diff --git a/error/GraphQLError.js.flow b/error/GraphQLError.js.flow
index ecd7997..89e540e 100644
--- a/error/GraphQLError.js.flow
+++ b/error/GraphQLError.js.flow
@@ -95,7 +95,7 @@ export function GraphQLError( // eslint-disable-line no-redeclare
   source?: ?Source,
   positions?: ?$ReadOnlyArray<number>,
   path?: ?$ReadOnlyArray<string | number>,
-  originalError?: ?Error,
+  originalError?: ?Error & { +extensions: mixed },
   extensions?: ?{ [key: string]: mixed },
 ) {
   // Compute list of blame nodes.
@@ -139,8 +139,7 @@ export function GraphQLError( // eslint-disable-line no-redeclare
     }, []);
   }
 
-  const _extensions =
-    extensions || (originalError && (originalError: any).extensions);
+  const _extensions = extensions || (originalError && originalError.extensions);
 
   Object.defineProperties(this, {
     message: {
diff --git a/error/printError.js b/error/printError.js
index d40ea8a..80b7ed8 100644
--- a/error/printError.js
+++ b/error/printError.js
@@ -24,16 +24,57 @@ function printError(error) {
   var printedLocations = [];
 
   if (error.nodes) {
-    error.nodes.forEach(function (node) {
-      if (node.loc) {
-        printedLocations.push(highlightSourceAtLocation(node.loc.source, (0, _location.getLocation)(node.loc.source, node.loc.start)));
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
+    try {
+      for (var _iterator = error.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+        var node = _step.value;
+
+        if (node.loc) {
+          printedLocations.push(highlightSourceAtLocation(node.loc.source, (0, _location.getLocation)(node.loc.source, node.loc.start)));
+        }
       }
-    });
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return != null) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
+    }
   } else if (error.source && error.locations) {
     var source = error.source;
-    error.locations.forEach(function (location) {
-      printedLocations.push(highlightSourceAtLocation(source, location));
-    });
+    var _iteratorNormalCompletion2 = true;
+    var _didIteratorError2 = false;
+    var _iteratorError2 = undefined;
+
+    try {
+      for (var _iterator2 = error.locations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+        var location = _step2.value;
+        printedLocations.push(highlightSourceAtLocation(source, location));
+      }
+    } catch (err) {
+      _didIteratorError2 = true;
+      _iteratorError2 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+          _iterator2.return();
+        }
+      } finally {
+        if (_didIteratorError2) {
+          throw _iteratorError2;
+        }
+      }
+    }
   }
 
   return printedLocations.length === 0 ? error.message : [error.message].concat(printedLocations).join('\n\n') + '\n';
@@ -64,27 +105,27 @@ function printPrefixedLines(lines) {
     return line !== undefined;
   });
   var padLen = 0;
-  var _iteratorNormalCompletion = true;
-  var _didIteratorError = false;
-  var _iteratorError = undefined;
+  var _iteratorNormalCompletion3 = true;
+  var _didIteratorError3 = false;
+  var _iteratorError3 = undefined;
 
   try {
-    for (var _iterator = existingLines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
-      var _ref4 = _step.value;
+    for (var _iterator3 = existingLines[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
+      var _ref4 = _step3.value;
       var prefix = _ref4[0];
       padLen = Math.max(padLen, prefix.length);
     }
   } catch (err) {
-    _didIteratorError = true;
-    _iteratorError = err;
+    _didIteratorError3 = true;
+    _iteratorError3 = err;
   } finally {
     try {
-      if (!_iteratorNormalCompletion && _iterator.return != null) {
-        _iterator.return();
+      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
+        _iterator3.return();
       }
     } finally {
-      if (_didIteratorError) {
-        throw _iteratorError;
+      if (_didIteratorError3) {
+        throw _iteratorError3;
       }
     }
   }
diff --git a/error/printError.js.flow b/error/printError.js.flow
index 1741464..9012640 100644
--- a/error/printError.js.flow
+++ b/error/printError.js.flow
@@ -19,7 +19,7 @@ import type { GraphQLError } from './GraphQLError';
 export function printError(error: GraphQLError): string {
   const printedLocations = [];
   if (error.nodes) {
-    error.nodes.forEach(node => {
+    for (const node of error.nodes) {
       if (node.loc) {
         printedLocations.push(
           highlightSourceAtLocation(
@@ -28,12 +28,12 @@ export function printError(error: GraphQLError): string {
           ),
         );
       }
-    });
+    }
   } else if (error.source && error.locations) {
     const source = error.source;
-    error.locations.forEach(location => {
+    for (const location of error.locations) {
       printedLocations.push(highlightSourceAtLocation(source, location));
-    });
+    }
   }
   return printedLocations.length === 0
     ? error.message
diff --git a/error/printError.mjs b/error/printError.mjs
index 256666a..a65d873 100644
--- a/error/printError.mjs
+++ b/error/printError.mjs
@@ -16,16 +16,57 @@ export function printError(error) {
   var printedLocations = [];
 
   if (error.nodes) {
-    error.nodes.forEach(function (node) {
-      if (node.loc) {
-        printedLocations.push(highlightSourceAtLocation(node.loc.source, getLocation(node.loc.source, node.loc.start)));
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
+    try {
+      for (var _iterator = error.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+        var node = _step.value;
+
+        if (node.loc) {
+          printedLocations.push(highlightSourceAtLocation(node.loc.source, getLocation(node.loc.source, node.loc.start)));
+        }
       }
-    });
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return != null) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
+    }
   } else if (error.source && error.locations) {
     var source = error.source;
-    error.locations.forEach(function (location) {
-      printedLocations.push(highlightSourceAtLocation(source, location));
-    });
+    var _iteratorNormalCompletion2 = true;
+    var _didIteratorError2 = false;
+    var _iteratorError2 = undefined;
+
+    try {
+      for (var _iterator2 = error.locations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+        var location = _step2.value;
+        printedLocations.push(highlightSourceAtLocation(source, location));
+      }
+    } catch (err) {
+      _didIteratorError2 = true;
+      _iteratorError2 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+          _iterator2.return();
+        }
+      } finally {
+        if (_didIteratorError2) {
+          throw _iteratorError2;
+        }
+      }
+    }
   }
 
   return printedLocations.length === 0 ? error.message : [error.message].concat(printedLocations).join('\n\n') + '\n';
@@ -55,27 +96,27 @@ function printPrefixedLines(lines) {
     return line !== undefined;
   });
   var padLen = 0;
-  var _iteratorNormalCompletion = true;
-  var _didIteratorError = false;
-  var _iteratorError = undefined;
+  var _iteratorNormalCompletion3 = true;
+  var _didIteratorError3 = false;
+  var _iteratorError3 = undefined;
 
   try {
-    for (var _iterator = existingLines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
-      var _ref4 = _step.value;
+    for (var _iterator3 = existingLines[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
+      var _ref4 = _step3.value;
       var prefix = _ref4[0];
       padLen = Math.max(padLen, prefix.length);
     }
   } catch (err) {
-    _didIteratorError = true;
-    _iteratorError = err;
+    _didIteratorError3 = true;
+    _iteratorError3 = err;
   } finally {
     try {
-      if (!_iteratorNormalCompletion && _iterator.return != null) {
-        _iterator.return();
+      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
+        _iterator3.return();
       }
     } finally {
-      if (_didIteratorError) {
-        throw _iteratorError;
+      if (_didIteratorError3) {
+        throw _iteratorError3;
       }
     }
   }
diff --git a/execution/execute.js b/execution/execute.js
index 2608a0e..55c23f5 100644
--- a/execution/execute.js
+++ b/execution/execute.js
@@ -44,8 +44,6 @@ var _values = require("./values");
 
 var _definition = require("../type/definition");
 
-var _schema = require("../type/schema");
-
 var _introspection = require("../type/introspection");
 
 var _directives = require("../type/directives");
@@ -668,7 +666,7 @@ function ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, field
   var runtimeType = typeof runtimeTypeOrName === 'string' ? exeContext.schema.getType(runtimeTypeOrName) : runtimeTypeOrName;
 
   if (!(0, _definition.isObjectType)(runtimeType)) {
-    throw new _error.GraphQLError("Abstract type ".concat(returnType.name, " must resolve to an Object type at ") + "runtime for field ".concat(info.parentType.name, ".").concat(info.fieldName, " with ") + "value \"".concat((0, _inspect.default)(result), "\", received \"").concat((0, _inspect.default)(runtimeType), "\". ") + "Either the ".concat(returnType.name, " type should provide a \"resolveType\" ") + 'function or each possible types should provide an ' + '"isTypeOf" function.', fieldNodes);
+    throw new _error.GraphQLError("Abstract type ".concat(returnType.name, " must resolve to an Object type at ") + "runtime for field ".concat(info.parentType.name, ".").concat(info.fieldName, " with ") + "value ".concat((0, _inspect.default)(result), ", received \"").concat((0, _inspect.default)(runtimeType), "\". ") + "Either the ".concat(returnType.name, " type should provide a \"resolveType\" ") + 'function or each possible type should provide an ' + '"isTypeOf" function.', fieldNodes);
   }
 
   if (!exeContext.schema.isPossibleType(returnType, runtimeType)) {
diff --git a/execution/execute.js.flow b/execution/execute.js.flow
index fb04bd6..d1d5d3d 100644
--- a/execution/execute.js.flow
+++ b/execution/execute.js.flow
@@ -46,7 +46,7 @@ import type {
   ResponsePath,
   GraphQLList,
 } from '../type/definition';
-import { GraphQLSchema } from '../type/schema';
+import type { GraphQLSchema } from '../type/schema';
 import {
   SchemaMetaFieldDef,
   TypeMetaFieldDef,
@@ -1046,9 +1046,9 @@ function ensureValidRuntimeType(
     throw new GraphQLError(
       `Abstract type ${returnType.name} must resolve to an Object type at ` +
         `runtime for field ${info.parentType.name}.${info.fieldName} with ` +
-        `value "${inspect(result)}", received "${inspect(runtimeType)}". ` +
+        `value ${inspect(result)}, received "${inspect(runtimeType)}". ` +
         `Either the ${returnType.name} type should provide a "resolveType" ` +
-        'function or each possible types should provide an ' +
+        'function or each possible type should provide an ' +
         '"isTypeOf" function.',
       fieldNodes,
     );
diff --git a/execution/execute.mjs b/execution/execute.mjs
index 8e5e9a1..c3a009d 100644
--- a/execution/execute.mjs
+++ b/execution/execute.mjs
@@ -23,7 +23,6 @@ import { typeFromAST } from '../utilities/typeFromAST';
 import { Kind } from '../language/kinds';
 import { getVariableValues, getArgumentValues, getDirectiveValues } from './values';
 import { isObjectType, isAbstractType, isLeafType, isListType, isNonNullType } from '../type/definition';
-import { GraphQLSchema } from '../type/schema';
 import { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection';
 import { GraphQLIncludeDirective, GraphQLSkipDirective } from '../type/directives';
 import { assertValidSchema } from '../type/validate';
@@ -632,7 +631,7 @@ function ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, field
   var runtimeType = typeof runtimeTypeOrName === 'string' ? exeContext.schema.getType(runtimeTypeOrName) : runtimeTypeOrName;
 
   if (!isObjectType(runtimeType)) {
-    throw new GraphQLError("Abstract type ".concat(returnType.name, " must resolve to an Object type at ") + "runtime for field ".concat(info.parentType.name, ".").concat(info.fieldName, " with ") + "value \"".concat(inspect(result), "\", received \"").concat(inspect(runtimeType), "\". ") + "Either the ".concat(returnType.name, " type should provide a \"resolveType\" ") + 'function or each possible types should provide an ' + '"isTypeOf" function.', fieldNodes);
+    throw new GraphQLError("Abstract type ".concat(returnType.name, " must resolve to an Object type at ") + "runtime for field ".concat(info.parentType.name, ".").concat(info.fieldName, " with ") + "value ".concat(inspect(result), ", received \"").concat(inspect(runtimeType), "\". ") + "Either the ".concat(returnType.name, " type should provide a \"resolveType\" ") + 'function or each possible type should provide an ' + '"isTypeOf" function.', fieldNodes);
   }
 
   if (!exeContext.schema.isPossibleType(returnType, runtimeType)) {
diff --git a/execution/values.js b/execution/values.js
index 687da77..06308bb 100644
--- a/execution/values.js
+++ b/execution/values.js
@@ -53,7 +53,7 @@ function getVariableValues(schema, varDefNodes, inputs) {
   var errors = [];
   var coercedValues = {};
 
-  var _loop = function _loop(i) {
+  for (var i = 0; i < varDefNodes.length; i++) {
     var varDefNode = varDefNodes[i];
     var varName = varDefNode.variable.name.value;
     var varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
@@ -82,25 +82,41 @@ function getVariableValues(schema, varDefNodes, inputs) {
         } else {
           // Otherwise, a non-null value was provided, coerce it to the expected
           // type or report an error if coercion fails.
-          var _coerced = (0, _coerceValue.coerceValue)(value, varType, varDefNode);
-
-          var coercionErrors = _coerced.errors;
+          var coerced = (0, _coerceValue.coerceValue)(value, varType, varDefNode);
+          var coercionErrors = coerced.errors;
 
           if (coercionErrors) {
-            coercionErrors.forEach(function (error) {
-              error.message = "Variable \"$".concat(varName, "\" got invalid ") + "value ".concat(JSON.stringify(value), "; ").concat(error.message);
-            });
+            var _iteratorNormalCompletion = true;
+            var _didIteratorError = false;
+            var _iteratorError = undefined;
+
+            try {
+              for (var _iterator = coercionErrors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+                var error = _step.value;
+                error.message = "Variable \"$".concat(varName, "\" got invalid ") + "value ".concat((0, _inspect.default)(value), "; ").concat(error.message);
+              }
+            } catch (err) {
+              _didIteratorError = true;
+              _iteratorError = err;
+            } finally {
+              try {
+                if (!_iteratorNormalCompletion && _iterator.return != null) {
+                  _iterator.return();
+                }
+              } finally {
+                if (_didIteratorError) {
+                  throw _iteratorError;
+                }
+              }
+            }
+
             errors.push.apply(errors, coercionErrors);
           } else {
-            coercedValues[varName] = _coerced.value;
+            coercedValues[varName] = coerced.value;
           }
         }
       }
     }
-  };
-
-  for (var i = 0; i < varDefNodes.length; i++) {
-    _loop(i);
   }
 
   return errors.length === 0 ? {
diff --git a/execution/values.js.flow b/execution/values.js.flow
index 5df2440..0f8a9bd 100644
--- a/execution/values.js.flow
+++ b/execution/values.js.flow
@@ -96,11 +96,11 @@ export function getVariableValues(
           const coerced = coerceValue(value, varType, varDefNode);
           const coercionErrors = coerced.errors;
           if (coercionErrors) {
-            coercionErrors.forEach(error => {
+            for (const error of coercionErrors) {
               error.message =
                 `Variable "$${varName}" got invalid ` +
-                `value ${JSON.stringify(value)}; ${error.message}`;
-            });
+                `value ${inspect(value)}; ${error.message}`;
+            }
             errors.push(...coercionErrors);
           } else {
             coercedValues[varName] = coerced.value;
diff --git a/execution/values.mjs b/execution/values.mjs
index 3051d69..3ef3656 100644
--- a/execution/values.mjs
+++ b/execution/values.mjs
@@ -31,7 +31,7 @@ export function getVariableValues(schema, varDefNodes, inputs) {
   var errors = [];
   var coercedValues = {};
 
-  var _loop = function _loop(i) {
+  for (var i = 0; i < varDefNodes.length; i++) {
     var varDefNode = varDefNodes[i];
     var varName = varDefNode.variable.name.value;
     var varType = typeFromAST(schema, varDefNode.type);
@@ -60,25 +60,41 @@ export function getVariableValues(schema, varDefNodes, inputs) {
         } else {
           // Otherwise, a non-null value was provided, coerce it to the expected
           // type or report an error if coercion fails.
-          var _coerced = coerceValue(value, varType, varDefNode);
-
-          var coercionErrors = _coerced.errors;
+          var coerced = coerceValue(value, varType, varDefNode);
+          var coercionErrors = coerced.errors;
 
           if (coercionErrors) {
-            coercionErrors.forEach(function (error) {
-              error.message = "Variable \"$".concat(varName, "\" got invalid ") + "value ".concat(JSON.stringify(value), "; ").concat(error.message);
-            });
+            var _iteratorNormalCompletion = true;
+            var _didIteratorError = false;
+            var _iteratorError = undefined;
+
+            try {
+              for (var _iterator = coercionErrors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+                var error = _step.value;
+                error.message = "Variable \"$".concat(varName, "\" got invalid ") + "value ".concat(inspect(value), "; ").concat(error.message);
+              }
+            } catch (err) {
+              _didIteratorError = true;
+              _iteratorError = err;
+            } finally {
+              try {
+                if (!_iteratorNormalCompletion && _iterator.return != null) {
+                  _iterator.return();
+                }
+              } finally {
+                if (_didIteratorError) {
+                  throw _iteratorError;
+                }
+              }
+            }
+
             errors.push.apply(errors, coercionErrors);
           } else {
-            coercedValues[varName] = _coerced.value;
+            coercedValues[varName] = coerced.value;
           }
         }
       }
     }
-  };
-
-  for (var i = 0; i < varDefNodes.length; i++) {
-    _loop(i);
   }
 
   return errors.length === 0 ? {
diff --git a/graphql.js b/graphql.js
index 1c2ed25..42992f0 100644
--- a/graphql.js
+++ b/graphql.js
@@ -41,6 +41,7 @@ function graphql(argsOrSchema, source, rootValue, contextValue, variableValues,
 
 
 function graphqlSync(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver) {
+  /* eslint-enable no-redeclare */
   // Extract arguments from object args if provided.
   var result = arguments.length === 1 ? graphqlImpl(argsOrSchema.schema, argsOrSchema.source, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver) : graphqlImpl(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver); // Assert that the execution was synchronous.
 
diff --git a/graphql.js.flow b/graphql.js.flow
index 8b0fe06..ab93016 100644
--- a/graphql.js.flow
+++ b/graphql.js.flow
@@ -36,6 +36,11 @@ import type { MaybePromise } from './jsutils/MaybePromise';
  * rootValue:
  *    The value provided as the first argument to resolver functions on the top
  *    level type (e.g. the query object type).
+ * contextValue:
+ *    The context value is provided as an argument to resolver functions after
+ *    field arguments. It is used to pass shared information useful at any point
+ *    during executing this query, for example the currently logged in user and
+ *    connections to databases or other services.
  * variableValues:
  *    A mapping of variable name to runtime value to use for all variables
  *    defined in the requestString.
@@ -131,6 +136,7 @@ export function graphqlSync(
   operationName,
   fieldResolver,
 ) {
+  /* eslint-enable no-redeclare */
   // Extract arguments from object args if provided.
   const result =
     arguments.length === 1
diff --git a/graphql.mjs b/graphql.mjs
index 0e75166..af7509a 100644
--- a/graphql.mjs
+++ b/graphql.mjs
@@ -28,6 +28,7 @@ export function graphql(argsOrSchema, source, rootValue, contextValue, variableV
  */
 
 export function graphqlSync(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver) {
+  /* eslint-enable no-redeclare */
   // Extract arguments from object args if provided.
   var result = arguments.length === 1 ? graphqlImpl(argsOrSchema.schema, argsOrSchema.source, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver) : graphqlImpl(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver); // Assert that the execution was synchronous.
 
diff --git a/index.js b/index.js
index 94a30f3..fe474bd 100644
--- a/index.js
+++ b/index.js
@@ -141,6 +141,12 @@ Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
     return _type.GraphQLDeprecatedDirective;
   }
 });
+Object.defineProperty(exports, "GraphQLIAMDirective", {
+  enumerable: true,
+  get: function get() {
+    return _type.GraphQLIAMDirective;
+  }
+});
 Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
   enumerable: true,
   get: function get() {
diff --git a/index.js.flow b/index.js.flow
index 697734c..1d14365 100644
--- a/index.js.flow
+++ b/index.js.flow
@@ -62,6 +62,7 @@ export {
   GraphQLIncludeDirective,
   GraphQLSkipDirective,
   GraphQLDeprecatedDirective,
+  GraphQLIAMDirective,
   // Constant Deprecation Reason
   DEFAULT_DEPRECATION_REASON,
   // Meta-field definitions.
@@ -165,6 +166,9 @@ export type {
   GraphQLTypeResolver,
   GraphQLUnionTypeConfig,
   GraphQLDirectiveConfig,
+  GraphQLScalarSerializer,
+  GraphQLScalarValueParser,
+  GraphQLScalarLiteralParser,
 } from './type';
 
 // Parse and operate on GraphQL language source files.
@@ -316,7 +320,7 @@ export {
   // Produce the GraphQL query recommended for a full schema introspection.
   // Accepts optional IntrospectionOptions.
   getIntrospectionQuery,
-  // Deprecated: use getIntrospectionQuery
+  // @deprecated: use getIntrospectionQuery - will be removed in v15
   introspectionQuery,
   // Gets the target Operation from a Document
   getOperationAST,
@@ -330,7 +334,8 @@ export {
   buildASTSchema,
   // Build a GraphQLSchema from a GraphQL schema language document.
   buildSchema,
-  // Get the description from a schema AST node.
+  // @deprecated: Get the description from a schema AST node and supports legacy
+  // syntax for specifying descriptions - will be removed in v16
   getDescription,
   // Extends an existing GraphQLSchema from a parsed GraphQL Schema
   // language AST.
@@ -357,9 +362,9 @@ export {
   TypeInfo,
   // Coerces a JavaScript value to a GraphQL type, or produces errors.
   coerceValue,
-  // @deprecated use coerceValue
+  // @deprecated use coerceValue - will be removed in v15
   isValidJSValue,
-  // Determine if AST values adhere to a GraphQL type.
+  // @deprecated use validation - will be removed in v15
   isValidLiteralValue,
   // Concatenates multiple AST together.
   concatAST,
diff --git a/index.mjs b/index.mjs
index 9088204..dec7ca8 100644
--- a/index.mjs
+++ b/index.mjs
@@ -37,7 +37,7 @@ export { GraphQLSchema, // Definitions
 GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, GraphQLDirective, // "Enum" of Type Kinds
 TypeKind, // Scalars
 specifiedScalarTypes, GraphQLInt, GraphQLFloat, GraphQLString, GraphQLBoolean, GraphQLID, // Built-in Directives defined by the Spec
-specifiedDirectives, GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, // Constant Deprecation Reason
+specifiedDirectives, GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, GraphQLIAMDirective, // Constant Deprecation Reason
 DEFAULT_DEPRECATION_REASON, // Meta-field definitions.
 SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, // GraphQL Types for introspection.
 introspectionTypes, __Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, __TypeKind, // Predicates
@@ -62,14 +62,15 @@ export { GraphQLError, formatError, printError } from './error';
 // Utilities for operating on GraphQL type schema and parsed sources.
 export { // Produce the GraphQL query recommended for a full schema introspection.
 // Accepts optional IntrospectionOptions.
-getIntrospectionQuery, // Deprecated: use getIntrospectionQuery
+getIntrospectionQuery, // @deprecated: use getIntrospectionQuery - will be removed in v15
 introspectionQuery, // Gets the target Operation from a Document
 getOperationAST, // Gets the Type for the target Operation AST.
 getOperationRootType, // Convert a GraphQLSchema to an IntrospectionQuery
 introspectionFromSchema, // Build a GraphQLSchema from an introspection result.
 buildClientSchema, // Build a GraphQLSchema from a parsed GraphQL Schema language AST.
 buildASTSchema, // Build a GraphQLSchema from a GraphQL schema language document.
-buildSchema, // Get the description from a schema AST node.
+buildSchema, // @deprecated: Get the description from a schema AST node and supports legacy
+// syntax for specifying descriptions - will be removed in v16
 getDescription, // Extends an existing GraphQLSchema from a parsed GraphQL Schema
 // language AST.
 extendSchema, // Sort a GraphQLSchema.
@@ -84,8 +85,8 @@ valueFromASTUntyped, // Create a GraphQL language AST from a JavaScript value.
 astFromValue, // A helper to use within recursive-descent visitors which need to be aware of
 // the GraphQL type system.
 TypeInfo, // Coerces a JavaScript value to a GraphQL type, or produces errors.
-coerceValue, // @deprecated use coerceValue
-isValidJSValue, // Determine if AST values adhere to a GraphQL type.
+coerceValue, // @deprecated use coerceValue - will be removed in v15
+isValidJSValue, // @deprecated use validation - will be removed in v15
 isValidLiteralValue, // Concatenates multiple AST together.
 concatAST, // Separates an AST into an AST per Operation.
 separateOperations, // Comparators for types
diff --git a/jsutils/dedent.js b/jsutils/dedent.js
index 6dfa875..71f3792 100644
--- a/jsutils/dedent.js
+++ b/jsutils/dedent.js
@@ -5,6 +5,10 @@ Object.defineProperty(exports, "__esModule", {
 });
 exports.default = dedent;
 
+var _invariant = _interopRequireDefault(require("./invariant"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
 /**
  * Copyright (c) 2017-present, Facebook, Inc.
  *
@@ -21,7 +25,9 @@ function fixIndent(str) {
   var trimmedStr = str.replace(/^\n*/m, '') //  remove leading newline
   .replace(/[ \t]*$/, ''); // remove trailing spaces and tabs
 
-  var indent = /^[ \t]*/.exec(trimmedStr)[0]; // figure out indent
+  var indentMatch = /^[ \t]*/.exec(trimmedStr);
+  !Array.isArray(indentMatch) ? (0, _invariant.default)(0) : void 0;
+  var indent = indentMatch[0]; // figure out indent
 
   return trimmedStr.replace(RegExp('^' + indent, 'mg'), ''); // remove indent
 }
diff --git a/jsutils/dedent.js.flow b/jsutils/dedent.js.flow
index 0239266..8158198 100644
--- a/jsutils/dedent.js.flow
+++ b/jsutils/dedent.js.flow
@@ -7,6 +7,8 @@
  * @flow strict
  */
 
+import invariant from './invariant';
+
 /**
  * fixes indentation by removing leading spaces and tabs from each line
  */
@@ -14,7 +16,9 @@ function fixIndent(str: string): string {
   const trimmedStr = str
     .replace(/^\n*/m, '') //  remove leading newline
     .replace(/[ \t]*$/, ''); // remove trailing spaces and tabs
-  const indent = /^[ \t]*/.exec(trimmedStr)[0]; // figure out indent
+  const indentMatch = /^[ \t]*/.exec(trimmedStr);
+  invariant(Array.isArray(indentMatch));
+  const indent = indentMatch[0]; // figure out indent
   return trimmedStr.replace(RegExp('^' + indent, 'mg'), ''); // remove indent
 }
 
diff --git a/jsutils/dedent.mjs b/jsutils/dedent.mjs
index ff12dfa..69293f7 100644
--- a/jsutils/dedent.mjs
+++ b/jsutils/dedent.mjs
@@ -6,15 +6,18 @@
  *
  *  strict
  */
-
+import invariant from './invariant';
 /**
  * fixes indentation by removing leading spaces and tabs from each line
  */
+
 function fixIndent(str) {
   var trimmedStr = str.replace(/^\n*/m, '') //  remove leading newline
   .replace(/[ \t]*$/, ''); // remove trailing spaces and tabs
 
-  var indent = /^[ \t]*/.exec(trimmedStr)[0]; // figure out indent
+  var indentMatch = /^[ \t]*/.exec(trimmedStr);
+  !Array.isArray(indentMatch) ? invariant(0) : void 0;
+  var indent = indentMatch[0]; // figure out indent
 
   return trimmedStr.replace(RegExp('^' + indent, 'mg'), ''); // remove indent
 }
diff --git a/jsutils/defineToJSON.js b/jsutils/defineToJSON.js
new file mode 100644
index 0000000..b5a2513
--- /dev/null
+++ b/jsutils/defineToJSON.js
@@ -0,0 +1,23 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = applyToJSON;
+
+/**
+ * Copyright (c) 2015-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *  strict
+ */
+
+/**
+ * The `applyToJSON()` function defines toJSON() and inspect() prototype
+ * methods which are aliases for toString().
+ */
+function applyToJSON(classObject) {
+  classObject.prototype.toJSON = classObject.prototype.inspect = classObject.prototype.toString;
+}
\ No newline at end of file
diff --git a/jsutils/defineToJSON.js.flow b/jsutils/defineToJSON.js.flow
new file mode 100644
index 0000000..fde3f6c
--- /dev/null
+++ b/jsutils/defineToJSON.js.flow
@@ -0,0 +1,17 @@
+/**
+ * Copyright (c) 2015-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow strict
+ */
+
+/**
+ * The `applyToJSON()` function defines toJSON() and inspect() prototype
+ * methods which are aliases for toString().
+ */
+export default function applyToJSON(classObject: Class<any>): void {
+  classObject.prototype.toJSON = classObject.prototype.inspect =
+    classObject.prototype.toString;
+}
diff --git a/jsutils/defineToJSON.mjs b/jsutils/defineToJSON.mjs
new file mode 100644
index 0000000..ba22494
--- /dev/null
+++ b/jsutils/defineToJSON.mjs
@@ -0,0 +1,16 @@
+/**
+ * Copyright (c) 2015-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *  strict
+ */
+
+/**
+ * The `applyToJSON()` function defines toJSON() and inspect() prototype
+ * methods which are aliases for toString().
+ */
+export default function applyToJSON(classObject) {
+  classObject.prototype.toJSON = classObject.prototype.inspect = classObject.prototype.toString;
+}
\ No newline at end of file
diff --git a/jsutils/applyToStringTag.js b/jsutils/defineToStringTag.js
similarity index 52%
rename from dist/jsutils/applyToStringTag.js
rename to dist/jsutils/defineToStringTag.js
index 195d7f5..fedef31 100644
--- a/jsutils/applyToStringTag.js
+++ b/jsutils/defineToStringTag.js
@@ -3,10 +3,7 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.applyToStringTag = applyToStringTag;
-exports.default = void 0;
-
-function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+exports.default = applyToStringTag;
 
 /**
  * Copyright (c) 2015-present, Facebook, Inc.
@@ -26,25 +23,16 @@ function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterat
  *
  * @method applyToStringTag
  *
- * @param {Class<*>} classObject a class such as Object, String, Number but
+ * @param {Class<any>} classObject a class such as Object, String, Number but
  * typically one of your own creation through the class keyword; `class A {}`,
  * for example.
  */
 function applyToStringTag(classObject) {
-  var symbolType = typeof Symbol === "undefined" ? "undefined" : _typeof(Symbol);
-
-  var toStringTagType = _typeof(Symbol.toStringTag);
-
-  if (symbolType === 'function' && toStringTagType === 'symbol') {
+  if (typeof Symbol === 'function' && Symbol.toStringTag) {
     Object.defineProperty(classObject.prototype, Symbol.toStringTag, {
       get: function get() {
         return this.constructor.name;
       }
     });
   }
-}
-/** Support both default export and named `applyToStringTag` export */
-
-
-var _default = applyToStringTag;
-exports.default = _default;
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/jsutils/applyToStringTag.js.flow b/jsutils/defineToStringTag.js.flow
similarity index 66%
rename from dist/jsutils/applyToStringTag.js.flow
rename to dist/jsutils/defineToStringTag.js.flow
index 9da9b3e..f539cde 100644
--- a/jsutils/applyToStringTag.js.flow
+++ b/jsutils/defineToStringTag.js.flow
@@ -16,15 +16,12 @@
  *
  * @method applyToStringTag
  *
- * @param {Class<*>} classObject a class such as Object, String, Number but
+ * @param {Class<any>} classObject a class such as Object, String, Number but
  * typically one of your own creation through the class keyword; `class A {}`,
  * for example.
  */
-export function applyToStringTag(classObject: Class<*>): void {
-  const symbolType: string = typeof Symbol;
-  const toStringTagType: string = typeof Symbol.toStringTag;
-
-  if (symbolType === 'function' && toStringTagType === 'symbol') {
+export default function applyToStringTag(classObject: Class<any>): void {
+  if (typeof Symbol === 'function' && Symbol.toStringTag) {
     Object.defineProperty(classObject.prototype, Symbol.toStringTag, {
       get() {
         return this.constructor.name;
@@ -32,6 +29,3 @@ export function applyToStringTag(classObject: Class<*>): void {
     });
   }
 }
-
-/** Support both default export and named `applyToStringTag` export */
-export default applyToStringTag;
diff --git a/jsutils/applyToStringTag.mjs b/jsutils/defineToStringTag.mjs
similarity index 51%
rename from dist/jsutils/applyToStringTag.mjs
rename to dist/jsutils/defineToStringTag.mjs
index 5029643..ed0d728 100644
--- a/jsutils/applyToStringTag.mjs
+++ b/jsutils/defineToStringTag.mjs
@@ -1,5 +1,3 @@
-function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
-
 /**
  * Copyright (c) 2015-present, Facebook, Inc.
  *
@@ -18,23 +16,16 @@ function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterat
  *
  * @method applyToStringTag
  *
- * @param {Class<*>} classObject a class such as Object, String, Number but
+ * @param {Class<any>} classObject a class such as Object, String, Number but
  * typically one of your own creation through the class keyword; `class A {}`,
  * for example.
  */
-export function applyToStringTag(classObject) {
-  var symbolType = typeof Symbol === "undefined" ? "undefined" : _typeof(Symbol);
-
-  var toStringTagType = _typeof(Symbol.toStringTag);
-
-  if (symbolType === 'function' && toStringTagType === 'symbol') {
+export default function applyToStringTag(classObject) {
+  if (typeof Symbol === 'function' && Symbol.toStringTag) {
     Object.defineProperty(classObject.prototype, Symbol.toStringTag, {
       get: function get() {
         return this.constructor.name;
       }
     });
   }
-}
-/** Support both default export and named `applyToStringTag` export */
-
-export default applyToStringTag;
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/jsutils/inspect.js b/jsutils/inspect.js
index c5f67c8..f869425 100644
--- a/jsutils/inspect.js
+++ b/jsutils/inspect.js
@@ -5,6 +5,8 @@ Object.defineProperty(exports, "__esModule", {
 });
 exports.default = inspect;
 
+function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
 /**
  * Copyright (c) 2015-present, Facebook, Inc.
  *
@@ -13,10 +15,12 @@ exports.default = inspect;
  *
  *  strict
  */
-function inspect(value) {
-  if (Array.isArray(value)) {
-    return '[' + String(value) + ']';
-  }
 
-  return String(value);
+/**
+ * Used to print values in error messages.
+ */
+function inspect(value) {
+  return value && _typeof(value) === 'object' ? typeof value.inspect === 'function' ? value.inspect() : Array.isArray(value) ? '[' + value.map(inspect).join(', ') + ']' : '{' + Object.keys(value).map(function (k) {
+    return "".concat(k, ": ").concat(inspect(value[k]));
+  }).join(', ') + '}' : typeof value === 'string' ? '"' + value + '"' : typeof value === 'function' ? "[function ".concat(value.name, "]") : String(value);
 }
\ No newline at end of file
diff --git a/jsutils/inspect.js.flow b/jsutils/inspect.js.flow
index 70bc6bd..6870175 100644
--- a/jsutils/inspect.js.flow
+++ b/jsutils/inspect.js.flow
@@ -7,9 +7,23 @@
  * @flow strict
  */
 
+/**
+ * Used to print values in error messages.
+ */
 export default function inspect(value: mixed): string {
-  if (Array.isArray(value)) {
-    return '[' + String(value) + ']';
-  }
-  return String(value);
+  return value && typeof value === 'object'
+    ? typeof value.inspect === 'function'
+      ? value.inspect()
+      : Array.isArray(value)
+        ? '[' + value.map(inspect).join(', ') + ']'
+        : '{' +
+          Object.keys(value)
+            .map(k => `${k}: ${inspect(value[k])}`)
+            .join(', ') +
+          '}'
+    : typeof value === 'string'
+      ? '"' + value + '"'
+      : typeof value === 'function'
+        ? `[function ${value.name}]`
+        : String(value);
 }
diff --git a/jsutils/inspect.mjs b/jsutils/inspect.mjs
index e7ca997..4b7e40d 100644
--- a/jsutils/inspect.mjs
+++ b/jsutils/inspect.mjs
@@ -1,3 +1,5 @@
+function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
 /**
  * Copyright (c) 2015-present, Facebook, Inc.
  *
@@ -6,10 +8,12 @@
  *
  *  strict
  */
-export default function inspect(value) {
-  if (Array.isArray(value)) {
-    return '[' + String(value) + ']';
-  }
 
-  return String(value);
+/**
+ * Used to print values in error messages.
+ */
+export default function inspect(value) {
+  return value && _typeof(value) === 'object' ? typeof value.inspect === 'function' ? value.inspect() : Array.isArray(value) ? '[' + value.map(inspect).join(', ') + ']' : '{' + Object.keys(value).map(function (k) {
+    return "".concat(k, ": ").concat(inspect(value[k]));
+  }).join(', ') + '}' : typeof value === 'string' ? '"' + value + '"' : typeof value === 'function' ? "[function ".concat(value.name, "]") : String(value);
 }
\ No newline at end of file
diff --git a/jsutils/instanceOf.js.flow b/jsutils/instanceOf.js.flow
index db485c3..1cb4d2a 100644
--- a/jsutils/instanceOf.js.flow
+++ b/jsutils/instanceOf.js.flow
@@ -20,7 +20,7 @@ declare function instanceOf(
 // See: https://webpack.js.org/guides/production/
 export default (process.env.NODE_ENV === 'production'
   ? // eslint-disable-next-line no-shadow
-    function instanceOf(value: any, constructor: any) {
+    function instanceOf(value: mixed, constructor: mixed) {
       return value instanceof constructor;
     }
   : // eslint-disable-next-line no-shadow
diff --git a/jsutils/isFinite.js b/jsutils/isFinite.js
new file mode 100644
index 0000000..5e5aa0c
--- /dev/null
+++ b/jsutils/isFinite.js
@@ -0,0 +1,24 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+/**
+ * Copyright (c) 2018-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *  strict
+ */
+
+/* eslint-disable no-redeclare */
+// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441
+var isFinite = Number.isFinite || function (value) {
+  return typeof value === 'number' && isFinite(value);
+};
+
+var _default = isFinite;
+exports.default = _default;
\ No newline at end of file
diff --git a/jsutils/isFinite.js.flow b/jsutils/isFinite.js.flow
new file mode 100644
index 0000000..a874a2d
--- /dev/null
+++ b/jsutils/isFinite.js.flow
@@ -0,0 +1,20 @@
+/**
+ * Copyright (c) 2018-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow strict
+ */
+
+declare function isFinite(value: mixed): boolean %checks(typeof value ===
+  'number');
+
+/* eslint-disable no-redeclare */
+// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441
+const isFinite =
+  Number.isFinite ||
+  function(value) {
+    return typeof value === 'number' && isFinite(value);
+  };
+export default isFinite;
diff --git a/jsutils/isFinite.mjs b/jsutils/isFinite.mjs
new file mode 100644
index 0000000..f6e317b
--- /dev/null
+++ b/jsutils/isFinite.mjs
@@ -0,0 +1,16 @@
+/**
+ * Copyright (c) 2018-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *  strict
+ */
+
+/* eslint-disable no-redeclare */
+// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441
+var isFinite = Number.isFinite || function (value) {
+  return typeof value === 'number' && isFinite(value);
+};
+
+export default isFinite;
\ No newline at end of file
diff --git a/language/parser.js.flow b/language/parser.js.flow
index 2876a7e..fdbfce0 100644
--- a/language/parser.js.flow
+++ b/language/parser.js.flow
@@ -84,7 +84,7 @@ export type ParseOptions = {
    * specification.
    *
    * This option is provided to ease adoption of the final SDL specification
-   * and will be removed in a future major release.
+   * and will be removed in v16.
    */
   allowLegacySDLEmptyFields?: boolean,
 
@@ -94,7 +94,7 @@ export type ParseOptions = {
    * current specification.
    *
    * This option is provided to ease adoption of the final SDL specification
-   * and will be removed in a future major release.
+   * and will be removed in v16.
    */
   allowLegacySDLImplementsInterfaces?: boolean,
 
diff --git a/language/source.js b/language/source.js
index 618b454..388bc90 100644
--- a/language/source.js
+++ b/language/source.js
@@ -7,7 +7,7 @@ exports.Source = void 0;
 
 var _invariant = _interopRequireDefault(require("../jsutils/invariant"));
 
-var _applyToStringTag = _interopRequireDefault(require("../jsutils/applyToStringTag"));
+var _defineToStringTag = _interopRequireDefault(require("../jsutils/defineToStringTag"));
 
 function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
 
@@ -40,4 +40,4 @@ var Source = function Source(body, name, locationOffset) {
 
 
 exports.Source = Source;
-(0, _applyToStringTag.default)(Source);
\ No newline at end of file
+(0, _defineToStringTag.default)(Source);
\ No newline at end of file
diff --git a/language/source.js.flow b/language/source.js.flow
index 14817b6..258249f 100644
--- a/language/source.js.flow
+++ b/language/source.js.flow
@@ -8,7 +8,7 @@
  */
 
 import invariant from '../jsutils/invariant';
-import applyToStringTag from '../jsutils/applyToStringTag';
+import defineToStringTag from '../jsutils/defineToStringTag';
 
 type Location = {
   line: number,
@@ -44,4 +44,4 @@ export class Source {
 }
 
 // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
-applyToStringTag(Source);
+defineToStringTag(Source);
diff --git a/language/source.mjs b/language/source.mjs
index c12a5da..fd1425e 100644
--- a/language/source.mjs
+++ b/language/source.mjs
@@ -9,7 +9,7 @@ function _defineProperty(obj, key, value) { if (key in obj) { Object.definePrope
  *  strict
  */
 import invariant from '../jsutils/invariant';
-import applyToStringTag from '../jsutils/applyToStringTag';
+import defineToStringTag from '../jsutils/defineToStringTag';
 
 /**
  * A representation of source input to GraphQL.
@@ -36,4 +36,4 @@ export var Source = function Source(body, name, locationOffset) {
   !(this.locationOffset.column > 0) ? invariant(0, 'column in locationOffset is 1-indexed and must be positive') : void 0;
 }; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
 
-applyToStringTag(Source);
\ No newline at end of file
+defineToStringTag(Source);
\ No newline at end of file
diff --git a/package.json b/package.json
index 43ea2bb..78c90b0 100644
--- a/package.json
+++ b/package.json
@@ -1,5 +1,5 @@
 {
-  "name": "graphql",
+  "name": "@blackbird/graphql",
   "version": "14.0.0-rc.2",
   "description": "A Query Language and Runtime which can target any service.",
   "license": "MIT",
@@ -18,7 +18,7 @@
     "mocha": "--check-leaks --full-trace --timeout 15000 src/**/__tests__/**/*-test.js"
   },
   "engines": {
-    "node": "6.x || 8.x || 9.x || >= 10.x"
+    "node": "6.x || 8.x || >= 10.x"
   },
   "dependencies": {
     "iterall": "^1.2.2"
diff --git a/subscription/subscribe.js b/subscription/subscribe.js
index c0926cf..c0134cd 100644
--- a/subscription/subscribe.js
+++ b/subscription/subscribe.js
@@ -16,8 +16,6 @@ var _locatedError = require("../error/locatedError");
 
 var _execute = require("../execution/execute");
 
-var _schema = require("../type/schema");
-
 var _mapAsyncIterator = _interopRequireDefault(require("./mapAsyncIterator"));
 
 var _getOperationRootType = require("../utilities/getOperationRootType");
diff --git a/subscription/subscribe.js.flow b/subscription/subscribe.js.flow
index b226567..ebd52f8 100644
--- a/subscription/subscribe.js.flow
+++ b/subscription/subscribe.js.flow
@@ -22,7 +22,7 @@ import {
   resolveFieldValueOrError,
   responsePathAsArray,
 } from '../execution/execute';
-import { GraphQLSchema } from '../type/schema';
+import type { GraphQLSchema } from '../type/schema';
 import mapAsyncIterator from './mapAsyncIterator';
 
 import type { ObjMap } from '../jsutils/ObjMap';
diff --git a/subscription/subscribe.mjs b/subscription/subscribe.mjs
index 32a2084..3ebca4f 100644
--- a/subscription/subscribe.mjs
+++ b/subscription/subscribe.mjs
@@ -11,7 +11,6 @@ import inspect from '../jsutils/inspect';
 import { GraphQLError } from '../error/GraphQLError';
 import { locatedError } from '../error/locatedError';
 import { addPath, assertValidExecutionArguments, buildExecutionContext, buildResolveInfo, collectFields, execute, getFieldDef, resolveFieldValueOrError, responsePathAsArray } from '../execution/execute';
-import { GraphQLSchema } from '../type/schema';
 import mapAsyncIterator from './mapAsyncIterator';
 import { getOperationRootType } from '../utilities/getOperationRootType';
 /**
diff --git a/type/definition.js b/type/definition.js
index 7636b29..ab73ab5 100644
--- a/type/definition.js
+++ b/type/definition.js
@@ -43,7 +43,9 @@ exports.assertNamedType = assertNamedType;
 exports.getNamedType = getNamedType;
 exports.GraphQLInputObjectType = exports.GraphQLEnumType = exports.GraphQLUnionType = exports.GraphQLInterfaceType = exports.GraphQLObjectType = exports.GraphQLScalarType = void 0;
 
-var _applyToStringTag = _interopRequireDefault(require("../jsutils/applyToStringTag"));
+var _defineToJSON = _interopRequireDefault(require("../jsutils/defineToJSON"));
+
+var _defineToStringTag = _interopRequireDefault(require("../jsutils/defineToStringTag"));
 
 var _instanceOf = _interopRequireDefault(require("../jsutils/instanceOf"));
 
@@ -249,14 +251,14 @@ function GraphQLList(ofType) {
   } else {
     return new GraphQLList(ofType);
   }
-} // Also provide toJSON and inspect aliases for toString.
-
+} // Need to cast through any to alter the prototype.
 
-var listProto = GraphQLList.prototype;
 
-listProto.toString = listProto.toJSON = listProto.inspect = function toString() {
+GraphQLList.prototype.toString = function toString() {
   return '[' + String(this.ofType) + ']';
 };
+
+(0, _defineToJSON.default)(GraphQLList);
 /**
  * Non-Null Type Wrapper
  *
@@ -278,7 +280,6 @@ listProto.toString = listProto.toJSON = listProto.inspect = function toString()
  * Note: the enforcement of non-nullability occurs within the executor.
  */
 
-
 // eslint-disable-next-line no-redeclare
 function GraphQLNonNull(ofType) {
   if (this instanceof GraphQLNonNull) {
@@ -286,19 +287,18 @@ function GraphQLNonNull(ofType) {
   } else {
     return new GraphQLNonNull(ofType);
   }
-} // Also provide toJSON and inspect aliases for toString.
-
+} // Need to cast through any to alter the prototype.
 
-var nonNullProto = GraphQLNonNull.prototype;
 
-nonNullProto.toString = nonNullProto.toJSON = nonNullProto.inspect = function toString() {
+GraphQLNonNull.prototype.toString = function toString() {
   return String(this.ofType) + '!';
 };
+
+(0, _defineToJSON.default)(GraphQLNonNull);
 /**
  * These types wrap and modify other types
  */
 
-
 function isWrappingType(type) {
   return isListType(type) || isNonNullType(type);
 }
@@ -400,46 +400,37 @@ function () {
 
     _defineProperty(this, "description", void 0);
 
-    _defineProperty(this, "astNode", void 0);
+    _defineProperty(this, "serialize", void 0);
 
-    _defineProperty(this, "_scalarConfig", void 0);
+    _defineProperty(this, "parseValue", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
+    _defineProperty(this, "parseLiteral", void 0);
 
-    _defineProperty(this, "inspect", void 0);
+    _defineProperty(this, "astNode", void 0);
+
+    _defineProperty(this, "extensionASTNodes", void 0);
 
     this.name = config.name;
     this.description = config.description;
+    this.serialize = config.serialize;
+
+    this.parseValue = config.parseValue || function (value) {
+      return value;
+    };
+
+    this.parseLiteral = config.parseLiteral || _valueFromASTUntyped.valueFromASTUntyped;
     this.astNode = config.astNode;
-    this._scalarConfig = config;
+    this.extensionASTNodes = config.extensionASTNodes;
     !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;
     !(typeof config.serialize === 'function') ? (0, _invariant.default)(0, "".concat(this.name, " must provide \"serialize\" function. If this custom Scalar ") + 'is also used as an input type, ensure "parseValue" and "parseLiteral" ' + 'functions are also provided.') : void 0;
 
     if (config.parseValue || config.parseLiteral) {
       !(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') ? (0, _invariant.default)(0, "".concat(this.name, " must provide both \"parseValue\" and \"parseLiteral\" ") + 'functions.') : void 0;
     }
-  } // Serializes an internal value to include in a response.
-
+  }
 
   var _proto = GraphQLScalarType.prototype;
 
-  _proto.serialize = function serialize(value) {
-    var serializer = this._scalarConfig.serialize;
-    return serializer(value);
-  }; // Parses an externally provided value to use as an input.
-
-
-  _proto.parseValue = function parseValue(value) {
-    var parser = this._scalarConfig.parseValue;
-    return parser ? parser(value) : value;
-  }; // Parses an externally provided literal value to use as an input.
-
-
-  _proto.parseLiteral = function parseLiteral(valueNode, variables) {
-    var parser = this._scalarConfig.parseLiteral;
-    return parser ? parser(valueNode, variables) : (0, _valueFromASTUntyped.valueFromASTUntyped)(valueNode, variables);
-  };
-
   _proto.toString = function toString() {
     return this.name;
   };
@@ -449,9 +440,8 @@ function () {
 
 
 exports.GraphQLScalarType = GraphQLScalarType;
-(0, _applyToStringTag.default)(GraphQLScalarType); // Also provide toJSON and inspect aliases for toString.
-
-GraphQLScalarType.prototype.toJSON = GraphQLScalarType.prototype.inspect = GraphQLScalarType.prototype.toString;
+(0, _defineToStringTag.default)(GraphQLScalarType);
+(0, _defineToJSON.default)(GraphQLScalarType);
 
 /**
  * Object Type Definition
@@ -504,37 +494,37 @@ function () {
 
     _defineProperty(this, "isTypeOf", void 0);
 
-    _defineProperty(this, "_typeConfig", void 0);
-
     _defineProperty(this, "_fields", void 0);
 
     _defineProperty(this, "_interfaces", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
-
-    _defineProperty(this, "inspect", void 0);
-
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
     this.extensionASTNodes = config.extensionASTNodes;
     this.isTypeOf = config.isTypeOf;
-    this._typeConfig = config;
+    this._fields = defineFieldMap.bind(undefined, config);
+    this._interfaces = defineInterfaces.bind(undefined, config);
     !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;
-
-    if (config.isTypeOf) {
-      !(typeof config.isTypeOf === 'function') ? (0, _invariant.default)(0, "".concat(this.name, " must provide \"isTypeOf\" as a function.")) : void 0;
-    }
+    !(config.isTypeOf == null || typeof config.isTypeOf === 'function') ? (0, _invariant.default)(0, "".concat(this.name, " must provide \"isTypeOf\" as a function, ") + "but got: ".concat((0, _inspect.default)(config.isTypeOf), ".")) : void 0;
   }
 
   var _proto2 = GraphQLObjectType.prototype;
 
   _proto2.getFields = function getFields() {
-    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));
+    if (typeof this._fields === 'function') {
+      this._fields = this._fields();
+    }
+
+    return this._fields;
   };
 
   _proto2.getInterfaces = function getInterfaces() {
-    return this._interfaces || (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces));
+    if (typeof this._interfaces === 'function') {
+      this._interfaces = this._interfaces();
+    }
+
+    return this._interfaces;
   };
 
   _proto2.toString = function toString() {
@@ -546,37 +536,40 @@ function () {
 
 
 exports.GraphQLObjectType = GraphQLObjectType;
-(0, _applyToStringTag.default)(GraphQLObjectType); // Also provide toJSON and inspect aliases for toString.
+(0, _defineToStringTag.default)(GraphQLObjectType);
+(0, _defineToJSON.default)(GraphQLObjectType);
 
-GraphQLObjectType.prototype.toJSON = GraphQLObjectType.prototype.inspect = GraphQLObjectType.prototype.toString;
-
-function defineInterfaces(type, interfacesThunk) {
-  var interfaces = resolveThunk(interfacesThunk) || [];
-  !Array.isArray(interfaces) ? (0, _invariant.default)(0, "".concat(type.name, " interfaces must be an Array or a function which returns ") + 'an Array.') : void 0;
+function defineInterfaces(config) {
+  var interfaces = resolveThunk(config.interfaces) || [];
+  !Array.isArray(interfaces) ? (0, _invariant.default)(0, "".concat(config.name, " interfaces must be an Array or a function which returns ") + 'an Array.') : void 0;
   return interfaces;
 }
 
-function defineFieldMap(type, fieldsThunk) {
-  var fieldMap = resolveThunk(fieldsThunk) || {};
-  !isPlainObj(fieldMap) ? (0, _invariant.default)(0, "".concat(type.name, " fields must be an object with field names as keys or a ") + 'function which returns such an object.') : void 0;
+function defineFieldMap(config) {
+  var fieldMap = resolveThunk(config.fields) || {};
+  !isPlainObj(fieldMap) ? (0, _invariant.default)(0, "".concat(config.name, " fields must be an object with field names as keys or a ") + 'function which returns such an object.') : void 0;
   var resultFieldMap = Object.create(null);
-  Object.keys(fieldMap).forEach(function (fieldName) {
+
+  var _arr = Object.keys(fieldMap);
+
+  var _loop = function _loop() {
+    var fieldName = _arr[_i];
     var fieldConfig = fieldMap[fieldName];
-    !isPlainObj(fieldConfig) ? (0, _invariant.default)(0, "".concat(type.name, ".").concat(fieldName, " field config must be an object")) : void 0;
-    !!fieldConfig.hasOwnProperty('isDeprecated') ? (0, _invariant.default)(0, "".concat(type.name, ".").concat(fieldName, " should provide \"deprecationReason\" instead ") + 'of "isDeprecated".') : void 0;
+    !isPlainObj(fieldConfig) ? (0, _invariant.default)(0, "".concat(config.name, ".").concat(fieldName, " field config must be an object")) : void 0;
+    !!fieldConfig.hasOwnProperty('isDeprecated') ? (0, _invariant.default)(0, "".concat(config.name, ".").concat(fieldName, " should provide \"deprecationReason\" ") + 'instead of "isDeprecated".') : void 0;
 
     var field = _objectSpread({}, fieldConfig, {
       isDeprecated: Boolean(fieldConfig.deprecationReason),
       name: fieldName
     });
 
-    !isValidResolver(field.resolve) ? (0, _invariant.default)(0, "".concat(type.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat((0, _inspect.default)(field.resolve), ".")) : void 0;
+    !(field.resolve == null || typeof field.resolve === 'function') ? (0, _invariant.default)(0, "".concat(config.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat((0, _inspect.default)(field.resolve), ".")) : void 0;
     var argsConfig = fieldConfig.args;
 
     if (!argsConfig) {
       field.args = [];
     } else {
-      !isPlainObj(argsConfig) ? (0, _invariant.default)(0, "".concat(type.name, ".").concat(fieldName, " args must be an object with argument ") + 'names as keys.') : void 0;
+      !isPlainObj(argsConfig) ? (0, _invariant.default)(0, "".concat(config.name, ".").concat(fieldName, " args must be an object with argument ") + 'names as keys.') : void 0;
       field.args = Object.keys(argsConfig).map(function (argName) {
         var arg = argsConfig[argName];
         return {
@@ -590,17 +583,17 @@ function defineFieldMap(type, fieldsThunk) {
     }
 
     resultFieldMap[fieldName] = field;
-  });
+  };
+
+  for (var _i = 0; _i < _arr.length; _i++) {
+    _loop();
+  }
+
   return resultFieldMap;
 }
 
 function isPlainObj(obj) {
   return obj && _typeof(obj) === 'object' && !Array.isArray(obj);
-} // If a resolver is defined, it must be a function.
-
-
-function isValidResolver(resolver) {
-  return resolver == null || typeof resolver === 'function';
 }
 
 /**
@@ -635,31 +628,26 @@ function () {
 
     _defineProperty(this, "resolveType", void 0);
 
-    _defineProperty(this, "_typeConfig", void 0);
-
     _defineProperty(this, "_fields", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
-
-    _defineProperty(this, "inspect", void 0);
-
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
     this.extensionASTNodes = config.extensionASTNodes;
     this.resolveType = config.resolveType;
-    this._typeConfig = config;
+    this._fields = defineFieldMap.bind(undefined, config);
     !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;
-
-    if (config.resolveType) {
-      !(typeof config.resolveType === 'function') ? (0, _invariant.default)(0, "".concat(this.name, " must provide \"resolveType\" as a function.")) : void 0;
-    }
+    !(config.resolveType == null || typeof config.resolveType === 'function') ? (0, _invariant.default)(0, "".concat(this.name, " must provide \"resolveType\" as a function, ") + "but got: ".concat((0, _inspect.default)(config.resolveType), ".")) : void 0;
   }
 
   var _proto3 = GraphQLInterfaceType.prototype;
 
   _proto3.getFields = function getFields() {
-    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));
+    if (typeof this._fields === 'function') {
+      this._fields = this._fields();
+    }
+
+    return this._fields;
   };
 
   _proto3.toString = function toString() {
@@ -671,9 +659,8 @@ function () {
 
 
 exports.GraphQLInterfaceType = GraphQLInterfaceType;
-(0, _applyToStringTag.default)(GraphQLInterfaceType); // Also provide toJSON and inspect aliases for toString.
-
-GraphQLInterfaceType.prototype.toJSON = GraphQLInterfaceType.prototype.inspect = GraphQLInterfaceType.prototype.toString;
+(0, _defineToStringTag.default)(GraphQLInterfaceType);
+(0, _defineToJSON.default)(GraphQLInterfaceType);
 
 /**
  * Union Type Definition
@@ -712,30 +699,26 @@ function () {
 
     _defineProperty(this, "resolveType", void 0);
 
-    _defineProperty(this, "_typeConfig", void 0);
-
     _defineProperty(this, "_types", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
-
-    _defineProperty(this, "inspect", void 0);
-
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
+    this.extensionASTNodes = config.extensionASTNodes;
     this.resolveType = config.resolveType;
-    this._typeConfig = config;
+    this._types = defineTypes.bind(undefined, config);
     !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;
-
-    if (config.resolveType) {
-      !(typeof config.resolveType === 'function') ? (0, _invariant.default)(0, "".concat(this.name, " must provide \"resolveType\" as a function.")) : void 0;
-    }
+    !(config.resolveType == null || typeof config.resolveType === 'function') ? (0, _invariant.default)(0, "".concat(this.name, " must provide \"resolveType\" as a function, ") + "but got: ".concat((0, _inspect.default)(config.resolveType), ".")) : void 0;
   }
 
   var _proto4 = GraphQLUnionType.prototype;
 
   _proto4.getTypes = function getTypes() {
-    return this._types || (this._types = defineTypes(this, this._typeConfig.types));
+    if (typeof this._types === 'function') {
+      this._types = this._types();
+    }
+
+    return this._types;
   };
 
   _proto4.toString = function toString() {
@@ -747,13 +730,12 @@ function () {
 
 
 exports.GraphQLUnionType = GraphQLUnionType;
-(0, _applyToStringTag.default)(GraphQLUnionType); // Also provide toJSON and inspect aliases for toString.
+(0, _defineToStringTag.default)(GraphQLUnionType);
+(0, _defineToJSON.default)(GraphQLUnionType);
 
-GraphQLUnionType.prototype.toJSON = GraphQLUnionType.prototype.inspect = GraphQLUnionType.prototype.toString;
-
-function defineTypes(unionType, typesThunk) {
-  var types = resolveThunk(typesThunk) || [];
-  !Array.isArray(types) ? (0, _invariant.default)(0, 'Must provide Array of types or a function which returns ' + "such an array for Union ".concat(unionType.name, ".")) : void 0;
+function defineTypes(config) {
+  var types = resolveThunk(config.types) || [];
+  !Array.isArray(types) ? (0, _invariant.default)(0, 'Must provide Array of types or a function which returns ' + "such an array for Union ".concat(config.name, ".")) : void 0;
   return types;
 }
 
@@ -800,13 +782,10 @@ function () {
 
     _defineProperty(this, "_nameLookup", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
-
-    _defineProperty(this, "inspect", void 0);
-
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
+    this.extensionASTNodes = config.extensionASTNodes;
     this._values = defineEnumValues(this, config.values);
     this._valueLookup = new Map(this._values.map(function (enumValue) {
       return [enumValue.value, enumValue];
@@ -871,9 +850,8 @@ function () {
 
 
 exports.GraphQLEnumType = GraphQLEnumType;
-(0, _applyToStringTag.default)(GraphQLEnumType); // Also provide toJSON and inspect aliases for toString.
-
-GraphQLEnumType.prototype.toJSON = GraphQLEnumType.prototype.inspect = GraphQLEnumType.prototype.toString;
+(0, _defineToStringTag.default)(GraphQLEnumType);
+(0, _defineToJSON.default)(GraphQLEnumType);
 
 function defineEnumValues(type, valueMap
 /* <T> */
@@ -926,42 +904,24 @@ function () {
 
     _defineProperty(this, "extensionASTNodes", void 0);
 
-    _defineProperty(this, "_typeConfig", void 0);
-
     _defineProperty(this, "_fields", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
-
-    _defineProperty(this, "inspect", void 0);
-
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
-    this._typeConfig = config;
+    this.extensionASTNodes = config.extensionASTNodes;
+    this._fields = defineInputFieldMap.bind(undefined, config);
     !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;
   }
 
   var _proto6 = GraphQLInputObjectType.prototype;
 
   _proto6.getFields = function getFields() {
-    return this._fields || (this._fields = this._defineFieldMap());
-  };
-
-  _proto6._defineFieldMap = function _defineFieldMap() {
-    var _this = this;
-
-    var fieldMap = resolveThunk(this._typeConfig.fields) || {};
-    !isPlainObj(fieldMap) ? (0, _invariant.default)(0, "".concat(this.name, " fields must be an object with field names as keys or a ") + 'function which returns such an object.') : void 0;
-    var resultFieldMap = Object.create(null);
-    Object.keys(fieldMap).forEach(function (fieldName) {
-      var field = _objectSpread({}, fieldMap[fieldName], {
-        name: fieldName
-      });
+    if (typeof this._fields === 'function') {
+      this._fields = this._fields();
+    }
 
-      !!field.hasOwnProperty('resolve') ? (0, _invariant.default)(0, "".concat(_this.name, ".").concat(fieldName, " field type has a resolve property, but ") + 'Input Types cannot define resolvers.') : void 0;
-      resultFieldMap[fieldName] = field;
-    });
-    return resultFieldMap;
+    return this._fields;
   };
 
   _proto6.toString = function toString() {
@@ -973,7 +933,26 @@ function () {
 
 
 exports.GraphQLInputObjectType = GraphQLInputObjectType;
-(0, _applyToStringTag.default)(GraphQLInputObjectType); // Also provide toJSON and inspect aliases for toString.
+(0, _defineToStringTag.default)(GraphQLInputObjectType);
+(0, _defineToJSON.default)(GraphQLInputObjectType);
 
-GraphQLInputObjectType.prototype.toJSON = GraphQLInputObjectType.prototype.toString;
-GraphQLInputObjectType.prototype.inspect = GraphQLInputObjectType.prototype.toString;
\ No newline at end of file
+function defineInputFieldMap(config) {
+  var fieldMap = resolveThunk(config.fields) || {};
+  !isPlainObj(fieldMap) ? (0, _invariant.default)(0, "".concat(config.name, " fields must be an object with field names as keys or a ") + 'function which returns such an object.') : void 0;
+  var resultFieldMap = Object.create(null);
+
+  var _arr2 = Object.keys(fieldMap);
+
+  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
+    var fieldName = _arr2[_i2];
+
+    var field = _objectSpread({}, fieldMap[fieldName], {
+      name: fieldName
+    });
+
+    !!field.hasOwnProperty('resolve') ? (0, _invariant.default)(0, "".concat(config.name, ".").concat(fieldName, " field type has a resolve property, but ") + 'Input Types cannot define resolvers.') : void 0;
+    resultFieldMap[fieldName] = field;
+  }
+
+  return resultFieldMap;
+}
\ No newline at end of file
diff --git a/type/definition.js.flow b/type/definition.js.flow
index 827266c..793daf1 100644
--- a/type/definition.js.flow
+++ b/type/definition.js.flow
@@ -7,7 +7,8 @@
  * @flow strict
  */
 
-import applyToStringTag from '../jsutils/applyToStringTag';
+import defineToJSON from '../jsutils/defineToJSON';
+import defineToStringTag from '../jsutils/defineToStringTag';
 import instanceOf from '../jsutils/instanceOf';
 import inspect from '../jsutils/inspect';
 import invariant from '../jsutils/invariant';
@@ -25,8 +26,12 @@ import type {
   EnumTypeDefinitionNode,
   EnumValueDefinitionNode,
   InputObjectTypeDefinitionNode,
+  ScalarTypeExtensionNode,
   ObjectTypeExtensionNode,
   InterfaceTypeExtensionNode,
+  UnionTypeExtensionNode,
+  EnumTypeExtensionNode,
+  InputObjectTypeExtensionNode,
   OperationDefinitionNode,
   FieldNode,
   FragmentDefinitionNode,
@@ -65,7 +70,7 @@ export function isType(type: mixed): boolean %checks {
 
 export function assertType(type: mixed): GraphQLType {
   invariant(isType(type), `Expected ${inspect(type)} to be a GraphQL type.`);
-  return (type: any);
+  return type;
 }
 
 /**
@@ -338,7 +343,7 @@ declare class GraphQLList<+T: GraphQLType> {
   +ofType: T;
   static <T>(ofType: T): GraphQLList<T>;
   // Note: constructors cannot be used for covariant types. Drop the "new".
-  constructor(ofType: any): void;
+  constructor(ofType: GraphQLType): void;
 }
 // eslint-disable-next-line no-redeclare
 export function GraphQLList(ofType) {
@@ -349,11 +354,11 @@ export function GraphQLList(ofType) {
   }
 }
 
-// Also provide toJSON and inspect aliases for toString.
-const listProto: any = GraphQLList.prototype;
-listProto.toString = listProto.toJSON = listProto.inspect = function toString() {
+// Need to cast through any to alter the prototype.
+(GraphQLList.prototype: any).toString = function toString() {
   return '[' + String(this.ofType) + ']';
 };
+defineToJSON(GraphQLList);
 
 /**
  * Non-Null Type Wrapper
@@ -379,7 +384,7 @@ declare class GraphQLNonNull<+T: GraphQLNullableType> {
   +ofType: T;
   static <T>(ofType: T): GraphQLNonNull<T>;
   // Note: constructors cannot be used for covariant types. Drop the "new".
-  constructor(ofType: any): void;
+  constructor(ofType: GraphQLType): void;
 }
 // eslint-disable-next-line no-redeclare
 export function GraphQLNonNull(ofType) {
@@ -390,11 +395,11 @@ export function GraphQLNonNull(ofType) {
   }
 }
 
-// Also provide toJSON and inspect aliases for toString.
-const nonNullProto: any = GraphQLNonNull.prototype;
-nonNullProto.toString = nonNullProto.toJSON = nonNullProto.inspect = function toString() {
+// Need to cast through any to alter the prototype.
+(GraphQLNonNull.prototype: any).toString = function toString() {
   return String(this.ofType) + '!';
 };
+defineToJSON(GraphQLNonNull);
 
 /**
  * These types wrap and modify other types
@@ -530,15 +535,20 @@ function resolveThunk<+T>(thunk: Thunk<T>): T {
 export class GraphQLScalarType {
   name: string;
   description: ?string;
+  serialize: GraphQLScalarSerializer<*>;
+  parseValue: GraphQLScalarValueParser<*>;
+  parseLiteral: GraphQLScalarLiteralParser<*>;
   astNode: ?ScalarTypeDefinitionNode;
-
-  _scalarConfig: GraphQLScalarTypeConfig<*, *>;
+  extensionASTNodes: ?$ReadOnlyArray<ScalarTypeExtensionNode>;
 
   constructor(config: GraphQLScalarTypeConfig<*, *>): void {
     this.name = config.name;
     this.description = config.description;
+    this.serialize = config.serialize;
+    this.parseValue = config.parseValue || (value => value);
+    this.parseLiteral = config.parseLiteral || valueFromASTUntyped;
     this.astNode = config.astNode;
-    this._scalarConfig = config;
+    this.extensionASTNodes = config.extensionASTNodes;
     invariant(typeof config.name === 'string', 'Must provide name.');
     invariant(
       typeof config.serialize === 'function',
@@ -556,52 +566,34 @@ export class GraphQLScalarType {
     }
   }
 
-  // Serializes an internal value to include in a response.
-  serialize(value: mixed): mixed {
-    const serializer = this._scalarConfig.serialize;
-    return serializer(value);
-  }
-
-  // Parses an externally provided value to use as an input.
-  parseValue(value: mixed): mixed {
-    const parser = this._scalarConfig.parseValue;
-    return parser ? parser(value) : value;
-  }
-
-  // Parses an externally provided literal value to use as an input.
-  parseLiteral(valueNode: ValueNode, variables: ?ObjMap<mixed>): mixed {
-    const parser = this._scalarConfig.parseLiteral;
-    return parser
-      ? parser(valueNode, variables)
-      : valueFromASTUntyped(valueNode, variables);
-  }
-
   toString(): string {
     return this.name;
   }
-
-  toJSON: () => string;
-  inspect: () => string;
 }
 
 // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
-applyToStringTag(GraphQLScalarType);
+defineToStringTag(GraphQLScalarType);
+defineToJSON(GraphQLScalarType);
 
-// Also provide toJSON and inspect aliases for toString.
-GraphQLScalarType.prototype.toJSON = GraphQLScalarType.prototype.inspect =
-  GraphQLScalarType.prototype.toString;
+export type GraphQLScalarSerializer<TExternal> = (value: mixed) => ?TExternal;
+export type GraphQLScalarValueParser<TInternal> = (value: mixed) => ?TInternal;
+export type GraphQLScalarLiteralParser<TInternal> = (
+  valueNode: ValueNode,
+  variables: ?ObjMap<mixed>,
+) => ?TInternal;
 
-export type GraphQLScalarTypeConfig<TInternal, TExternal> = {
+export type GraphQLScalarTypeConfig<TInternal, TExternal> = {|
   name: string,
   description?: ?string,
+  // Serializes an internal value to include in a response.
+  serialize: GraphQLScalarSerializer<TExternal>,
+  // Parses an externally provided value to use as an input.
+  parseValue?: GraphQLScalarValueParser<TInternal>,
+  // Parses an externally provided literal value to use as an input.
+  parseLiteral?: GraphQLScalarLiteralParser<TInternal>,
   astNode?: ?ScalarTypeDefinitionNode,
-  serialize: (value: mixed) => ?TExternal,
-  parseValue?: (value: mixed) => ?TInternal,
-  parseLiteral?: (
-    valueNode: ValueNode,
-    variables: ?ObjMap<mixed>,
-  ) => ?TInternal,
-};
+  extensionASTNodes?: ?$ReadOnlyArray<ScalarTypeExtensionNode>,
+|};
 
 /**
  * Object Type Definition
@@ -647,9 +639,8 @@ export class GraphQLObjectType {
   extensionASTNodes: ?$ReadOnlyArray<ObjectTypeExtensionNode>;
   isTypeOf: ?GraphQLIsTypeOfFn<*, *>;
 
-  _typeConfig: GraphQLObjectTypeConfig<*, *>;
-  _fields: GraphQLFieldMap<*, *>;
-  _interfaces: Array<GraphQLInterfaceType>;
+  _fields: Thunk<GraphQLFieldMap<*, *>>;
+  _interfaces: Thunk<Array<GraphQLInterfaceType>>;
 
   constructor(config: GraphQLObjectTypeConfig<*, *>): void {
     this.name = config.name;
@@ -657,80 +648,74 @@ export class GraphQLObjectType {
     this.astNode = config.astNode;
     this.extensionASTNodes = config.extensionASTNodes;
     this.isTypeOf = config.isTypeOf;
-    this._typeConfig = config;
+    this._fields = defineFieldMap.bind(undefined, config);
+    this._interfaces = defineInterfaces.bind(undefined, config);
     invariant(typeof config.name === 'string', 'Must provide name.');
-    if (config.isTypeOf) {
-      invariant(
-        typeof config.isTypeOf === 'function',
-        `${this.name} must provide "isTypeOf" as a function.`,
-      );
-    }
+    invariant(
+      config.isTypeOf == null || typeof config.isTypeOf === 'function',
+      `${this.name} must provide "isTypeOf" as a function, ` +
+        `but got: ${inspect(config.isTypeOf)}.`,
+    );
   }
 
   getFields(): GraphQLFieldMap<*, *> {
-    return (
-      this._fields ||
-      (this._fields = defineFieldMap(this, this._typeConfig.fields))
-    );
+    if (typeof this._fields === 'function') {
+      this._fields = this._fields();
+    }
+    return this._fields;
   }
 
   getInterfaces(): Array<GraphQLInterfaceType> {
-    return (
-      this._interfaces ||
-      (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces))
-    );
+    if (typeof this._interfaces === 'function') {
+      this._interfaces = this._interfaces();
+    }
+    return this._interfaces;
   }
 
   toString(): string {
     return this.name;
   }
-
-  toJSON: () => string;
-  inspect: () => string;
 }
 
 // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
-applyToStringTag(GraphQLObjectType);
-
-// Also provide toJSON and inspect aliases for toString.
-GraphQLObjectType.prototype.toJSON = GraphQLObjectType.prototype.inspect =
-  GraphQLObjectType.prototype.toString;
+defineToStringTag(GraphQLObjectType);
+defineToJSON(GraphQLObjectType);
 
 function defineInterfaces(
-  type: GraphQLObjectType,
-  interfacesThunk: Thunk<?Array<GraphQLInterfaceType>>,
+  config: GraphQLObjectTypeConfig<*, *>,
 ): Array<GraphQLInterfaceType> {
-  const interfaces = resolveThunk(interfacesThunk) || [];
+  const interfaces = resolveThunk(config.interfaces) || [];
   invariant(
     Array.isArray(interfaces),
-    `${type.name} interfaces must be an Array or a function which returns ` +
+    `${config.name} interfaces must be an Array or a function which returns ` +
       'an Array.',
   );
   return interfaces;
 }
 
 function defineFieldMap<TSource, TContext>(
-  type: GraphQLNamedType,
-  fieldsThunk: Thunk<GraphQLFieldConfigMap<TSource, TContext>>,
+  config:
+    | GraphQLObjectTypeConfig<TSource, TContext>
+    | GraphQLInterfaceTypeConfig<TSource, TContext>,
 ): GraphQLFieldMap<TSource, TContext> {
-  const fieldMap = resolveThunk(fieldsThunk) || {};
+  const fieldMap = resolveThunk(config.fields) || {};
   invariant(
     isPlainObj(fieldMap),
-    `${type.name} fields must be an object with field names as keys or a ` +
+    `${config.name} fields must be an object with field names as keys or a ` +
       'function which returns such an object.',
   );
 
   const resultFieldMap = Object.create(null);
-  Object.keys(fieldMap).forEach(fieldName => {
+  for (const fieldName of Object.keys(fieldMap)) {
     const fieldConfig = fieldMap[fieldName];
     invariant(
       isPlainObj(fieldConfig),
-      `${type.name}.${fieldName} field config must be an object`,
+      `${config.name}.${fieldName} field config must be an object`,
     );
     invariant(
       !fieldConfig.hasOwnProperty('isDeprecated'),
-      `${type.name}.${fieldName} should provide "deprecationReason" instead ` +
-        'of "isDeprecated".',
+      `${config.name}.${fieldName} should provide "deprecationReason" ` +
+        'instead of "isDeprecated".',
     );
     const field = {
       ...fieldConfig,
@@ -738,8 +723,8 @@ function defineFieldMap<TSource, TContext>(
       name: fieldName,
     };
     invariant(
-      isValidResolver(field.resolve),
-      `${type.name}.${fieldName} field resolver must be a function if ` +
+      field.resolve == null || typeof field.resolve === 'function',
+      `${config.name}.${fieldName} field resolver must be a function if ` +
         `provided, but got: ${inspect(field.resolve)}.`,
     );
     const argsConfig = fieldConfig.args;
@@ -748,7 +733,7 @@ function defineFieldMap<TSource, TContext>(
     } else {
       invariant(
         isPlainObj(argsConfig),
-        `${type.name}.${fieldName} args must be an object with argument ` +
+        `${config.name}.${fieldName} args must be an object with argument ` +
           'names as keys.',
       );
       field.args = Object.keys(argsConfig).map(argName => {
@@ -763,7 +748,7 @@ function defineFieldMap<TSource, TContext>(
       });
     }
     resultFieldMap[fieldName] = field;
-  });
+  }
   return resultFieldMap;
 }
 
@@ -771,12 +756,7 @@ function isPlainObj(obj) {
   return obj && typeof obj === 'object' && !Array.isArray(obj);
 }
 
-// If a resolver is defined, it must be a function.
-function isValidResolver(resolver: mixed): boolean {
-  return resolver == null || typeof resolver === 'function';
-}
-
-export type GraphQLObjectTypeConfig<TSource, TContext> = {
+export type GraphQLObjectTypeConfig<TSource, TContext> = {|
   name: string,
   interfaces?: Thunk<?Array<GraphQLInterfaceType>>,
   fields: Thunk<GraphQLFieldConfigMap<TSource, TContext>>,
@@ -784,7 +764,7 @@ export type GraphQLObjectTypeConfig<TSource, TContext> = {
   description?: ?string,
   astNode?: ?ObjectTypeDefinitionNode,
   extensionASTNodes?: ?$ReadOnlyArray<ObjectTypeExtensionNode>,
-};
+|};
 
 export type GraphQLTypeResolver<TSource, TContext> = (
   value: TSource,
@@ -831,24 +811,25 @@ export type GraphQLFieldConfig<
   TSource,
   TContext,
   TArgs = { [argument: string]: any },
-> = {
+> = {|
   type: GraphQLOutputType,
   args?: GraphQLFieldConfigArgumentMap,
   resolve?: GraphQLFieldResolver<TSource, TContext, TArgs>,
   subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs>,
   deprecationReason?: ?string,
+  iamName?: ?string,
   description?: ?string,
   astNode?: ?FieldDefinitionNode,
-};
+|};
 
 export type GraphQLFieldConfigArgumentMap = ObjMap<GraphQLArgumentConfig>;
 
-export type GraphQLArgumentConfig = {
+export type GraphQLArgumentConfig = {|
   type: GraphQLInputType,
   defaultValue?: mixed,
   description?: ?string,
   astNode?: ?InputValueDefinitionNode,
-};
+|};
 
 export type GraphQLFieldConfigMap<TSource, TContext> = ObjMap<
   GraphQLFieldConfig<TSource, TContext>,
@@ -867,6 +848,7 @@ export type GraphQLField<
   subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs>,
   isDeprecated?: boolean,
   deprecationReason?: ?string,
+  iamName?: ?string,
   astNode?: ?FieldDefinitionNode,
 };
 
@@ -907,8 +889,7 @@ export class GraphQLInterfaceType {
   extensionASTNodes: ?$ReadOnlyArray<InterfaceTypeExtensionNode>;
   resolveType: ?GraphQLTypeResolver<*, *>;
 
-  _typeConfig: GraphQLInterfaceTypeConfig<*, *>;
-  _fields: GraphQLFieldMap<*, *>;
+  _fields: Thunk<GraphQLFieldMap<*, *>>;
 
   constructor(config: GraphQLInterfaceTypeConfig<*, *>): void {
     this.name = config.name;
@@ -916,39 +897,32 @@ export class GraphQLInterfaceType {
     this.astNode = config.astNode;
     this.extensionASTNodes = config.extensionASTNodes;
     this.resolveType = config.resolveType;
-    this._typeConfig = config;
+    this._fields = defineFieldMap.bind(undefined, config);
     invariant(typeof config.name === 'string', 'Must provide name.');
-    if (config.resolveType) {
-      invariant(
-        typeof config.resolveType === 'function',
-        `${this.name} must provide "resolveType" as a function.`,
-      );
-    }
+    invariant(
+      config.resolveType == null || typeof config.resolveType === 'function',
+      `${this.name} must provide "resolveType" as a function, ` +
+        `but got: ${inspect(config.resolveType)}.`,
+    );
   }
 
   getFields(): GraphQLFieldMap<*, *> {
-    return (
-      this._fields ||
-      (this._fields = defineFieldMap(this, this._typeConfig.fields))
-    );
+    if (typeof this._fields === 'function') {
+      this._fields = this._fields();
+    }
+    return this._fields;
   }
 
   toString(): string {
     return this.name;
   }
-
-  toJSON: () => string;
-  inspect: () => string;
 }
 
 // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
-applyToStringTag(GraphQLInterfaceType);
-
-// Also provide toJSON and inspect aliases for toString.
-GraphQLInterfaceType.prototype.toJSON = GraphQLInterfaceType.prototype.inspect =
-  GraphQLInterfaceType.prototype.toString;
+defineToStringTag(GraphQLInterfaceType);
+defineToJSON(GraphQLInterfaceType);
 
-export type GraphQLInterfaceTypeConfig<TSource, TContext> = {
+export type GraphQLInterfaceTypeConfig<TSource, TContext> = {|
   name: string,
   fields: Thunk<GraphQLFieldConfigMap<TSource, TContext>>,
   /**
@@ -960,7 +934,7 @@ export type GraphQLInterfaceTypeConfig<TSource, TContext> = {
   description?: ?string,
   astNode?: ?InterfaceTypeDefinitionNode,
   extensionASTNodes?: ?$ReadOnlyArray<InterfaceTypeExtensionNode>,
-};
+|};
 
 /**
  * Union Type Definition
@@ -989,62 +963,55 @@ export class GraphQLUnionType {
   name: string;
   description: ?string;
   astNode: ?UnionTypeDefinitionNode;
-  extensionASTNodes: ?$ReadOnlyArray<ObjectTypeExtensionNode>;
+  extensionASTNodes: ?$ReadOnlyArray<UnionTypeExtensionNode>;
   resolveType: ?GraphQLTypeResolver<*, *>;
 
-  _typeConfig: GraphQLUnionTypeConfig<*, *>;
-  _types: Array<GraphQLObjectType>;
+  _types: Thunk<Array<GraphQLObjectType>>;
 
   constructor(config: GraphQLUnionTypeConfig<*, *>): void {
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
+    this.extensionASTNodes = config.extensionASTNodes;
     this.resolveType = config.resolveType;
-    this._typeConfig = config;
+    this._types = defineTypes.bind(undefined, config);
     invariant(typeof config.name === 'string', 'Must provide name.');
-    if (config.resolveType) {
-      invariant(
-        typeof config.resolveType === 'function',
-        `${this.name} must provide "resolveType" as a function.`,
-      );
-    }
+    invariant(
+      config.resolveType == null || typeof config.resolveType === 'function',
+      `${this.name} must provide "resolveType" as a function, ` +
+        `but got: ${inspect(config.resolveType)}.`,
+    );
   }
 
   getTypes(): Array<GraphQLObjectType> {
-    return (
-      this._types || (this._types = defineTypes(this, this._typeConfig.types))
-    );
+    if (typeof this._types === 'function') {
+      this._types = this._types();
+    }
+    return this._types;
   }
 
   toString(): string {
     return this.name;
   }
-
-  toJSON: () => string;
-  inspect: () => string;
 }
 
 // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
-applyToStringTag(GraphQLUnionType);
-
-// Also provide toJSON and inspect aliases for toString.
-GraphQLUnionType.prototype.toJSON = GraphQLUnionType.prototype.inspect =
-  GraphQLUnionType.prototype.toString;
+defineToStringTag(GraphQLUnionType);
+defineToJSON(GraphQLUnionType);
 
 function defineTypes(
-  unionType: GraphQLUnionType,
-  typesThunk: Thunk<Array<GraphQLObjectType>>,
+  config: GraphQLUnionTypeConfig<*, *>,
 ): Array<GraphQLObjectType> {
-  const types = resolveThunk(typesThunk) || [];
+  const types = resolveThunk(config.types) || [];
   invariant(
     Array.isArray(types),
     'Must provide Array of types or a function which returns ' +
-      `such an array for Union ${unionType.name}.`,
+      `such an array for Union ${config.name}.`,
   );
   return types;
 }
 
-export type GraphQLUnionTypeConfig<TSource, TContext> = {
+export type GraphQLUnionTypeConfig<TSource, TContext> = {|
   name: string,
   types: Thunk<Array<GraphQLObjectType>>,
   /**
@@ -1055,7 +1022,8 @@ export type GraphQLUnionTypeConfig<TSource, TContext> = {
   resolveType?: ?GraphQLTypeResolver<TSource, TContext>,
   description?: ?string,
   astNode?: ?UnionTypeDefinitionNode,
-};
+  extensionASTNodes?: ?$ReadOnlyArray<UnionTypeExtensionNode>,
+|};
 
 /**
  * Enum Type Definition
@@ -1082,7 +1050,7 @@ export class GraphQLEnumType /* <T> */ {
   name: string;
   description: ?string;
   astNode: ?EnumTypeDefinitionNode;
-  extensionASTNodes: ?$ReadOnlyArray<ObjectTypeExtensionNode>;
+  extensionASTNodes: ?$ReadOnlyArray<EnumTypeExtensionNode>;
 
   _values: Array<GraphQLEnumValue /* <T> */>;
   _valueLookup: Map<any /* T */, GraphQLEnumValue>;
@@ -1092,6 +1060,7 @@ export class GraphQLEnumType /* <T> */ {
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
+    this.extensionASTNodes = config.extensionASTNodes;
     this._values = defineEnumValues(this, config.values);
     this._valueLookup = new Map(
       this._values.map(enumValue => [enumValue.value, enumValue]),
@@ -1109,7 +1078,7 @@ export class GraphQLEnumType /* <T> */ {
     return this._nameLookup[name];
   }
 
-  serialize(value: any /* T */): ?string {
+  serialize(value: mixed /* T */): ?string {
     const enumValue = this._valueLookup.get(value);
     if (enumValue) {
       return enumValue.name;
@@ -1138,17 +1107,11 @@ export class GraphQLEnumType /* <T> */ {
   toString(): string {
     return this.name;
   }
-
-  toJSON: () => string;
-  inspect: () => string;
 }
 
 // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
-applyToStringTag(GraphQLEnumType);
-
-// Also provide toJSON and inspect aliases for toString.
-GraphQLEnumType.prototype.toJSON = GraphQLEnumType.prototype.inspect =
-  GraphQLEnumType.prototype.toString;
+defineToStringTag(GraphQLEnumType);
+defineToJSON(GraphQLEnumType);
 
 function defineEnumValues(
   type: GraphQLEnumType,
@@ -1181,23 +1144,24 @@ function defineEnumValues(
   });
 }
 
-export type GraphQLEnumTypeConfig /* <T> */ = {
+export type GraphQLEnumTypeConfig /* <T> */ = {|
   name: string,
   values: GraphQLEnumValueConfigMap /* <T> */,
   description?: ?string,
   astNode?: ?EnumTypeDefinitionNode,
-};
+  extensionASTNodes?: ?$ReadOnlyArray<EnumTypeExtensionNode>,
+|};
 
 export type GraphQLEnumValueConfigMap /* <T> */ = ObjMap<
   GraphQLEnumValueConfig /* <T> */,
 >;
 
-export type GraphQLEnumValueConfig /* <T> */ = {
+export type GraphQLEnumValueConfig /* <T> */ = {|
   value?: any /* T */,
   deprecationReason?: ?string,
   description?: ?string,
   astNode?: ?EnumValueDefinitionNode,
-};
+|};
 
 export type GraphQLEnumValue /* <T> */ = {
   name: string,
@@ -1232,76 +1196,74 @@ export class GraphQLInputObjectType {
   name: string;
   description: ?string;
   astNode: ?InputObjectTypeDefinitionNode;
-  extensionASTNodes: ?$ReadOnlyArray<ObjectTypeExtensionNode>;
+  extensionASTNodes: ?$ReadOnlyArray<InputObjectTypeExtensionNode>;
 
-  _typeConfig: GraphQLInputObjectTypeConfig;
-  _fields: GraphQLInputFieldMap;
+  _fields: Thunk<GraphQLInputFieldMap>;
 
   constructor(config: GraphQLInputObjectTypeConfig): void {
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
-    this._typeConfig = config;
+    this.extensionASTNodes = config.extensionASTNodes;
+    this._fields = defineInputFieldMap.bind(undefined, config);
     invariant(typeof config.name === 'string', 'Must provide name.');
   }
 
   getFields(): GraphQLInputFieldMap {
-    return this._fields || (this._fields = this._defineFieldMap());
-  }
-
-  _defineFieldMap(): GraphQLInputFieldMap {
-    const fieldMap: any = resolveThunk(this._typeConfig.fields) || {};
-    invariant(
-      isPlainObj(fieldMap),
-      `${this.name} fields must be an object with field names as keys or a ` +
-        'function which returns such an object.',
-    );
-    const resultFieldMap = Object.create(null);
-    Object.keys(fieldMap).forEach(fieldName => {
-      const field = {
-        ...fieldMap[fieldName],
-        name: fieldName,
-      };
-      invariant(
-        !field.hasOwnProperty('resolve'),
-        `${this.name}.${fieldName} field type has a resolve property, but ` +
-          'Input Types cannot define resolvers.',
-      );
-      resultFieldMap[fieldName] = field;
-    });
-    return resultFieldMap;
+    if (typeof this._fields === 'function') {
+      this._fields = this._fields();
+    }
+    return this._fields;
   }
 
   toString(): string {
     return this.name;
   }
-
-  toJSON: () => string;
-  inspect: () => string;
 }
 
 // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
-applyToStringTag(GraphQLInputObjectType);
+defineToStringTag(GraphQLInputObjectType);
+defineToJSON(GraphQLInputObjectType);
 
-// Also provide toJSON and inspect aliases for toString.
-GraphQLInputObjectType.prototype.toJSON =
-  GraphQLInputObjectType.prototype.toString;
-GraphQLInputObjectType.prototype.inspect =
-  GraphQLInputObjectType.prototype.toString;
+function defineInputFieldMap(
+  config: GraphQLInputObjectTypeConfig,
+): GraphQLInputFieldMap {
+  const fieldMap = resolveThunk(config.fields) || {};
+  invariant(
+    isPlainObj(fieldMap),
+    `${config.name} fields must be an object with field names as keys or a ` +
+      'function which returns such an object.',
+  );
+  const resultFieldMap = Object.create(null);
+  for (const fieldName of Object.keys(fieldMap)) {
+    const field = {
+      ...fieldMap[fieldName],
+      name: fieldName,
+    };
+    invariant(
+      !field.hasOwnProperty('resolve'),
+      `${config.name}.${fieldName} field type has a resolve property, but ` +
+        'Input Types cannot define resolvers.',
+    );
+    resultFieldMap[fieldName] = field;
+  }
+  return resultFieldMap;
+}
 
-export type GraphQLInputObjectTypeConfig = {
+export type GraphQLInputObjectTypeConfig = {|
   name: string,
   fields: Thunk<GraphQLInputFieldConfigMap>,
   description?: ?string,
   astNode?: ?InputObjectTypeDefinitionNode,
-};
+  extensionASTNodes?: ?$ReadOnlyArray<InputObjectTypeExtensionNode>,
+|};
 
-export type GraphQLInputFieldConfig = {
+export type GraphQLInputFieldConfig = {|
   type: GraphQLInputType,
   defaultValue?: mixed,
   description?: ?string,
   astNode?: ?InputValueDefinitionNode,
-};
+|};
 
 export type GraphQLInputFieldConfigMap = ObjMap<GraphQLInputFieldConfig>;
 
diff --git a/type/definition.mjs b/type/definition.mjs
index 5354555..4fa1dfa 100644
--- a/type/definition.mjs
+++ b/type/definition.mjs
@@ -12,7 +12,8 @@ function _defineProperty(obj, key, value) { if (key in obj) { Object.definePrope
  *
  *  strict
  */
-import applyToStringTag from '../jsutils/applyToStringTag';
+import defineToJSON from '../jsutils/defineToJSON';
+import defineToStringTag from '../jsutils/defineToStringTag';
 import instanceOf from '../jsutils/instanceOf';
 import inspect from '../jsutils/inspect';
 import invariant from '../jsutils/invariant';
@@ -175,13 +176,13 @@ export function GraphQLList(ofType) {
   } else {
     return new GraphQLList(ofType);
   }
-} // Also provide toJSON and inspect aliases for toString.
+} // Need to cast through any to alter the prototype.
 
-var listProto = GraphQLList.prototype;
-
-listProto.toString = listProto.toJSON = listProto.inspect = function toString() {
+GraphQLList.prototype.toString = function toString() {
   return '[' + String(this.ofType) + ']';
 };
+
+defineToJSON(GraphQLList);
 /**
  * Non-Null Type Wrapper
  *
@@ -203,7 +204,6 @@ listProto.toString = listProto.toJSON = listProto.inspect = function toString()
  * Note: the enforcement of non-nullability occurs within the executor.
  */
 
-
 // eslint-disable-next-line no-redeclare
 export function GraphQLNonNull(ofType) {
   if (this instanceof GraphQLNonNull) {
@@ -211,18 +211,17 @@ export function GraphQLNonNull(ofType) {
   } else {
     return new GraphQLNonNull(ofType);
   }
-} // Also provide toJSON and inspect aliases for toString.
+} // Need to cast through any to alter the prototype.
 
-var nonNullProto = GraphQLNonNull.prototype;
-
-nonNullProto.toString = nonNullProto.toJSON = nonNullProto.inspect = function toString() {
+GraphQLNonNull.prototype.toString = function toString() {
   return String(this.ofType) + '!';
 };
+
+defineToJSON(GraphQLNonNull);
 /**
  * These types wrap and modify other types
  */
 
-
 export function isWrappingType(type) {
   return isListType(type) || isNonNullType(type);
 }
@@ -316,46 +315,37 @@ function () {
 
     _defineProperty(this, "description", void 0);
 
-    _defineProperty(this, "astNode", void 0);
+    _defineProperty(this, "serialize", void 0);
 
-    _defineProperty(this, "_scalarConfig", void 0);
+    _defineProperty(this, "parseValue", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
+    _defineProperty(this, "parseLiteral", void 0);
 
-    _defineProperty(this, "inspect", void 0);
+    _defineProperty(this, "astNode", void 0);
+
+    _defineProperty(this, "extensionASTNodes", void 0);
 
     this.name = config.name;
     this.description = config.description;
+    this.serialize = config.serialize;
+
+    this.parseValue = config.parseValue || function (value) {
+      return value;
+    };
+
+    this.parseLiteral = config.parseLiteral || valueFromASTUntyped;
     this.astNode = config.astNode;
-    this._scalarConfig = config;
+    this.extensionASTNodes = config.extensionASTNodes;
     !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;
     !(typeof config.serialize === 'function') ? invariant(0, "".concat(this.name, " must provide \"serialize\" function. If this custom Scalar ") + 'is also used as an input type, ensure "parseValue" and "parseLiteral" ' + 'functions are also provided.') : void 0;
 
     if (config.parseValue || config.parseLiteral) {
       !(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') ? invariant(0, "".concat(this.name, " must provide both \"parseValue\" and \"parseLiteral\" ") + 'functions.') : void 0;
     }
-  } // Serializes an internal value to include in a response.
-
+  }
 
   var _proto = GraphQLScalarType.prototype;
 
-  _proto.serialize = function serialize(value) {
-    var serializer = this._scalarConfig.serialize;
-    return serializer(value);
-  }; // Parses an externally provided value to use as an input.
-
-
-  _proto.parseValue = function parseValue(value) {
-    var parser = this._scalarConfig.parseValue;
-    return parser ? parser(value) : value;
-  }; // Parses an externally provided literal value to use as an input.
-
-
-  _proto.parseLiteral = function parseLiteral(valueNode, variables) {
-    var parser = this._scalarConfig.parseLiteral;
-    return parser ? parser(valueNode, variables) : valueFromASTUntyped(valueNode, variables);
-  };
-
   _proto.toString = function toString() {
     return this.name;
   };
@@ -363,9 +353,8 @@ function () {
   return GraphQLScalarType;
 }(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
 
-applyToStringTag(GraphQLScalarType); // Also provide toJSON and inspect aliases for toString.
-
-GraphQLScalarType.prototype.toJSON = GraphQLScalarType.prototype.inspect = GraphQLScalarType.prototype.toString;
+defineToStringTag(GraphQLScalarType);
+defineToJSON(GraphQLScalarType);
 
 /**
  * Object Type Definition
@@ -418,37 +407,37 @@ function () {
 
     _defineProperty(this, "isTypeOf", void 0);
 
-    _defineProperty(this, "_typeConfig", void 0);
-
     _defineProperty(this, "_fields", void 0);
 
     _defineProperty(this, "_interfaces", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
-
-    _defineProperty(this, "inspect", void 0);
-
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
     this.extensionASTNodes = config.extensionASTNodes;
     this.isTypeOf = config.isTypeOf;
-    this._typeConfig = config;
+    this._fields = defineFieldMap.bind(undefined, config);
+    this._interfaces = defineInterfaces.bind(undefined, config);
     !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;
-
-    if (config.isTypeOf) {
-      !(typeof config.isTypeOf === 'function') ? invariant(0, "".concat(this.name, " must provide \"isTypeOf\" as a function.")) : void 0;
-    }
+    !(config.isTypeOf == null || typeof config.isTypeOf === 'function') ? invariant(0, "".concat(this.name, " must provide \"isTypeOf\" as a function, ") + "but got: ".concat(inspect(config.isTypeOf), ".")) : void 0;
   }
 
   var _proto2 = GraphQLObjectType.prototype;
 
   _proto2.getFields = function getFields() {
-    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));
+    if (typeof this._fields === 'function') {
+      this._fields = this._fields();
+    }
+
+    return this._fields;
   };
 
   _proto2.getInterfaces = function getInterfaces() {
-    return this._interfaces || (this._interfaces = defineInterfaces(this, this._typeConfig.interfaces));
+    if (typeof this._interfaces === 'function') {
+      this._interfaces = this._interfaces();
+    }
+
+    return this._interfaces;
   };
 
   _proto2.toString = function toString() {
@@ -458,37 +447,40 @@ function () {
   return GraphQLObjectType;
 }(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
 
-applyToStringTag(GraphQLObjectType); // Also provide toJSON and inspect aliases for toString.
+defineToStringTag(GraphQLObjectType);
+defineToJSON(GraphQLObjectType);
 
-GraphQLObjectType.prototype.toJSON = GraphQLObjectType.prototype.inspect = GraphQLObjectType.prototype.toString;
-
-function defineInterfaces(type, interfacesThunk) {
-  var interfaces = resolveThunk(interfacesThunk) || [];
-  !Array.isArray(interfaces) ? invariant(0, "".concat(type.name, " interfaces must be an Array or a function which returns ") + 'an Array.') : void 0;
+function defineInterfaces(config) {
+  var interfaces = resolveThunk(config.interfaces) || [];
+  !Array.isArray(interfaces) ? invariant(0, "".concat(config.name, " interfaces must be an Array or a function which returns ") + 'an Array.') : void 0;
   return interfaces;
 }
 
-function defineFieldMap(type, fieldsThunk) {
-  var fieldMap = resolveThunk(fieldsThunk) || {};
-  !isPlainObj(fieldMap) ? invariant(0, "".concat(type.name, " fields must be an object with field names as keys or a ") + 'function which returns such an object.') : void 0;
+function defineFieldMap(config) {
+  var fieldMap = resolveThunk(config.fields) || {};
+  !isPlainObj(fieldMap) ? invariant(0, "".concat(config.name, " fields must be an object with field names as keys or a ") + 'function which returns such an object.') : void 0;
   var resultFieldMap = Object.create(null);
-  Object.keys(fieldMap).forEach(function (fieldName) {
+
+  var _arr = Object.keys(fieldMap);
+
+  var _loop = function _loop() {
+    var fieldName = _arr[_i];
     var fieldConfig = fieldMap[fieldName];
-    !isPlainObj(fieldConfig) ? invariant(0, "".concat(type.name, ".").concat(fieldName, " field config must be an object")) : void 0;
-    !!fieldConfig.hasOwnProperty('isDeprecated') ? invariant(0, "".concat(type.name, ".").concat(fieldName, " should provide \"deprecationReason\" instead ") + 'of "isDeprecated".') : void 0;
+    !isPlainObj(fieldConfig) ? invariant(0, "".concat(config.name, ".").concat(fieldName, " field config must be an object")) : void 0;
+    !!fieldConfig.hasOwnProperty('isDeprecated') ? invariant(0, "".concat(config.name, ".").concat(fieldName, " should provide \"deprecationReason\" ") + 'instead of "isDeprecated".') : void 0;
 
     var field = _objectSpread({}, fieldConfig, {
       isDeprecated: Boolean(fieldConfig.deprecationReason),
       name: fieldName
     });
 
-    !isValidResolver(field.resolve) ? invariant(0, "".concat(type.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat(inspect(field.resolve), ".")) : void 0;
+    !(field.resolve == null || typeof field.resolve === 'function') ? invariant(0, "".concat(config.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat(inspect(field.resolve), ".")) : void 0;
     var argsConfig = fieldConfig.args;
 
     if (!argsConfig) {
       field.args = [];
     } else {
-      !isPlainObj(argsConfig) ? invariant(0, "".concat(type.name, ".").concat(fieldName, " args must be an object with argument ") + 'names as keys.') : void 0;
+      !isPlainObj(argsConfig) ? invariant(0, "".concat(config.name, ".").concat(fieldName, " args must be an object with argument ") + 'names as keys.') : void 0;
       field.args = Object.keys(argsConfig).map(function (argName) {
         var arg = argsConfig[argName];
         return {
@@ -502,17 +494,17 @@ function defineFieldMap(type, fieldsThunk) {
     }
 
     resultFieldMap[fieldName] = field;
-  });
+  };
+
+  for (var _i = 0; _i < _arr.length; _i++) {
+    _loop();
+  }
+
   return resultFieldMap;
 }
 
 function isPlainObj(obj) {
   return obj && _typeof(obj) === 'object' && !Array.isArray(obj);
-} // If a resolver is defined, it must be a function.
-
-
-function isValidResolver(resolver) {
-  return resolver == null || typeof resolver === 'function';
 }
 
 /**
@@ -547,31 +539,26 @@ function () {
 
     _defineProperty(this, "resolveType", void 0);
 
-    _defineProperty(this, "_typeConfig", void 0);
-
     _defineProperty(this, "_fields", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
-
-    _defineProperty(this, "inspect", void 0);
-
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
     this.extensionASTNodes = config.extensionASTNodes;
     this.resolveType = config.resolveType;
-    this._typeConfig = config;
+    this._fields = defineFieldMap.bind(undefined, config);
     !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;
-
-    if (config.resolveType) {
-      !(typeof config.resolveType === 'function') ? invariant(0, "".concat(this.name, " must provide \"resolveType\" as a function.")) : void 0;
-    }
+    !(config.resolveType == null || typeof config.resolveType === 'function') ? invariant(0, "".concat(this.name, " must provide \"resolveType\" as a function, ") + "but got: ".concat(inspect(config.resolveType), ".")) : void 0;
   }
 
   var _proto3 = GraphQLInterfaceType.prototype;
 
   _proto3.getFields = function getFields() {
-    return this._fields || (this._fields = defineFieldMap(this, this._typeConfig.fields));
+    if (typeof this._fields === 'function') {
+      this._fields = this._fields();
+    }
+
+    return this._fields;
   };
 
   _proto3.toString = function toString() {
@@ -581,9 +568,8 @@ function () {
   return GraphQLInterfaceType;
 }(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
 
-applyToStringTag(GraphQLInterfaceType); // Also provide toJSON and inspect aliases for toString.
-
-GraphQLInterfaceType.prototype.toJSON = GraphQLInterfaceType.prototype.inspect = GraphQLInterfaceType.prototype.toString;
+defineToStringTag(GraphQLInterfaceType);
+defineToJSON(GraphQLInterfaceType);
 
 /**
  * Union Type Definition
@@ -622,30 +608,26 @@ function () {
 
     _defineProperty(this, "resolveType", void 0);
 
-    _defineProperty(this, "_typeConfig", void 0);
-
     _defineProperty(this, "_types", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
-
-    _defineProperty(this, "inspect", void 0);
-
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
+    this.extensionASTNodes = config.extensionASTNodes;
     this.resolveType = config.resolveType;
-    this._typeConfig = config;
+    this._types = defineTypes.bind(undefined, config);
     !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;
-
-    if (config.resolveType) {
-      !(typeof config.resolveType === 'function') ? invariant(0, "".concat(this.name, " must provide \"resolveType\" as a function.")) : void 0;
-    }
+    !(config.resolveType == null || typeof config.resolveType === 'function') ? invariant(0, "".concat(this.name, " must provide \"resolveType\" as a function, ") + "but got: ".concat(inspect(config.resolveType), ".")) : void 0;
   }
 
   var _proto4 = GraphQLUnionType.prototype;
 
   _proto4.getTypes = function getTypes() {
-    return this._types || (this._types = defineTypes(this, this._typeConfig.types));
+    if (typeof this._types === 'function') {
+      this._types = this._types();
+    }
+
+    return this._types;
   };
 
   _proto4.toString = function toString() {
@@ -655,13 +637,12 @@ function () {
   return GraphQLUnionType;
 }(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
 
-applyToStringTag(GraphQLUnionType); // Also provide toJSON and inspect aliases for toString.
+defineToStringTag(GraphQLUnionType);
+defineToJSON(GraphQLUnionType);
 
-GraphQLUnionType.prototype.toJSON = GraphQLUnionType.prototype.inspect = GraphQLUnionType.prototype.toString;
-
-function defineTypes(unionType, typesThunk) {
-  var types = resolveThunk(typesThunk) || [];
-  !Array.isArray(types) ? invariant(0, 'Must provide Array of types or a function which returns ' + "such an array for Union ".concat(unionType.name, ".")) : void 0;
+function defineTypes(config) {
+  var types = resolveThunk(config.types) || [];
+  !Array.isArray(types) ? invariant(0, 'Must provide Array of types or a function which returns ' + "such an array for Union ".concat(config.name, ".")) : void 0;
   return types;
 }
 
@@ -708,13 +689,10 @@ function () {
 
     _defineProperty(this, "_nameLookup", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
-
-    _defineProperty(this, "inspect", void 0);
-
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
+    this.extensionASTNodes = config.extensionASTNodes;
     this._values = defineEnumValues(this, config.values);
     this._valueLookup = new Map(this._values.map(function (enumValue) {
       return [enumValue.value, enumValue];
@@ -777,9 +755,8 @@ function () {
   return GraphQLEnumType;
 }(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
 
-applyToStringTag(GraphQLEnumType); // Also provide toJSON and inspect aliases for toString.
-
-GraphQLEnumType.prototype.toJSON = GraphQLEnumType.prototype.inspect = GraphQLEnumType.prototype.toString;
+defineToStringTag(GraphQLEnumType);
+defineToJSON(GraphQLEnumType);
 
 function defineEnumValues(type, valueMap
 /* <T> */
@@ -832,42 +809,24 @@ function () {
 
     _defineProperty(this, "extensionASTNodes", void 0);
 
-    _defineProperty(this, "_typeConfig", void 0);
-
     _defineProperty(this, "_fields", void 0);
 
-    _defineProperty(this, "toJSON", void 0);
-
-    _defineProperty(this, "inspect", void 0);
-
     this.name = config.name;
     this.description = config.description;
     this.astNode = config.astNode;
-    this._typeConfig = config;
+    this.extensionASTNodes = config.extensionASTNodes;
+    this._fields = defineInputFieldMap.bind(undefined, config);
     !(typeof config.name === 'string') ? invariant(0, 'Must provide name.') : void 0;
   }
 
   var _proto6 = GraphQLInputObjectType.prototype;
 
   _proto6.getFields = function getFields() {
-    return this._fields || (this._fields = this._defineFieldMap());
-  };
-
-  _proto6._defineFieldMap = function _defineFieldMap() {
-    var _this = this;
-
-    var fieldMap = resolveThunk(this._typeConfig.fields) || {};
-    !isPlainObj(fieldMap) ? invariant(0, "".concat(this.name, " fields must be an object with field names as keys or a ") + 'function which returns such an object.') : void 0;
-    var resultFieldMap = Object.create(null);
-    Object.keys(fieldMap).forEach(function (fieldName) {
-      var field = _objectSpread({}, fieldMap[fieldName], {
-        name: fieldName
-      });
+    if (typeof this._fields === 'function') {
+      this._fields = this._fields();
+    }
 
-      !!field.hasOwnProperty('resolve') ? invariant(0, "".concat(_this.name, ".").concat(fieldName, " field type has a resolve property, but ") + 'Input Types cannot define resolvers.') : void 0;
-      resultFieldMap[fieldName] = field;
-    });
-    return resultFieldMap;
+    return this._fields;
   };
 
   _proto6.toString = function toString() {
@@ -877,7 +836,26 @@ function () {
   return GraphQLInputObjectType;
 }(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
 
-applyToStringTag(GraphQLInputObjectType); // Also provide toJSON and inspect aliases for toString.
+defineToStringTag(GraphQLInputObjectType);
+defineToJSON(GraphQLInputObjectType);
 
-GraphQLInputObjectType.prototype.toJSON = GraphQLInputObjectType.prototype.toString;
-GraphQLInputObjectType.prototype.inspect = GraphQLInputObjectType.prototype.toString;
\ No newline at end of file
+function defineInputFieldMap(config) {
+  var fieldMap = resolveThunk(config.fields) || {};
+  !isPlainObj(fieldMap) ? invariant(0, "".concat(config.name, " fields must be an object with field names as keys or a ") + 'function which returns such an object.') : void 0;
+  var resultFieldMap = Object.create(null);
+
+  var _arr2 = Object.keys(fieldMap);
+
+  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
+    var fieldName = _arr2[_i2];
+
+    var field = _objectSpread({}, fieldMap[fieldName], {
+      name: fieldName
+    });
+
+    !!field.hasOwnProperty('resolve') ? invariant(0, "".concat(config.name, ".").concat(fieldName, " field type has a resolve property, but ") + 'Input Types cannot define resolvers.') : void 0;
+    resultFieldMap[fieldName] = field;
+  }
+
+  return resultFieldMap;
+}
\ No newline at end of file
diff --git a/type/directives.js b/type/directives.js
index 0545df6..2067d61 100644
--- a/type/directives.js
+++ b/type/directives.js
@@ -5,13 +5,15 @@ Object.defineProperty(exports, "__esModule", {
 });
 exports.isDirective = isDirective;
 exports.isSpecifiedDirective = isSpecifiedDirective;
-exports.specifiedDirectives = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = void 0;
+exports.specifiedDirectives = exports.GraphQLIAMDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = void 0;
 
 var _definition = require("./definition");
 
 var _scalars = require("./scalars");
 
-var _applyToStringTag = _interopRequireDefault(require("../jsutils/applyToStringTag"));
+var _defineToStringTag = _interopRequireDefault(require("../jsutils/defineToStringTag"));
+
+var _defineToJSON = _interopRequireDefault(require("../jsutils/defineToJSON"));
 
 var _instanceOf = _interopRequireDefault(require("../jsutils/instanceOf"));
 
@@ -33,45 +35,58 @@ function isDirective(directive) {
  */
 
 
-var GraphQLDirective = function GraphQLDirective(config) {
-  _defineProperty(this, "name", void 0);
-
-  _defineProperty(this, "description", void 0);
-
-  _defineProperty(this, "locations", void 0);
-
-  _defineProperty(this, "args", void 0);
+var GraphQLDirective =
+/*#__PURE__*/
+function () {
+  function GraphQLDirective(config) {
+    _defineProperty(this, "name", void 0);
+
+    _defineProperty(this, "description", void 0);
+
+    _defineProperty(this, "locations", void 0);
+
+    _defineProperty(this, "args", void 0);
+
+    _defineProperty(this, "astNode", void 0);
+
+    this.name = config.name;
+    this.description = config.description;
+    this.locations = config.locations;
+    this.astNode = config.astNode;
+    !config.name ? (0, _invariant.default)(0, 'Directive must be named.') : void 0;
+    !Array.isArray(config.locations) ? (0, _invariant.default)(0, 'Must provide locations for directive.') : void 0;
+    var args = config.args;
+
+    if (!args) {
+      this.args = [];
+    } else {
+      !!Array.isArray(args) ? (0, _invariant.default)(0, "@".concat(config.name, " args must be an object with argument names as keys.")) : void 0;
+      this.args = Object.keys(args).map(function (argName) {
+        var arg = args[argName];
+        return {
+          name: argName,
+          description: arg.description === undefined ? null : arg.description,
+          type: arg.type,
+          defaultValue: arg.defaultValue,
+          astNode: arg.astNode
+        };
+      });
+    }
+  }
 
-  _defineProperty(this, "astNode", void 0);
+  var _proto = GraphQLDirective.prototype;
 
-  this.name = config.name;
-  this.description = config.description;
-  this.locations = config.locations;
-  this.astNode = config.astNode;
-  !config.name ? (0, _invariant.default)(0, 'Directive must be named.') : void 0;
-  !Array.isArray(config.locations) ? (0, _invariant.default)(0, 'Must provide locations for directive.') : void 0;
-  var args = config.args;
+  _proto.toString = function toString() {
+    return '@' + this.name;
+  };
 
-  if (!args) {
-    this.args = [];
-  } else {
-    !!Array.isArray(args) ? (0, _invariant.default)(0, "@".concat(config.name, " args must be an object with argument names as keys.")) : void 0;
-    this.args = Object.keys(args).map(function (argName) {
-      var arg = args[argName];
-      return {
-        name: argName,
-        description: arg.description === undefined ? null : arg.description,
-        type: arg.type,
-        defaultValue: arg.defaultValue,
-        astNode: arg.astNode
-      };
-    });
-  }
-}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
+  return GraphQLDirective;
+}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
 
 
 exports.GraphQLDirective = GraphQLDirective;
-(0, _applyToStringTag.default)(GraphQLDirective);
+(0, _defineToStringTag.default)(GraphQLDirective);
+(0, _defineToJSON.default)(GraphQLDirective);
 
 /**
  * Used to conditionally include fields or fragments.
@@ -127,11 +142,27 @@ var GraphQLDeprecatedDirective = new GraphQLDirective({
   }
 });
 /**
- * The full list of specified directives.
+ * Used to declare element of a GraphQL schema as restricted to certain permissions.
  */
 
 exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
-var specifiedDirectives = [GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective];
+var GraphQLIAMDirective = new GraphQLDirective({
+  name: 'iam',
+  description: 'Annotates the neccessary access permissions for the element.',
+  locations: [_directiveLocation.DirectiveLocation.FIELD_DEFINITION],
+  args: {
+    name: {
+      type: _scalars.GraphQLString,
+      description: 'Defines the access key'
+    }
+  }
+});
+/**
+ * The full list of specified directives.
+ */
+
+exports.GraphQLIAMDirective = GraphQLIAMDirective;
+var specifiedDirectives = [GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, GraphQLIAMDirective];
 exports.specifiedDirectives = specifiedDirectives;
 
 function isSpecifiedDirective(directive) {
diff --git a/type/directives.js.flow b/type/directives.js.flow
index 1d5ecea..bb2ef24 100644
--- a/type/directives.js.flow
+++ b/type/directives.js.flow
@@ -13,7 +13,8 @@ import type {
 } from './definition';
 import { GraphQLNonNull } from './definition';
 import { GraphQLString, GraphQLBoolean } from './scalars';
-import applyToStringTag from '../jsutils/applyToStringTag';
+import defineToStringTag from '../jsutils/defineToStringTag';
+import defineToJSON from '../jsutils/defineToJSON';
 import instanceOf from '../jsutils/instanceOf';
 import invariant from '../jsutils/invariant';
 import type { DirectiveDefinitionNode } from '../language/ast';
@@ -75,18 +76,23 @@ export class GraphQLDirective {
       });
     }
   }
+
+  toString(): string {
+    return '@' + this.name;
+  }
 }
 
 // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
-applyToStringTag(GraphQLDirective);
+defineToStringTag(GraphQLDirective);
+defineToJSON(GraphQLDirective);
 
-export type GraphQLDirectiveConfig = {
+export type GraphQLDirectiveConfig = {|
   name: string,
   description?: ?string,
   locations: Array<DirectiveLocationEnum>,
   args?: ?GraphQLFieldConfigArgumentMap,
   astNode?: ?DirectiveDefinitionNode,
-};
+|};
 
 /**
  * Used to conditionally include fields or fragments.
@@ -154,6 +160,21 @@ export const GraphQLDeprecatedDirective = new GraphQLDirective({
   },
 });
 
+/**
+ * Used to declare element of a GraphQL schema as restricted to certain permissions.
+ */
+export const GraphQLIAMDirective = new GraphQLDirective({
+  name: 'iam',
+  description: 'Annotates the neccessary access permissions for the element.',
+  locations: [DirectiveLocation.FIELD_DEFINITION],
+  args: {
+    name: {
+      type: GraphQLString,
+      description: 'Defines the access key',
+    },
+  },
+});
+
 /**
  * The full list of specified directives.
  */
@@ -161,6 +182,7 @@ export const specifiedDirectives: $ReadOnlyArray<*> = [
   GraphQLIncludeDirective,
   GraphQLSkipDirective,
   GraphQLDeprecatedDirective,
+  GraphQLIAMDirective,
 ];
 
 export function isSpecifiedDirective(
diff --git a/type/directives.mjs b/type/directives.mjs
index a9675b3..fe6ba57 100644
--- a/type/directives.mjs
+++ b/type/directives.mjs
@@ -10,7 +10,8 @@ function _defineProperty(obj, key, value) { if (key in obj) { Object.definePrope
  */
 import { GraphQLNonNull } from './definition';
 import { GraphQLString, GraphQLBoolean } from './scalars';
-import applyToStringTag from '../jsutils/applyToStringTag';
+import defineToStringTag from '../jsutils/defineToStringTag';
+import defineToJSON from '../jsutils/defineToJSON';
 import instanceOf from '../jsutils/instanceOf';
 import invariant from '../jsutils/invariant';
 import { DirectiveLocation } from '../language/directiveLocation';
@@ -27,43 +28,56 @@ export function isDirective(directive) {
  * behavior. Type system creators will usually not create these directly.
  */
 
-export var GraphQLDirective = function GraphQLDirective(config) {
-  _defineProperty(this, "name", void 0);
-
-  _defineProperty(this, "description", void 0);
-
-  _defineProperty(this, "locations", void 0);
-
-  _defineProperty(this, "args", void 0);
-
-  _defineProperty(this, "astNode", void 0);
-
-  this.name = config.name;
-  this.description = config.description;
-  this.locations = config.locations;
-  this.astNode = config.astNode;
-  !config.name ? invariant(0, 'Directive must be named.') : void 0;
-  !Array.isArray(config.locations) ? invariant(0, 'Must provide locations for directive.') : void 0;
-  var args = config.args;
-
-  if (!args) {
-    this.args = [];
-  } else {
-    !!Array.isArray(args) ? invariant(0, "@".concat(config.name, " args must be an object with argument names as keys.")) : void 0;
-    this.args = Object.keys(args).map(function (argName) {
-      var arg = args[argName];
-      return {
-        name: argName,
-        description: arg.description === undefined ? null : arg.description,
-        type: arg.type,
-        defaultValue: arg.defaultValue,
-        astNode: arg.astNode
-      };
-    });
+export var GraphQLDirective =
+/*#__PURE__*/
+function () {
+  function GraphQLDirective(config) {
+    _defineProperty(this, "name", void 0);
+
+    _defineProperty(this, "description", void 0);
+
+    _defineProperty(this, "locations", void 0);
+
+    _defineProperty(this, "args", void 0);
+
+    _defineProperty(this, "astNode", void 0);
+
+    this.name = config.name;
+    this.description = config.description;
+    this.locations = config.locations;
+    this.astNode = config.astNode;
+    !config.name ? invariant(0, 'Directive must be named.') : void 0;
+    !Array.isArray(config.locations) ? invariant(0, 'Must provide locations for directive.') : void 0;
+    var args = config.args;
+
+    if (!args) {
+      this.args = [];
+    } else {
+      !!Array.isArray(args) ? invariant(0, "@".concat(config.name, " args must be an object with argument names as keys.")) : void 0;
+      this.args = Object.keys(args).map(function (argName) {
+        var arg = args[argName];
+        return {
+          name: argName,
+          description: arg.description === undefined ? null : arg.description,
+          type: arg.type,
+          defaultValue: arg.defaultValue,
+          astNode: arg.astNode
+        };
+      });
+    }
   }
-}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
 
-applyToStringTag(GraphQLDirective);
+  var _proto = GraphQLDirective.prototype;
+
+  _proto.toString = function toString() {
+    return '@' + this.name;
+  };
+
+  return GraphQLDirective;
+}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
+
+defineToStringTag(GraphQLDirective);
+defineToJSON(GraphQLDirective);
 
 /**
  * Used to conditionally include fields or fragments.
@@ -115,11 +129,26 @@ export var GraphQLDeprecatedDirective = new GraphQLDirective({
     }
   }
 });
+/**
+ * Used to declare element of a GraphQL schema as restricted to certain permissions.
+ */
+
+export var GraphQLIAMDirective = new GraphQLDirective({
+  name: 'iam',
+  description: 'Annotates the neccessary access permissions for the element.',
+  locations: [DirectiveLocation.FIELD_DEFINITION],
+  args: {
+    name: {
+      type: GraphQLString,
+      description: 'Defines the access key'
+    }
+  }
+});
 /**
  * The full list of specified directives.
  */
 
-export var specifiedDirectives = [GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective];
+export var specifiedDirectives = [GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, GraphQLIAMDirective];
 export function isSpecifiedDirective(directive) {
   return specifiedDirectives.some(function (specifiedDirective) {
     return specifiedDirective.name === directive.name;
diff --git a/type/index.js b/type/index.js
index fa73403..c9794b7 100644
--- a/type/index.js
+++ b/type/index.js
@@ -321,6 +321,12 @@ Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
     return _directives.GraphQLDeprecatedDirective;
   }
 });
+Object.defineProperty(exports, "GraphQLIAMDirective", {
+  enumerable: true,
+  get: function get() {
+    return _directives.GraphQLIAMDirective;
+  }
+});
 Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
   enumerable: true,
   get: function get() {
diff --git a/type/index.js.flow b/type/index.js.flow
index f7ac4fd..bf8c7e0 100644
--- a/type/index.js.flow
+++ b/type/index.js.flow
@@ -79,6 +79,7 @@ export {
   GraphQLIncludeDirective,
   GraphQLSkipDirective,
   GraphQLDeprecatedDirective,
+  GraphQLIAMDirective,
   // Constant Deprecation Reason
   DEFAULT_DEPRECATION_REASON,
 } from './directives';
@@ -152,6 +153,9 @@ export type {
   GraphQLScalarTypeConfig,
   GraphQLTypeResolver,
   GraphQLUnionTypeConfig,
+  GraphQLScalarSerializer,
+  GraphQLScalarValueParser,
+  GraphQLScalarLiteralParser,
 } from './definition';
 
 export { validateSchema, assertValidSchema } from './validate';
diff --git a/type/index.mjs b/type/index.mjs
index 2a245ee..99bf733 100644
--- a/type/index.mjs
+++ b/type/index.mjs
@@ -18,7 +18,7 @@ GraphQLList, GraphQLNonNull } from './definition';
 export { // Predicate
 isDirective, // Directives Definition
 GraphQLDirective, // Built-in Directives defined by the Spec
-isSpecifiedDirective, specifiedDirectives, GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, // Constant Deprecation Reason
+isSpecifiedDirective, specifiedDirectives, GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, GraphQLIAMDirective, // Constant Deprecation Reason
 DEFAULT_DEPRECATION_REASON } from './directives';
 // Common built-in scalar instances.
 export { isSpecifiedScalarType, specifiedScalarTypes, GraphQLInt, GraphQLFloat, GraphQLString, GraphQLBoolean, GraphQLID } from './scalars';
diff --git a/type/introspection.js b/type/introspection.js
index db2a123..24efcfa 100644
--- a/type/introspection.js
+++ b/type/introspection.js
@@ -32,7 +32,6 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
  */
 var __Schema = new _definition.GraphQLObjectType({
   name: '__Schema',
-  isIntrospection: true,
   description: 'A GraphQL Schema defines the capabilities of a GraphQL server. It ' + 'exposes all available types and directives on the server, as well as ' + 'the entry points for query, mutation, and subscription operations.',
   fields: function fields() {
     return {
@@ -79,7 +78,6 @@ exports.__Schema = __Schema;
 
 var __Directive = new _definition.GraphQLObjectType({
   name: '__Directive',
-  isIntrospection: true,
   description: 'A Directive provides a way to describe alternate runtime execution and ' + 'type validation behavior in a GraphQL document.' + "\n\nIn some cases, you need to provide options to alter GraphQL's " + 'execution behavior in ways field arguments will not suffice, such as ' + 'conditionally including or skipping a field. Directives provide this by ' + 'describing additional information to the executor.',
   fields: function fields() {
     return {
@@ -106,29 +104,6 @@ var __Directive = new _definition.GraphQLObjectType({
         resolve: function resolve(directive) {
           return directive.args || [];
         }
-      },
-      // NOTE: the following three fields are deprecated and are no longer part
-      // of the GraphQL specification.
-      onOperation: {
-        deprecationReason: 'Use `locations`.',
-        type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLBoolean),
-        resolve: function resolve(d) {
-          return d.locations.indexOf(_directiveLocation.DirectiveLocation.QUERY) !== -1 || d.locations.indexOf(_directiveLocation.DirectiveLocation.MUTATION) !== -1 || d.locations.indexOf(_directiveLocation.DirectiveLocation.SUBSCRIPTION) !== -1;
-        }
-      },
-      onFragment: {
-        deprecationReason: 'Use `locations`.',
-        type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLBoolean),
-        resolve: function resolve(d) {
-          return d.locations.indexOf(_directiveLocation.DirectiveLocation.FRAGMENT_SPREAD) !== -1 || d.locations.indexOf(_directiveLocation.DirectiveLocation.INLINE_FRAGMENT) !== -1 || d.locations.indexOf(_directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION) !== -1;
-        }
-      },
-      onField: {
-        deprecationReason: 'Use `locations`.',
-        type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLBoolean),
-        resolve: function resolve(d) {
-          return d.locations.indexOf(_directiveLocation.DirectiveLocation.FIELD) !== -1;
-        }
       }
     };
   }
@@ -138,7 +113,6 @@ exports.__Directive = __Directive;
 
 var __DirectiveLocation = new _definition.GraphQLEnumType({
   name: '__DirectiveLocation',
-  isIntrospection: true,
   description: 'A Directive can be adjacent to many parts of the GraphQL language, a ' + '__DirectiveLocation describes one such possible adjacencies.',
   values: {
     QUERY: {
@@ -220,7 +194,6 @@ exports.__DirectiveLocation = __DirectiveLocation;
 
 var __Type = new _definition.GraphQLObjectType({
   name: '__Type',
-  isIntrospection: true,
   description: 'The fundamental unit of any GraphQL Schema is the type. There are ' + 'many kinds of types in GraphQL as represented by the `__TypeKind` enum.' + '\n\nDepending on the kind of a type, certain fields describe ' + 'information about that type. Scalar types provide no information ' + 'beyond a name and description, while Enum types provide their values. ' + 'Object and Interface types provide the fields they describe. Abstract ' + 'types, Union and Interface, provide the Object types possible ' + 'at runtime. List and NonNull types compose other types.',
   fields: function fields() {
     return {
@@ -266,10 +239,15 @@ var __Type = new _definition.GraphQLObjectType({
           includeDeprecated: {
             type: _scalars.GraphQLBoolean,
             defaultValue: false
+          },
+          includeIAM: {
+            type: _scalars.GraphQLBoolean,
+            defaultValue: false
           }
         },
         resolve: function resolve(type, _ref) {
-          var includeDeprecated = _ref.includeDeprecated;
+          var includeDeprecated = _ref.includeDeprecated,
+              includeIAM = _ref.includeIAM;
 
           if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
             var fields = (0, _objectValues.default)(type.getFields());
@@ -280,6 +258,12 @@ var __Type = new _definition.GraphQLObjectType({
               });
             }
 
+            if (!includeIAM) {
+              fields = fields.filter(function (field) {
+                return !field.iamName;
+              });
+            }
+
             return fields;
           }
 
@@ -350,7 +334,6 @@ exports.__Type = __Type;
 
 var __Field = new _definition.GraphQLObjectType({
   name: '__Field',
-  isIntrospection: true,
   description: 'Object and Interface types are described by a list of Fields, each of ' + 'which has a name, potentially a list of arguments, and a return type.',
   fields: function fields() {
     return {
@@ -389,6 +372,12 @@ var __Field = new _definition.GraphQLObjectType({
         resolve: function resolve(obj) {
           return obj.deprecationReason;
         }
+      },
+      iamName: {
+        type: _scalars.GraphQLString,
+        resolve: function resolve(obj) {
+          return obj.iamName;
+        }
       }
     };
   }
@@ -398,7 +387,6 @@ exports.__Field = __Field;
 
 var __InputValue = new _definition.GraphQLObjectType({
   name: '__InputValue',
-  isIntrospection: true,
   description: 'Arguments provided to Fields or Directives and the input fields of an ' + 'InputObject are represented as Input Values which describe their type ' + 'and optionally a default value.',
   fields: function fields() {
     return {
@@ -435,7 +423,6 @@ exports.__InputValue = __InputValue;
 
 var __EnumValue = new _definition.GraphQLObjectType({
   name: '__EnumValue',
-  isIntrospection: true,
   description: 'One possible value for a given Enum. Enum values are unique values, not ' + 'a placeholder for a string or numeric value. However an Enum value is ' + 'returned in a JSON response as a string.',
   fields: function fields() {
     return {
@@ -482,7 +469,6 @@ exports.TypeKind = TypeKind;
 
 var __TypeKind = new _definition.GraphQLEnumType({
   name: '__TypeKind',
-  isIntrospection: true,
   description: 'An enum describing what kind of type a given `__Type` is.',
   values: {
     SCALAR: {
diff --git a/type/introspection.js.flow b/type/introspection.js.flow
index e3787ba..0215fcd 100644
--- a/type/introspection.js.flow
+++ b/type/introspection.js.flow
@@ -33,7 +33,6 @@ import type { GraphQLField } from './definition';
 
 export const __Schema = new GraphQLObjectType({
   name: '__Schema',
-  isIntrospection: true,
   description:
     'A GraphQL Schema defines the capabilities of a GraphQL server. It ' +
     'exposes all available types and directives on the server, as well as ' +
@@ -75,7 +74,6 @@ export const __Schema = new GraphQLObjectType({
 
 export const __Directive = new GraphQLObjectType({
   name: '__Directive',
-  isIntrospection: true,
   description:
     'A Directive provides a way to describe alternate runtime execution and ' +
     'type validation behavior in a GraphQL document.' +
@@ -100,35 +98,11 @@ export const __Directive = new GraphQLObjectType({
       type: GraphQLNonNull(GraphQLList(GraphQLNonNull(__InputValue))),
       resolve: directive => directive.args || [],
     },
-    // NOTE: the following three fields are deprecated and are no longer part
-    // of the GraphQL specification.
-    onOperation: {
-      deprecationReason: 'Use `locations`.',
-      type: GraphQLNonNull(GraphQLBoolean),
-      resolve: d =>
-        d.locations.indexOf(DirectiveLocation.QUERY) !== -1 ||
-        d.locations.indexOf(DirectiveLocation.MUTATION) !== -1 ||
-        d.locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1,
-    },
-    onFragment: {
-      deprecationReason: 'Use `locations`.',
-      type: GraphQLNonNull(GraphQLBoolean),
-      resolve: d =>
-        d.locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1 ||
-        d.locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1 ||
-        d.locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1,
-    },
-    onField: {
-      deprecationReason: 'Use `locations`.',
-      type: GraphQLNonNull(GraphQLBoolean),
-      resolve: d => d.locations.indexOf(DirectiveLocation.FIELD) !== -1,
-    },
   }),
 });
 
 export const __DirectiveLocation = new GraphQLEnumType({
   name: '__DirectiveLocation',
-  isIntrospection: true,
   description:
     'A Directive can be adjacent to many parts of the GraphQL language, a ' +
     '__DirectiveLocation describes one such possible adjacencies.',
@@ -210,7 +184,6 @@ export const __DirectiveLocation = new GraphQLEnumType({
 
 export const __Type = new GraphQLObjectType({
   name: '__Type',
-  isIntrospection: true,
   description:
     'The fundamental unit of any GraphQL Schema is the type. There are ' +
     'many kinds of types in GraphQL as represented by the `__TypeKind` enum.' +
@@ -256,13 +229,17 @@ export const __Type = new GraphQLObjectType({
       type: GraphQLList(GraphQLNonNull(__Field)),
       args: {
         includeDeprecated: { type: GraphQLBoolean, defaultValue: false },
+        includeIAM: { type: GraphQLBoolean, defaultValue: false },
       },
-      resolve(type, { includeDeprecated }) {
+      resolve(type, { includeDeprecated, includeIAM }) {
         if (isObjectType(type) || isInterfaceType(type)) {
           let fields = objectValues(type.getFields());
           if (!includeDeprecated) {
             fields = fields.filter(field => !field.deprecationReason);
           }
+          if (!includeIAM) {
+            fields = fields.filter(field => !field.iamName);
+          }
           return fields;
         }
         return null;
@@ -316,7 +293,6 @@ export const __Type = new GraphQLObjectType({
 
 export const __Field = new GraphQLObjectType({
   name: '__Field',
-  isIntrospection: true,
   description:
     'Object and Interface types are described by a list of Fields, each of ' +
     'which has a name, potentially a list of arguments, and a return type.',
@@ -345,12 +321,15 @@ export const __Field = new GraphQLObjectType({
       type: GraphQLString,
       resolve: obj => obj.deprecationReason,
     },
+    iamName: {
+      type: GraphQLString,
+      resolve: obj => obj.iamName,
+    },
   }),
 });
 
 export const __InputValue = new GraphQLObjectType({
   name: '__InputValue',
-  isIntrospection: true,
   description:
     'Arguments provided to Fields or Directives and the input fields of an ' +
     'InputObject are represented as Input Values which describe their type ' +
@@ -383,7 +362,6 @@ export const __InputValue = new GraphQLObjectType({
 
 export const __EnumValue = new GraphQLObjectType({
   name: '__EnumValue',
-  isIntrospection: true,
   description:
     'One possible value for a given Enum. Enum values are unique values, not ' +
     'a placeholder for a string or numeric value. However an Enum value is ' +
@@ -421,7 +399,6 @@ export const TypeKind = {
 
 export const __TypeKind = new GraphQLEnumType({
   name: '__TypeKind',
-  isIntrospection: true,
   description: 'An enum describing what kind of type a given `__Type` is.',
   values: {
     SCALAR: {
diff --git a/type/introspection.mjs b/type/introspection.mjs
index f9095eb..fdf375b 100644
--- a/type/introspection.mjs
+++ b/type/introspection.mjs
@@ -15,7 +15,6 @@ import { GraphQLString, GraphQLBoolean } from './scalars';
 import { DirectiveLocation } from '../language/directiveLocation';
 export var __Schema = new GraphQLObjectType({
   name: '__Schema',
-  isIntrospection: true,
   description: 'A GraphQL Schema defines the capabilities of a GraphQL server. It ' + 'exposes all available types and directives on the server, as well as ' + 'the entry points for query, mutation, and subscription operations.',
   fields: function fields() {
     return {
@@ -59,7 +58,6 @@ export var __Schema = new GraphQLObjectType({
 });
 export var __Directive = new GraphQLObjectType({
   name: '__Directive',
-  isIntrospection: true,
   description: 'A Directive provides a way to describe alternate runtime execution and ' + 'type validation behavior in a GraphQL document.' + "\n\nIn some cases, you need to provide options to alter GraphQL's " + 'execution behavior in ways field arguments will not suffice, such as ' + 'conditionally including or skipping a field. Directives provide this by ' + 'describing additional information to the executor.',
   fields: function fields() {
     return {
@@ -86,36 +84,12 @@ export var __Directive = new GraphQLObjectType({
         resolve: function resolve(directive) {
           return directive.args || [];
         }
-      },
-      // NOTE: the following three fields are deprecated and are no longer part
-      // of the GraphQL specification.
-      onOperation: {
-        deprecationReason: 'Use `locations`.',
-        type: GraphQLNonNull(GraphQLBoolean),
-        resolve: function resolve(d) {
-          return d.locations.indexOf(DirectiveLocation.QUERY) !== -1 || d.locations.indexOf(DirectiveLocation.MUTATION) !== -1 || d.locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;
-        }
-      },
-      onFragment: {
-        deprecationReason: 'Use `locations`.',
-        type: GraphQLNonNull(GraphQLBoolean),
-        resolve: function resolve(d) {
-          return d.locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1 || d.locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1 || d.locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;
-        }
-      },
-      onField: {
-        deprecationReason: 'Use `locations`.',
-        type: GraphQLNonNull(GraphQLBoolean),
-        resolve: function resolve(d) {
-          return d.locations.indexOf(DirectiveLocation.FIELD) !== -1;
-        }
       }
     };
   }
 });
 export var __DirectiveLocation = new GraphQLEnumType({
   name: '__DirectiveLocation',
-  isIntrospection: true,
   description: 'A Directive can be adjacent to many parts of the GraphQL language, a ' + '__DirectiveLocation describes one such possible adjacencies.',
   values: {
     QUERY: {
@@ -194,7 +168,6 @@ export var __DirectiveLocation = new GraphQLEnumType({
 });
 export var __Type = new GraphQLObjectType({
   name: '__Type',
-  isIntrospection: true,
   description: 'The fundamental unit of any GraphQL Schema is the type. There are ' + 'many kinds of types in GraphQL as represented by the `__TypeKind` enum.' + '\n\nDepending on the kind of a type, certain fields describe ' + 'information about that type. Scalar types provide no information ' + 'beyond a name and description, while Enum types provide their values. ' + 'Object and Interface types provide the fields they describe. Abstract ' + 'types, Union and Interface, provide the Object types possible ' + 'at runtime. List and NonNull types compose other types.',
   fields: function fields() {
     return {
@@ -240,10 +213,15 @@ export var __Type = new GraphQLObjectType({
           includeDeprecated: {
             type: GraphQLBoolean,
             defaultValue: false
+          },
+          includeIAM: {
+            type: GraphQLBoolean,
+            defaultValue: false
           }
         },
         resolve: function resolve(type, _ref) {
-          var includeDeprecated = _ref.includeDeprecated;
+          var includeDeprecated = _ref.includeDeprecated,
+              includeIAM = _ref.includeIAM;
 
           if (isObjectType(type) || isInterfaceType(type)) {
             var fields = objectValues(type.getFields());
@@ -254,6 +232,12 @@ export var __Type = new GraphQLObjectType({
               });
             }
 
+            if (!includeIAM) {
+              fields = fields.filter(function (field) {
+                return !field.iamName;
+              });
+            }
+
             return fields;
           }
 
@@ -321,7 +305,6 @@ export var __Type = new GraphQLObjectType({
 });
 export var __Field = new GraphQLObjectType({
   name: '__Field',
-  isIntrospection: true,
   description: 'Object and Interface types are described by a list of Fields, each of ' + 'which has a name, potentially a list of arguments, and a return type.',
   fields: function fields() {
     return {
@@ -360,13 +343,18 @@ export var __Field = new GraphQLObjectType({
         resolve: function resolve(obj) {
           return obj.deprecationReason;
         }
+      },
+      iamName: {
+        type: GraphQLString,
+        resolve: function resolve(obj) {
+          return obj.iamName;
+        }
       }
     };
   }
 });
 export var __InputValue = new GraphQLObjectType({
   name: '__InputValue',
-  isIntrospection: true,
   description: 'Arguments provided to Fields or Directives and the input fields of an ' + 'InputObject are represented as Input Values which describe their type ' + 'and optionally a default value.',
   fields: function fields() {
     return {
@@ -400,7 +388,6 @@ export var __InputValue = new GraphQLObjectType({
 });
 export var __EnumValue = new GraphQLObjectType({
   name: '__EnumValue',
-  isIntrospection: true,
   description: 'One possible value for a given Enum. Enum values are unique values, not ' + 'a placeholder for a string or numeric value. However an Enum value is ' + 'returned in a JSON response as a string.',
   fields: function fields() {
     return {
@@ -443,7 +430,6 @@ export var TypeKind = {
 };
 export var __TypeKind = new GraphQLEnumType({
   name: '__TypeKind',
-  isIntrospection: true,
   description: 'An enum describing what kind of type a given `__Type` is.',
   values: {
     SCALAR: {
diff --git a/type/scalars.js b/type/scalars.js
index 9a650a7..ea797bb 100644
--- a/type/scalars.js
+++ b/type/scalars.js
@@ -8,6 +8,8 @@ exports.specifiedScalarTypes = exports.GraphQLID = exports.GraphQLBoolean = expo
 
 var _inspect = _interopRequireDefault(require("../jsutils/inspect"));
 
+var _isFinite = _interopRequireDefault(require("../jsutils/isFinite"));
+
 var _isInteger = _interopRequireDefault(require("../jsutils/isInteger"));
 
 var _definition = require("./definition");
@@ -32,32 +34,44 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
 var MAX_INT = 2147483647;
 var MIN_INT = -2147483648;
 
-function coerceInt(value) {
-  if (Array.isArray(value)) {
-    throw new TypeError("Int cannot represent an array value: [".concat(String(value), "]"));
+function serializeInt(value) {
+  if (typeof value === 'boolean') {
+    return value ? 1 : 0;
   }
 
-  if (value === '') {
-    throw new TypeError('Int cannot represent non-integer value: (empty string)');
-  }
+  var num = value;
 
-  var num = Number(value);
+  if (typeof value === 'string' && value !== '') {
+    num = Number(value);
+  }
 
   if (!(0, _isInteger.default)(num)) {
-    throw new TypeError('Int cannot represent non-integer value: ' + (0, _inspect.default)(value));
+    throw new TypeError("Int cannot represent non-integer value: ".concat((0, _inspect.default)(value)));
   }
 
   if (num > MAX_INT || num < MIN_INT) {
-    throw new TypeError('Int cannot represent non 32-bit signed integer value: ' + (0, _inspect.default)(value));
+    throw new TypeError("Int cannot represent non 32-bit signed integer value: ".concat((0, _inspect.default)(value)));
   }
 
   return num;
 }
 
+function coerceInt(value) {
+  if (!(0, _isInteger.default)(value)) {
+    throw new TypeError("Int cannot represent non-integer value: ".concat((0, _inspect.default)(value)));
+  }
+
+  if (value > MAX_INT || value < MIN_INT) {
+    throw new TypeError("Int cannot represent non 32-bit signed integer value: ".concat((0, _inspect.default)(value)));
+  }
+
+  return value;
+}
+
 var GraphQLInt = new _definition.GraphQLScalarType({
   name: 'Int',
   description: 'The `Int` scalar type represents non-fractional signed whole numeric ' + 'values. Int can represent values between -(2^31) and 2^31 - 1. ',
-  serialize: coerceInt,
+  serialize: serializeInt,
   parseValue: coerceInt,
   parseLiteral: function parseLiteral(ast) {
     if (ast.kind === _kinds.Kind.INT) {
@@ -73,28 +87,36 @@ var GraphQLInt = new _definition.GraphQLScalarType({
 });
 exports.GraphQLInt = GraphQLInt;
 
-function coerceFloat(value) {
-  if (Array.isArray(value)) {
-    throw new TypeError("Float cannot represent an array value: [".concat(String(value), "]"));
+function serializeFloat(value) {
+  if (typeof value === 'boolean') {
+    return value ? 1 : 0;
   }
 
-  if (value === '') {
-    throw new TypeError('Float cannot represent non numeric value: (empty string)');
+  var num = value;
+
+  if (typeof value === 'string' && value !== '') {
+    num = Number(value);
+  }
+
+  if (!(0, _isFinite.default)(num)) {
+    throw new TypeError("Float cannot represent non numeric value: ".concat((0, _inspect.default)(value)));
   }
 
-  var num = Number(value);
+  return num;
+}
 
-  if (isFinite(num)) {
-    return num;
+function coerceFloat(value) {
+  if (!(0, _isFinite.default)(value)) {
+    throw new TypeError("Float cannot represent non numeric value: ".concat((0, _inspect.default)(value)));
   }
 
-  throw new TypeError('Float cannot represent non numeric value: ' + (0, _inspect.default)(value));
+  return value;
 }
 
 var GraphQLFloat = new _definition.GraphQLScalarType({
   name: 'Float',
   description: 'The `Float` scalar type represents signed double-precision fractional ' + 'values as specified by ' + '[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). ',
-  serialize: coerceFloat,
+  serialize: serializeFloat,
   parseValue: coerceFloat,
   parseLiteral: function parseLiteral(ast) {
     return ast.kind === _kinds.Kind.FLOAT || ast.kind === _kinds.Kind.INT ? parseFloat(ast.value) : undefined;
@@ -102,18 +124,40 @@ var GraphQLFloat = new _definition.GraphQLScalarType({
 });
 exports.GraphQLFloat = GraphQLFloat;
 
+function serializeString(value) {
+  // Support serializing objects with custom valueOf() functions - a common way
+  // to represent an complex value which can be represented as a string
+  // (ex: MongoDB id objects).
+  var result = value && typeof value.valueOf === 'function' ? value.valueOf() : value; // Serialize string, boolean and number values to a string, but do not
+  // attempt to coerce object, function, symbol, or other types as strings.
+
+  if (typeof result === 'string') {
+    return result;
+  }
+
+  if (typeof result === 'boolean') {
+    return result ? 'true' : 'false';
+  }
+
+  if ((0, _isFinite.default)(result)) {
+    return result.toString();
+  }
+
+  throw new TypeError("String cannot represent value: ".concat((0, _inspect.default)(value)));
+}
+
 function coerceString(value) {
-  if (Array.isArray(value)) {
-    throw new TypeError("String cannot represent an array value: ".concat((0, _inspect.default)(value)));
+  if (typeof value !== 'string') {
+    throw new TypeError("String cannot represent a non string value: ".concat((0, _inspect.default)(value)));
   }
 
-  return String(value);
+  return value;
 }
 
 var GraphQLString = new _definition.GraphQLScalarType({
   name: 'String',
   description: 'The `String` scalar type represents textual data, represented as UTF-8 ' + 'character sequences. The String type is most often used by GraphQL to ' + 'represent free-form human-readable text.',
-  serialize: coerceString,
+  serialize: serializeString,
   parseValue: coerceString,
   parseLiteral: function parseLiteral(ast) {
     return ast.kind === _kinds.Kind.STRING ? ast.value : undefined;
@@ -121,29 +165,70 @@ var GraphQLString = new _definition.GraphQLScalarType({
 });
 exports.GraphQLString = GraphQLString;
 
+function serializeBoolean(value) {
+  if (typeof value === 'boolean') {
+    return value;
+  }
+
+  if ((0, _isFinite.default)(value)) {
+    return value !== 0;
+  }
+
+  throw new TypeError("Boolean cannot represent a non boolean value: ".concat((0, _inspect.default)(value)));
+}
+
 function coerceBoolean(value) {
-  if (Array.isArray(value)) {
-    throw new TypeError("Boolean cannot represent an array value: [".concat(String(value), "]"));
+  if (typeof value !== 'boolean') {
+    throw new TypeError("Boolean cannot represent a non boolean value: ".concat((0, _inspect.default)(value)));
   }
 
-  return Boolean(value);
+  return value;
 }
 
 var GraphQLBoolean = new _definition.GraphQLScalarType({
   name: 'Boolean',
   description: 'The `Boolean` scalar type represents `true` or `false`.',
-  serialize: coerceBoolean,
+  serialize: serializeBoolean,
   parseValue: coerceBoolean,
   parseLiteral: function parseLiteral(ast) {
     return ast.kind === _kinds.Kind.BOOLEAN ? ast.value : undefined;
   }
 });
 exports.GraphQLBoolean = GraphQLBoolean;
+
+function serializeID(value) {
+  // Support serializing objects with custom valueOf() functions - a common way
+  // to represent an object identifier (ex. MongoDB).
+  var result = value && typeof value.valueOf === 'function' ? value.valueOf() : value;
+
+  if (typeof result === 'string') {
+    return result;
+  }
+
+  if ((0, _isInteger.default)(result)) {
+    return String(result);
+  }
+
+  throw new TypeError("ID cannot represent value: ".concat((0, _inspect.default)(value)));
+}
+
+function coerceID(value) {
+  if (typeof value === 'string') {
+    return value;
+  }
+
+  if ((0, _isInteger.default)(value)) {
+    return value.toString();
+  }
+
+  throw new TypeError("ID cannot represent value: ".concat((0, _inspect.default)(value)));
+}
+
 var GraphQLID = new _definition.GraphQLScalarType({
   name: 'ID',
   description: 'The `ID` scalar type represents a unique identifier, often used to ' + 'refetch an object or as key for a cache. The ID type appears in a JSON ' + 'response as a String; however, it is not intended to be human-readable. ' + 'When expected as an input type, any string (such as `"4"`) or integer ' + '(such as `4`) input value will be accepted as an ID.',
-  serialize: coerceString,
-  parseValue: coerceString,
+  serialize: serializeID,
+  parseValue: coerceID,
   parseLiteral: function parseLiteral(ast) {
     return ast.kind === _kinds.Kind.STRING || ast.kind === _kinds.Kind.INT ? ast.value : undefined;
   }
diff --git a/type/scalars.js.flow b/type/scalars.js.flow
index 72400b2..89f6ed2 100644
--- a/type/scalars.js.flow
+++ b/type/scalars.js.flow
@@ -8,6 +8,7 @@
  */
 
 import inspect from '../jsutils/inspect';
+import isFinite from '../jsutils/isFinite';
 import isInteger from '../jsutils/isInteger';
 import { GraphQLScalarType, isNamedType } from './definition';
 import { Kind } from '../language/kinds';
@@ -20,30 +21,41 @@ import { Kind } from '../language/kinds';
 const MAX_INT = 2147483647;
 const MIN_INT = -2147483648;
 
-function coerceInt(value: mixed): number {
-  if (Array.isArray(value)) {
+function serializeInt(value: mixed): number {
+  if (typeof value === 'boolean') {
+    return value ? 1 : 0;
+  }
+
+  let num = value;
+  if (typeof value === 'string' && value !== '') {
+    num = Number(value);
+  }
+
+  if (!isInteger(num)) {
     throw new TypeError(
-      `Int cannot represent an array value: [${String(value)}]`,
+      `Int cannot represent non-integer value: ${inspect(value)}`,
     );
   }
-  if (value === '') {
+  if (num > MAX_INT || num < MIN_INT) {
     throw new TypeError(
-      'Int cannot represent non-integer value: (empty string)',
+      `Int cannot represent non 32-bit signed integer value: ${inspect(value)}`,
     );
   }
-  const num = Number(value);
-  if (!isInteger(num)) {
+  return num;
+}
+
+function coerceInt(value: mixed): number {
+  if (!isInteger(value)) {
     throw new TypeError(
-      'Int cannot represent non-integer value: ' + inspect(value),
+      `Int cannot represent non-integer value: ${inspect(value)}`,
     );
   }
-
-  if (num > MAX_INT || num < MIN_INT) {
+  if (value > MAX_INT || value < MIN_INT) {
     throw new TypeError(
-      'Int cannot represent non 32-bit signed integer value: ' + inspect(value),
+      `Int cannot represent non 32-bit signed integer value: ${inspect(value)}`,
     );
   }
-  return num;
+  return value;
 }
 
 export const GraphQLInt = new GraphQLScalarType({
@@ -51,7 +63,7 @@ export const GraphQLInt = new GraphQLScalarType({
   description:
     'The `Int` scalar type represents non-fractional signed whole numeric ' +
     'values. Int can represent values between -(2^31) and 2^31 - 1. ',
-  serialize: coerceInt,
+  serialize: serializeInt,
   parseValue: coerceInt,
   parseLiteral(ast) {
     if (ast.kind === Kind.INT) {
@@ -64,24 +76,30 @@ export const GraphQLInt = new GraphQLScalarType({
   },
 });
 
-function coerceFloat(value: mixed): number {
-  if (Array.isArray(value)) {
+function serializeFloat(value: mixed): number {
+  if (typeof value === 'boolean') {
+    return value ? 1 : 0;
+  }
+
+  let num = value;
+  if (typeof value === 'string' && value !== '') {
+    num = Number(value);
+  }
+  if (!isFinite(num)) {
     throw new TypeError(
-      `Float cannot represent an array value: [${String(value)}]`,
+      `Float cannot represent non numeric value: ${inspect(value)}`,
     );
   }
-  if (value === '') {
+  return num;
+}
+
+function coerceFloat(value: mixed): number {
+  if (!isFinite(value)) {
     throw new TypeError(
-      'Float cannot represent non numeric value: (empty string)',
+      `Float cannot represent non numeric value: ${inspect(value)}`,
     );
   }
-  const num = Number(value);
-  if (isFinite(num)) {
-    return num;
-  }
-  throw new TypeError(
-    'Float cannot represent non numeric value: ' + inspect(value),
-  );
+  return value;
 }
 
 export const GraphQLFloat = new GraphQLScalarType({
@@ -90,7 +108,7 @@ export const GraphQLFloat = new GraphQLScalarType({
     'The `Float` scalar type represents signed double-precision fractional ' +
     'values as specified by ' +
     '[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). ',
-  serialize: coerceFloat,
+  serialize: serializeFloat,
   parseValue: coerceFloat,
   parseLiteral(ast) {
     return ast.kind === Kind.FLOAT || ast.kind === Kind.INT
@@ -99,13 +117,33 @@ export const GraphQLFloat = new GraphQLScalarType({
   },
 });
 
+function serializeString(value: mixed): string {
+  // Support serializing objects with custom valueOf() functions - a common way
+  // to represent an complex value which can be represented as a string
+  // (ex: MongoDB id objects).
+  const result =
+    value && typeof value.valueOf === 'function' ? value.valueOf() : value;
+  // Serialize string, boolean and number values to a string, but do not
+  // attempt to coerce object, function, symbol, or other types as strings.
+  if (typeof result === 'string') {
+    return result;
+  }
+  if (typeof result === 'boolean') {
+    return result ? 'true' : 'false';
+  }
+  if (isFinite(result)) {
+    return result.toString();
+  }
+  throw new TypeError(`String cannot represent value: ${inspect(value)}`);
+}
+
 function coerceString(value: mixed): string {
-  if (Array.isArray(value)) {
+  if (typeof value !== 'string') {
     throw new TypeError(
-      `String cannot represent an array value: ${inspect(value)}`,
+      `String cannot represent a non string value: ${inspect(value)}`,
     );
   }
-  return String(value);
+  return value;
 }
 
 export const GraphQLString = new GraphQLScalarType({
@@ -114,32 +152,68 @@ export const GraphQLString = new GraphQLScalarType({
     'The `String` scalar type represents textual data, represented as UTF-8 ' +
     'character sequences. The String type is most often used by GraphQL to ' +
     'represent free-form human-readable text.',
-  serialize: coerceString,
+  serialize: serializeString,
   parseValue: coerceString,
   parseLiteral(ast) {
     return ast.kind === Kind.STRING ? ast.value : undefined;
   },
 });
 
+function serializeBoolean(value: mixed): boolean {
+  if (typeof value === 'boolean') {
+    return value;
+  }
+  if (isFinite(value)) {
+    return value !== 0;
+  }
+  throw new TypeError(
+    `Boolean cannot represent a non boolean value: ${inspect(value)}`,
+  );
+}
+
 function coerceBoolean(value: mixed): boolean {
-  if (Array.isArray(value)) {
+  if (typeof value !== 'boolean') {
     throw new TypeError(
-      `Boolean cannot represent an array value: [${String(value)}]`,
+      `Boolean cannot represent a non boolean value: ${inspect(value)}`,
     );
   }
-  return Boolean(value);
+  return value;
 }
 
 export const GraphQLBoolean = new GraphQLScalarType({
   name: 'Boolean',
   description: 'The `Boolean` scalar type represents `true` or `false`.',
-  serialize: coerceBoolean,
+  serialize: serializeBoolean,
   parseValue: coerceBoolean,
   parseLiteral(ast) {
     return ast.kind === Kind.BOOLEAN ? ast.value : undefined;
   },
 });
 
+function serializeID(value: mixed): string {
+  // Support serializing objects with custom valueOf() functions - a common way
+  // to represent an object identifier (ex. MongoDB).
+  const result =
+    value && typeof value.valueOf === 'function' ? value.valueOf() : value;
+  if (typeof result === 'string') {
+    return result;
+  }
+  if (isInteger(result)) {
+    return String(result);
+  }
+  throw new TypeError(`ID cannot represent value: ${inspect(value)}`);
+}
+
+function coerceID(value: mixed): string {
+  if (typeof value === 'string') {
+    return value;
+  }
+  if (isInteger(value)) {
+    return value.toString();
+  }
+  throw new TypeError(`ID cannot represent value: ${inspect(value)}`);
+}
+
 export const GraphQLID = new GraphQLScalarType({
   name: 'ID',
   description:
@@ -148,8 +222,8 @@ export const GraphQLID = new GraphQLScalarType({
     'response as a String; however, it is not intended to be human-readable. ' +
     'When expected as an input type, any string (such as `"4"`) or integer ' +
     '(such as `4`) input value will be accepted as an ID.',
-  serialize: coerceString,
-  parseValue: coerceString,
+  serialize: serializeID,
+  parseValue: coerceID,
   parseLiteral(ast) {
     return ast.kind === Kind.STRING || ast.kind === Kind.INT
       ? ast.value
diff --git a/type/scalars.mjs b/type/scalars.mjs
index dce1890..3eec312 100644
--- a/type/scalars.mjs
+++ b/type/scalars.mjs
@@ -7,6 +7,7 @@
  *  strict
  */
 import inspect from '../jsutils/inspect';
+import isFinite from '../jsutils/isFinite';
 import isInteger from '../jsutils/isInteger';
 import { GraphQLScalarType, isNamedType } from './definition';
 import { Kind } from '../language/kinds'; // As per the GraphQL Spec, Integers are only treated as valid when a valid
@@ -18,32 +19,44 @@ import { Kind } from '../language/kinds'; // As per the GraphQL Spec, Integers a
 var MAX_INT = 2147483647;
 var MIN_INT = -2147483648;
 
-function coerceInt(value) {
-  if (Array.isArray(value)) {
-    throw new TypeError("Int cannot represent an array value: [".concat(String(value), "]"));
+function serializeInt(value) {
+  if (typeof value === 'boolean') {
+    return value ? 1 : 0;
   }
 
-  if (value === '') {
-    throw new TypeError('Int cannot represent non-integer value: (empty string)');
-  }
+  var num = value;
 
-  var num = Number(value);
+  if (typeof value === 'string' && value !== '') {
+    num = Number(value);
+  }
 
   if (!isInteger(num)) {
-    throw new TypeError('Int cannot represent non-integer value: ' + inspect(value));
+    throw new TypeError("Int cannot represent non-integer value: ".concat(inspect(value)));
   }
 
   if (num > MAX_INT || num < MIN_INT) {
-    throw new TypeError('Int cannot represent non 32-bit signed integer value: ' + inspect(value));
+    throw new TypeError("Int cannot represent non 32-bit signed integer value: ".concat(inspect(value)));
   }
 
   return num;
 }
 
+function coerceInt(value) {
+  if (!isInteger(value)) {
+    throw new TypeError("Int cannot represent non-integer value: ".concat(inspect(value)));
+  }
+
+  if (value > MAX_INT || value < MIN_INT) {
+    throw new TypeError("Int cannot represent non 32-bit signed integer value: ".concat(inspect(value)));
+  }
+
+  return value;
+}
+
 export var GraphQLInt = new GraphQLScalarType({
   name: 'Int',
   description: 'The `Int` scalar type represents non-fractional signed whole numeric ' + 'values. Int can represent values between -(2^31) and 2^31 - 1. ',
-  serialize: coerceInt,
+  serialize: serializeInt,
   parseValue: coerceInt,
   parseLiteral: function parseLiteral(ast) {
     if (ast.kind === Kind.INT) {
@@ -58,74 +71,145 @@ export var GraphQLInt = new GraphQLScalarType({
   }
 });
 
-function coerceFloat(value) {
-  if (Array.isArray(value)) {
-    throw new TypeError("Float cannot represent an array value: [".concat(String(value), "]"));
+function serializeFloat(value) {
+  if (typeof value === 'boolean') {
+    return value ? 1 : 0;
+  }
+
+  var num = value;
+
+  if (typeof value === 'string' && value !== '') {
+    num = Number(value);
   }
 
-  if (value === '') {
-    throw new TypeError('Float cannot represent non numeric value: (empty string)');
+  if (!isFinite(num)) {
+    throw new TypeError("Float cannot represent non numeric value: ".concat(inspect(value)));
   }
 
-  var num = Number(value);
+  return num;
+}
 
-  if (isFinite(num)) {
-    return num;
+function coerceFloat(value) {
+  if (!isFinite(value)) {
+    throw new TypeError("Float cannot represent non numeric value: ".concat(inspect(value)));
   }
 
-  throw new TypeError('Float cannot represent non numeric value: ' + inspect(value));
+  return value;
 }
 
 export var GraphQLFloat = new GraphQLScalarType({
   name: 'Float',
   description: 'The `Float` scalar type represents signed double-precision fractional ' + 'values as specified by ' + '[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). ',
-  serialize: coerceFloat,
+  serialize: serializeFloat,
   parseValue: coerceFloat,
   parseLiteral: function parseLiteral(ast) {
     return ast.kind === Kind.FLOAT || ast.kind === Kind.INT ? parseFloat(ast.value) : undefined;
   }
 });
 
+function serializeString(value) {
+  // Support serializing objects with custom valueOf() functions - a common way
+  // to represent an complex value which can be represented as a string
+  // (ex: MongoDB id objects).
+  var result = value && typeof value.valueOf === 'function' ? value.valueOf() : value; // Serialize string, boolean and number values to a string, but do not
+  // attempt to coerce object, function, symbol, or other types as strings.
+
+  if (typeof result === 'string') {
+    return result;
+  }
+
+  if (typeof result === 'boolean') {
+    return result ? 'true' : 'false';
+  }
+
+  if (isFinite(result)) {
+    return result.toString();
+  }
+
+  throw new TypeError("String cannot represent value: ".concat(inspect(value)));
+}
+
 function coerceString(value) {
-  if (Array.isArray(value)) {
-    throw new TypeError("String cannot represent an array value: ".concat(inspect(value)));
+  if (typeof value !== 'string') {
+    throw new TypeError("String cannot represent a non string value: ".concat(inspect(value)));
   }
 
-  return String(value);
+  return value;
 }
 
 export var GraphQLString = new GraphQLScalarType({
   name: 'String',
   description: 'The `String` scalar type represents textual data, represented as UTF-8 ' + 'character sequences. The String type is most often used by GraphQL to ' + 'represent free-form human-readable text.',
-  serialize: coerceString,
+  serialize: serializeString,
   parseValue: coerceString,
   parseLiteral: function parseLiteral(ast) {
     return ast.kind === Kind.STRING ? ast.value : undefined;
   }
 });
 
+function serializeBoolean(value) {
+  if (typeof value === 'boolean') {
+    return value;
+  }
+
+  if (isFinite(value)) {
+    return value !== 0;
+  }
+
+  throw new TypeError("Boolean cannot represent a non boolean value: ".concat(inspect(value)));
+}
+
 function coerceBoolean(value) {
-  if (Array.isArray(value)) {
-    throw new TypeError("Boolean cannot represent an array value: [".concat(String(value), "]"));
+  if (typeof value !== 'boolean') {
+    throw new TypeError("Boolean cannot represent a non boolean value: ".concat(inspect(value)));
   }
 
-  return Boolean(value);
+  return value;
 }
 
 export var GraphQLBoolean = new GraphQLScalarType({
   name: 'Boolean',
   description: 'The `Boolean` scalar type represents `true` or `false`.',
-  serialize: coerceBoolean,
+  serialize: serializeBoolean,
   parseValue: coerceBoolean,
   parseLiteral: function parseLiteral(ast) {
     return ast.kind === Kind.BOOLEAN ? ast.value : undefined;
   }
 });
+
+function serializeID(value) {
+  // Support serializing objects with custom valueOf() functions - a common way
+  // to represent an object identifier (ex. MongoDB).
+  var result = value && typeof value.valueOf === 'function' ? value.valueOf() : value;
+
+  if (typeof result === 'string') {
+    return result;
+  }
+
+  if (isInteger(result)) {
+    return String(result);
+  }
+
+  throw new TypeError("ID cannot represent value: ".concat(inspect(value)));
+}
+
+function coerceID(value) {
+  if (typeof value === 'string') {
+    return value;
+  }
+
+  if (isInteger(value)) {
+    return value.toString();
+  }
+
+  throw new TypeError("ID cannot represent value: ".concat(inspect(value)));
+}
+
 export var GraphQLID = new GraphQLScalarType({
   name: 'ID',
   description: 'The `ID` scalar type represents a unique identifier, often used to ' + 'refetch an object or as key for a cache. The ID type appears in a JSON ' + 'response as a String; however, it is not intended to be human-readable. ' + 'When expected as an input type, any string (such as `"4"`) or integer ' + '(such as `4`) input value will be accepted as an ID.',
-  serialize: coerceString,
-  parseValue: coerceString,
+  serialize: serializeID,
+  parseValue: coerceID,
   parseLiteral: function parseLiteral(ast) {
     return ast.kind === Kind.STRING || ast.kind === Kind.INT ? ast.value : undefined;
   }
diff --git a/type/schema.js b/type/schema.js
index c58d1cb..3b7d32f 100644
--- a/type/schema.js
+++ b/type/schema.js
@@ -14,7 +14,7 @@ var _inspect = _interopRequireDefault(require("../jsutils/inspect"));
 
 var _introspection = require("./introspection");
 
-var _applyToStringTag = _interopRequireDefault(require("../jsutils/applyToStringTag"));
+var _defineToStringTag = _interopRequireDefault(require("../jsutils/defineToStringTag"));
 
 var _find = _interopRequireDefault(require("../jsutils/find"));
 
@@ -68,8 +68,6 @@ function () {
   // Used as a cache for validateSchema().
   // Referenced by validateSchema().
   function GraphQLSchema(config) {
-    var _this = this;
-
     _defineProperty(this, "astNode", void 0);
 
     _defineProperty(this, "extensionASTNodes", void 0);
@@ -131,25 +129,50 @@ function () {
     this._typeMap = typeMap; // Keep track of all implementations by interface name.
 
     this._implementations = Object.create(null);
-    Object.keys(this._typeMap).forEach(function (typeName) {
-      var type = _this._typeMap[typeName];
+
+    var _arr = Object.keys(this._typeMap);
+
+    for (var _i = 0; _i < _arr.length; _i++) {
+      var typeName = _arr[_i];
+      var type = this._typeMap[typeName];
 
       if ((0, _definition.isObjectType)(type)) {
-        type.getInterfaces().forEach(function (iface) {
-          if ((0, _definition.isInterfaceType)(iface)) {
-            var impls = _this._implementations[iface.name];
-
-            if (impls) {
-              impls.push(type);
-            } else {
-              _this._implementations[iface.name] = [type];
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
+
+        try {
+          for (var _iterator = type.getInterfaces()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var iface = _step.value;
+
+            if ((0, _definition.isInterfaceType)(iface)) {
+              var impls = this._implementations[iface.name];
+
+              if (impls) {
+                impls.push(type);
+              } else {
+                this._implementations[iface.name] = [type];
+              }
+            }
+          }
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
             }
           }
-        });
-      } else if ((0, _definition.isAbstractType)(type) && !_this._implementations[type.name]) {
-        _this._implementations[type.name] = [];
+        }
+      } else if ((0, _definition.isAbstractType)(type) && !this._implementations[type.name]) {
+        this._implementations[type.name] = [];
       }
-    });
+    }
   }
 
   var _proto = GraphQLSchema.prototype;
@@ -214,7 +237,7 @@ function () {
 
 
 exports.GraphQLSchema = GraphQLSchema;
-(0, _applyToStringTag.default)(GraphQLSchema);
+(0, _defineToStringTag.default)(GraphQLSchema);
 
 function typeMapReducer(map, type) {
   if (!type) {
@@ -242,22 +265,63 @@ function typeMapReducer(map, type) {
   }
 
   if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
-    (0, _objectValues.default)(type.getFields()).forEach(function (field) {
-      if (field.args) {
-        var fieldArgTypes = field.args.map(function (arg) {
-          return arg.type;
-        });
-        reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);
+    var _iteratorNormalCompletion2 = true;
+    var _didIteratorError2 = false;
+    var _iteratorError2 = undefined;
+
+    try {
+      for (var _iterator2 = (0, _objectValues.default)(type.getFields())[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+        var field = _step2.value;
+
+        if (field.args) {
+          var fieldArgTypes = field.args.map(function (arg) {
+            return arg.type;
+          });
+          reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);
+        }
+
+        reducedMap = typeMapReducer(reducedMap, field.type);
       }
-
-      reducedMap = typeMapReducer(reducedMap, field.type);
-    });
+    } catch (err) {
+      _didIteratorError2 = true;
+      _iteratorError2 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+          _iterator2.return();
+        }
+      } finally {
+        if (_didIteratorError2) {
+          throw _iteratorError2;
+        }
+      }
+    }
   }
 
   if ((0, _definition.isInputObjectType)(type)) {
-    (0, _objectValues.default)(type.getFields()).forEach(function (field) {
-      reducedMap = typeMapReducer(reducedMap, field.type);
-    });
+    var _iteratorNormalCompletion3 = true;
+    var _didIteratorError3 = false;
+    var _iteratorError3 = undefined;
+
+    try {
+      for (var _iterator3 = (0, _objectValues.default)(type.getFields())[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
+        var _field = _step3.value;
+        reducedMap = typeMapReducer(reducedMap, _field.type);
+      }
+    } catch (err) {
+      _didIteratorError3 = true;
+      _iteratorError3 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
+          _iterator3.return();
+        }
+      } finally {
+        if (_didIteratorError3) {
+          throw _iteratorError3;
+        }
+      }
+    }
   }
 
   return reducedMap;
diff --git a/type/schema.js.flow b/type/schema.js.flow
index 0df086d..ad95d34 100644
--- a/type/schema.js.flow
+++ b/type/schema.js.flow
@@ -33,7 +33,7 @@ import {
 import type { GraphQLError } from '../error/GraphQLError';
 import inspect from '../jsutils/inspect';
 import { __Schema } from './introspection';
-import applyToStringTag from '../jsutils/applyToStringTag';
+import defineToStringTag from '../jsutils/defineToStringTag';
 import find from '../jsutils/find';
 import instanceOf from '../jsutils/instanceOf';
 import invariant from '../jsutils/invariant';
@@ -155,10 +155,10 @@ export class GraphQLSchema {
 
     // Keep track of all implementations by interface name.
     this._implementations = Object.create(null);
-    Object.keys(this._typeMap).forEach(typeName => {
+    for (const typeName of Object.keys(this._typeMap)) {
       const type = this._typeMap[typeName];
       if (isObjectType(type)) {
-        type.getInterfaces().forEach(iface => {
+        for (const iface of type.getInterfaces()) {
           if (isInterfaceType(iface)) {
             const impls = this._implementations[iface.name];
             if (impls) {
@@ -167,11 +167,11 @@ export class GraphQLSchema {
               this._implementations[iface.name] = [type];
             }
           }
-        });
+        }
       } else if (isAbstractType(type) && !this._implementations[type.name]) {
         this._implementations[type.name] = [];
       }
-    });
+    }
   }
 
   getQueryType(): ?GraphQLObjectType {
@@ -233,7 +233,7 @@ export class GraphQLSchema {
 }
 
 // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
-applyToStringTag(GraphQLSchema);
+defineToStringTag(GraphQLSchema);
 
 type TypeMap = ObjMap<GraphQLNamedType>;
 
@@ -252,13 +252,12 @@ export type GraphQLSchemaValidationOptions = {|
    * in this list valid, even if they do not adhere to the specification's
    * schema validation rules.
    *
-   * This option is provided to ease adoption and may be removed in a future
-   * major release.
+   * This option is provided to ease adoption and will be removed in v15.
    */
   allowedLegacyNames?: ?$ReadOnlyArray<string>,
 |};
 
-export type GraphQLSchemaConfig = {
+export type GraphQLSchemaConfig = {|
   query?: ?GraphQLObjectType,
   mutation?: ?GraphQLObjectType,
   subscription?: ?GraphQLObjectType,
@@ -267,7 +266,7 @@ export type GraphQLSchemaConfig = {
   astNode?: ?SchemaDefinitionNode,
   extensionASTNodes?: ?$ReadOnlyArray<SchemaExtensionNode>,
   ...GraphQLSchemaValidationOptions,
-};
+|};
 
 function typeMapReducer(map: TypeMap, type: ?GraphQLType): TypeMap {
   if (!type) {
@@ -297,19 +296,19 @@ function typeMapReducer(map: TypeMap, type: ?GraphQLType): TypeMap {
   }
 
   if (isObjectType(type) || isInterfaceType(type)) {
-    objectValues(type.getFields()).forEach(field => {
+    for (const field of objectValues(type.getFields())) {
       if (field.args) {
         const fieldArgTypes = field.args.map(arg => arg.type);
         reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);
       }
       reducedMap = typeMapReducer(reducedMap, field.type);
-    });
+    }
   }
 
   if (isInputObjectType(type)) {
-    objectValues(type.getFields()).forEach(field => {
+    for (const field of objectValues(type.getFields())) {
       reducedMap = typeMapReducer(reducedMap, field.type);
-    });
+    }
   }
 
   return reducedMap;
diff --git a/type/schema.mjs b/type/schema.mjs
index 13e7c51..5e3ef73 100644
--- a/type/schema.mjs
+++ b/type/schema.mjs
@@ -14,7 +14,7 @@ import { isAbstractType, isObjectType, isInterfaceType, isUnionType, isInputObje
 import { GraphQLDirective, isDirective, specifiedDirectives } from './directives';
 import inspect from '../jsutils/inspect';
 import { __Schema } from './introspection';
-import applyToStringTag from '../jsutils/applyToStringTag';
+import defineToStringTag from '../jsutils/defineToStringTag';
 import find from '../jsutils/find';
 import instanceOf from '../jsutils/instanceOf';
 import invariant from '../jsutils/invariant';
@@ -56,8 +56,6 @@ function () {
   // Used as a cache for validateSchema().
   // Referenced by validateSchema().
   function GraphQLSchema(config) {
-    var _this = this;
-
     _defineProperty(this, "astNode", void 0);
 
     _defineProperty(this, "extensionASTNodes", void 0);
@@ -119,25 +117,50 @@ function () {
     this._typeMap = typeMap; // Keep track of all implementations by interface name.
 
     this._implementations = Object.create(null);
-    Object.keys(this._typeMap).forEach(function (typeName) {
-      var type = _this._typeMap[typeName];
+
+    var _arr = Object.keys(this._typeMap);
+
+    for (var _i = 0; _i < _arr.length; _i++) {
+      var typeName = _arr[_i];
+      var type = this._typeMap[typeName];
 
       if (isObjectType(type)) {
-        type.getInterfaces().forEach(function (iface) {
-          if (isInterfaceType(iface)) {
-            var impls = _this._implementations[iface.name];
-
-            if (impls) {
-              impls.push(type);
-            } else {
-              _this._implementations[iface.name] = [type];
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
+
+        try {
+          for (var _iterator = type.getInterfaces()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var iface = _step.value;
+
+            if (isInterfaceType(iface)) {
+              var impls = this._implementations[iface.name];
+
+              if (impls) {
+                impls.push(type);
+              } else {
+                this._implementations[iface.name] = [type];
+              }
+            }
+          }
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
             }
           }
-        });
-      } else if (isAbstractType(type) && !_this._implementations[type.name]) {
-        _this._implementations[type.name] = [];
+        }
+      } else if (isAbstractType(type) && !this._implementations[type.name]) {
+        this._implementations[type.name] = [];
       }
-    });
+    }
   }
 
   var _proto = GraphQLSchema.prototype;
@@ -200,7 +223,7 @@ function () {
   return GraphQLSchema;
 }(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported
 
-applyToStringTag(GraphQLSchema);
+defineToStringTag(GraphQLSchema);
 
 function typeMapReducer(map, type) {
   if (!type) {
@@ -228,22 +251,63 @@ function typeMapReducer(map, type) {
   }
 
   if (isObjectType(type) || isInterfaceType(type)) {
-    objectValues(type.getFields()).forEach(function (field) {
-      if (field.args) {
-        var fieldArgTypes = field.args.map(function (arg) {
-          return arg.type;
-        });
-        reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);
+    var _iteratorNormalCompletion2 = true;
+    var _didIteratorError2 = false;
+    var _iteratorError2 = undefined;
+
+    try {
+      for (var _iterator2 = objectValues(type.getFields())[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+        var field = _step2.value;
+
+        if (field.args) {
+          var fieldArgTypes = field.args.map(function (arg) {
+            return arg.type;
+          });
+          reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);
+        }
+
+        reducedMap = typeMapReducer(reducedMap, field.type);
       }
-
-      reducedMap = typeMapReducer(reducedMap, field.type);
-    });
+    } catch (err) {
+      _didIteratorError2 = true;
+      _iteratorError2 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+          _iterator2.return();
+        }
+      } finally {
+        if (_didIteratorError2) {
+          throw _iteratorError2;
+        }
+      }
+    }
   }
 
   if (isInputObjectType(type)) {
-    objectValues(type.getFields()).forEach(function (field) {
-      reducedMap = typeMapReducer(reducedMap, field.type);
-    });
+    var _iteratorNormalCompletion3 = true;
+    var _didIteratorError3 = false;
+    var _iteratorError3 = undefined;
+
+    try {
+      for (var _iterator3 = objectValues(type.getFields())[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
+        var _field = _step3.value;
+        reducedMap = typeMapReducer(reducedMap, _field.type);
+      }
+    } catch (err) {
+      _didIteratorError3 = true;
+      _iteratorError3 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
+          _iterator3.return();
+        }
+      } finally {
+        if (_didIteratorError3) {
+          throw _iteratorError3;
+        }
+      }
+    }
   }
 
   return reducedMap;
diff --git a/type/validate.js b/type/validate.js
index 4f00478..1a3ffbd 100644
--- a/type/validate.js
+++ b/type/validate.js
@@ -129,41 +129,19 @@ function validateRootTypes(context) {
 }
 
 function getOperationTypeNode(schema, type, operation) {
+  var operationNodes = getAllSubNodes(schema, function (node) {
+    return node.operationTypes;
+  });
   var _iteratorNormalCompletion = true;
   var _didIteratorError = false;
   var _iteratorError = undefined;
 
   try {
-    for (var _iterator = getAllNodes(schema)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+    for (var _iterator = operationNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
       var node = _step.value;
 
-      if (node.operationTypes) {
-        var _iteratorNormalCompletion2 = true;
-        var _didIteratorError2 = false;
-        var _iteratorError2 = undefined;
-
-        try {
-          for (var _iterator2 = node.operationTypes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
-            var operationType = _step2.value;
-
-            if (operationType.operation === operation) {
-              return operationType.type;
-            }
-          }
-        } catch (err) {
-          _didIteratorError2 = true;
-          _iteratorError2 = err;
-        } finally {
-          try {
-            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
-              _iterator2.return();
-            }
-          } finally {
-            if (_didIteratorError2) {
-              throw _iteratorError2;
-            }
-          }
-        }
+      if (node.operation === operation) {
+        return node.type;
       }
     }
   } catch (err) {
@@ -185,36 +163,76 @@ function getOperationTypeNode(schema, type, operation) {
 }
 
 function validateDirectives(context) {
-  var directives = context.schema.getDirectives();
-  directives.forEach(function (directive) {
-    // Ensure all directives are in fact GraphQL directives.
-    if (!(0, _directives.isDirective)(directive)) {
-      context.reportError("Expected directive but got: ".concat((0, _inspect.default)(directive), "."), directive && directive.astNode);
-      return;
-    } // Ensure they are named correctly.
+  var _iteratorNormalCompletion2 = true;
+  var _didIteratorError2 = false;
+  var _iteratorError2 = undefined;
+
+  try {
+    for (var _iterator2 = context.schema.getDirectives()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+      var directive = _step2.value;
 
+      // Ensure all directives are in fact GraphQL directives.
+      if (!(0, _directives.isDirective)(directive)) {
+        context.reportError("Expected directive but got: ".concat((0, _inspect.default)(directive), "."), directive && directive.astNode);
+        continue;
+      } // Ensure they are named correctly.
 
-    validateName(context, directive); // TODO: Ensure proper locations.
-    // Ensure the arguments are valid.
 
-    var argNames = Object.create(null);
-    directive.args.forEach(function (arg) {
-      var argName = arg.name; // Ensure they are named correctly.
+      validateName(context, directive); // TODO: Ensure proper locations.
+      // Ensure the arguments are valid.
 
-      validateName(context, arg); // Ensure they are unique per directive.
+      var argNames = Object.create(null);
+      var _iteratorNormalCompletion3 = true;
+      var _didIteratorError3 = false;
+      var _iteratorError3 = undefined;
 
-      if (argNames[argName]) {
-        context.reportError("Argument @".concat(directive.name, "(").concat(argName, ":) can only be defined once."), getAllDirectiveArgNodes(directive, argName));
-        return; // continue loop
-      }
+      try {
+        for (var _iterator3 = directive.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
+          var arg = _step3.value;
+          var argName = arg.name; // Ensure they are named correctly.
+
+          validateName(context, arg); // Ensure they are unique per directive.
 
-      argNames[argName] = true; // Ensure the type is an input type.
+          if (argNames[argName]) {
+            context.reportError("Argument @".concat(directive.name, "(").concat(argName, ":) can only be defined once."), getAllDirectiveArgNodes(directive, argName));
+            continue;
+          }
+
+          argNames[argName] = true; // Ensure the type is an input type.
 
-      if (!(0, _definition.isInputType)(arg.type)) {
-        context.reportError("The type of @".concat(directive.name, "(").concat(argName, ":) must be Input Type ") + "but got: ".concat((0, _inspect.default)(arg.type), "."), getDirectiveArgTypeNode(directive, argName));
+          if (!(0, _definition.isInputType)(arg.type)) {
+            context.reportError("The type of @".concat(directive.name, "(").concat(argName, ":) must be Input Type ") + "but got: ".concat((0, _inspect.default)(arg.type), "."), getDirectiveArgTypeNode(directive, argName));
+          }
+        }
+      } catch (err) {
+        _didIteratorError3 = true;
+        _iteratorError3 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
+            _iterator3.return();
+          }
+        } finally {
+          if (_didIteratorError3) {
+            throw _iteratorError3;
+          }
+        }
       }
-    });
-  });
+    }
+  } catch (err) {
+    _didIteratorError2 = true;
+    _iteratorError2 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+        _iterator2.return();
+      }
+    } finally {
+      if (_didIteratorError2) {
+        throw _iteratorError2;
+      }
+    }
+  }
 }
 
 function validateName(context, node) {
@@ -234,37 +252,58 @@ function validateName(context, node) {
 
 function validateTypes(context) {
   var typeMap = context.schema.getTypeMap();
-  (0, _objectValues.default)(typeMap).forEach(function (type) {
-    // Ensure all provided types are in fact GraphQL type.
-    if (!(0, _definition.isNamedType)(type)) {
-      context.reportError("Expected GraphQL named type but got: ".concat((0, _inspect.default)(type), "."), type && type.astNode);
-      return;
-    } // Ensure it is named correctly (excluding introspection types).
+  var _iteratorNormalCompletion4 = true;
+  var _didIteratorError4 = false;
+  var _iteratorError4 = undefined;
 
+  try {
+    for (var _iterator4 = (0, _objectValues.default)(typeMap)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
+      var type = _step4.value;
 
-    if (!(0, _introspection.isIntrospectionType)(type)) {
-      validateName(context, type);
-    }
+      // Ensure all provided types are in fact GraphQL type.
+      if (!(0, _definition.isNamedType)(type)) {
+        context.reportError("Expected GraphQL named type but got: ".concat((0, _inspect.default)(type), "."), type && type.astNode);
+        continue;
+      } // Ensure it is named correctly (excluding introspection types).
+
+
+      if (!(0, _introspection.isIntrospectionType)(type)) {
+        validateName(context, type);
+      }
 
-    if ((0, _definition.isObjectType)(type)) {
-      // Ensure fields are valid
-      validateFields(context, type); // Ensure objects implement the interfaces they claim to.
-
-      validateObjectInterfaces(context, type);
-    } else if ((0, _definition.isInterfaceType)(type)) {
-      // Ensure fields are valid.
-      validateFields(context, type);
-    } else if ((0, _definition.isUnionType)(type)) {
-      // Ensure Unions include valid member types.
-      validateUnionMembers(context, type);
-    } else if ((0, _definition.isEnumType)(type)) {
-      // Ensure Enums have valid values.
-      validateEnumValues(context, type);
-    } else if ((0, _definition.isInputObjectType)(type)) {
-      // Ensure Input Object fields are valid.
-      validateInputFields(context, type);
+      if ((0, _definition.isObjectType)(type)) {
+        // Ensure fields are valid
+        validateFields(context, type); // Ensure objects implement the interfaces they claim to.
+
+        validateObjectInterfaces(context, type);
+      } else if ((0, _definition.isInterfaceType)(type)) {
+        // Ensure fields are valid.
+        validateFields(context, type);
+      } else if ((0, _definition.isUnionType)(type)) {
+        // Ensure Unions include valid member types.
+        validateUnionMembers(context, type);
+      } else if ((0, _definition.isEnumType)(type)) {
+        // Ensure Enums have valid values.
+        validateEnumValues(context, type);
+      } else if ((0, _definition.isInputObjectType)(type)) {
+        // Ensure Input Object fields are valid.
+        validateInputFields(context, type);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError4 = true;
+    _iteratorError4 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
+        _iterator4.return();
+      }
+    } finally {
+      if (_didIteratorError4) {
+        throw _iteratorError4;
+      }
+    }
+  }
 }
 
 function validateFields(context, type) {
@@ -274,72 +313,135 @@ function validateFields(context, type) {
     context.reportError("Type ".concat(type.name, " must define one or more fields."), getAllNodes(type));
   }
 
-  fields.forEach(function (field) {
-    // Ensure they are named correctly.
-    validateName(context, field); // Ensure they were defined at most once.
+  var _iteratorNormalCompletion5 = true;
+  var _didIteratorError5 = false;
+  var _iteratorError5 = undefined;
+
+  try {
+    for (var _iterator5 = fields[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
+      var field = _step5.value;
+      // Ensure they are named correctly.
+      validateName(context, field); // Ensure they were defined at most once.
 
-    var fieldNodes = getAllFieldNodes(type, field.name);
+      var fieldNodes = getAllFieldNodes(type, field.name);
 
-    if (fieldNodes.length > 1) {
-      context.reportError("Field ".concat(type.name, ".").concat(field.name, " can only be defined once."), fieldNodes);
-      return; // continue loop
-    } // Ensure the type is an output type
+      if (fieldNodes.length > 1) {
+        context.reportError("Field ".concat(type.name, ".").concat(field.name, " can only be defined once."), fieldNodes);
+        continue;
+      } // Ensure the type is an output type
 
 
-    if (!(0, _definition.isOutputType)(field.type)) {
-      context.reportError("The type of ".concat(type.name, ".").concat(field.name, " must be Output Type ") + "but got: ".concat((0, _inspect.default)(field.type), "."), getFieldTypeNode(type, field.name));
-    } // Ensure the arguments are valid
+      if (!(0, _definition.isOutputType)(field.type)) {
+        context.reportError("The type of ".concat(type.name, ".").concat(field.name, " must be Output Type ") + "but got: ".concat((0, _inspect.default)(field.type), "."), getFieldTypeNode(type, field.name));
+      } // Ensure the arguments are valid
 
 
-    var argNames = Object.create(null);
-    field.args.forEach(function (arg) {
-      var argName = arg.name; // Ensure they are named correctly.
+      var argNames = Object.create(null);
+      var _iteratorNormalCompletion6 = true;
+      var _didIteratorError6 = false;
+      var _iteratorError6 = undefined;
 
-      validateName(context, arg); // Ensure they are unique per field.
+      try {
+        for (var _iterator6 = field.args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
+          var arg = _step6.value;
+          var argName = arg.name; // Ensure they are named correctly.
 
-      if (argNames[argName]) {
-        context.reportError("Field argument ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) can only ") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));
-      }
+          validateName(context, arg); // Ensure they are unique per field.
+
+          if (argNames[argName]) {
+            context.reportError("Field argument ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) can only ") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));
+          }
 
-      argNames[argName] = true; // Ensure the type is an input type
+          argNames[argName] = true; // Ensure the type is an input type
 
-      if (!(0, _definition.isInputType)(arg.type)) {
-        context.reportError("The type of ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) must be Input ") + "Type but got: ".concat((0, _inspect.default)(arg.type), "."), getFieldArgTypeNode(type, field.name, argName));
+          if (!(0, _definition.isInputType)(arg.type)) {
+            context.reportError("The type of ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) must be Input ") + "Type but got: ".concat((0, _inspect.default)(arg.type), "."), getFieldArgTypeNode(type, field.name, argName));
+          }
+        }
+      } catch (err) {
+        _didIteratorError6 = true;
+        _iteratorError6 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
+            _iterator6.return();
+          }
+        } finally {
+          if (_didIteratorError6) {
+            throw _iteratorError6;
+          }
+        }
       }
-    });
-  });
+    }
+  } catch (err) {
+    _didIteratorError5 = true;
+    _iteratorError5 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
+        _iterator5.return();
+      }
+    } finally {
+      if (_didIteratorError5) {
+        throw _iteratorError5;
+      }
+    }
+  }
 }
 
 function validateObjectInterfaces(context, object) {
   var implementedTypeNames = Object.create(null);
-  object.getInterfaces().forEach(function (iface) {
-    if (!(0, _definition.isInterfaceType)(iface)) {
-      context.reportError("Type ".concat((0, _inspect.default)(object), " must only implement Interface types, ") + "it cannot implement ".concat((0, _inspect.default)(iface), "."), getImplementsInterfaceNode(object, iface));
-      return;
-    }
+  var _iteratorNormalCompletion7 = true;
+  var _didIteratorError7 = false;
+  var _iteratorError7 = undefined;
 
-    if (implementedTypeNames[iface.name]) {
-      context.reportError("Type ".concat(object.name, " can only implement ").concat(iface.name, " once."), getAllImplementsInterfaceNodes(object, iface));
-      return; // continue loop
-    }
+  try {
+    for (var _iterator7 = object.getInterfaces()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
+      var iface = _step7.value;
 
-    implementedTypeNames[iface.name] = true;
-    validateObjectImplementsInterface(context, object, iface);
-  });
+      if (!(0, _definition.isInterfaceType)(iface)) {
+        context.reportError("Type ".concat((0, _inspect.default)(object), " must only implement Interface types, ") + "it cannot implement ".concat((0, _inspect.default)(iface), "."), getImplementsInterfaceNode(object, iface));
+        continue;
+      }
+
+      if (implementedTypeNames[iface.name]) {
+        context.reportError("Type ".concat(object.name, " can only implement ").concat(iface.name, " once."), getAllImplementsInterfaceNodes(object, iface));
+        continue;
+      }
+
+      implementedTypeNames[iface.name] = true;
+      validateObjectImplementsInterface(context, object, iface);
+    }
+  } catch (err) {
+    _didIteratorError7 = true;
+    _iteratorError7 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
+        _iterator7.return();
+      }
+    } finally {
+      if (_didIteratorError7) {
+        throw _iteratorError7;
+      }
+    }
+  }
 }
 
 function validateObjectImplementsInterface(context, object, iface) {
   var objectFieldMap = object.getFields();
   var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.
 
-  Object.keys(ifaceFieldMap).forEach(function (fieldName) {
+  var _arr = Object.keys(ifaceFieldMap);
+
+  for (var _i = 0; _i < _arr.length; _i++) {
+    var fieldName = _arr[_i];
     var objectField = objectFieldMap[fieldName];
     var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.
 
     if (!objectField) {
-      context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expected but ") + "".concat(object.name, " does not provide it."), [getFieldNode(iface, fieldName), object.astNode]); // Continue loop over fields.
-
-      return;
+      context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expected but ") + "".concat(object.name, " does not provide it."), [getFieldNode(iface, fieldName)].concat(getAllNodes(object)));
+      continue;
     } // Assert interface field type is satisfied by object field type, by being
     // a valid subtype. (covariant)
 
@@ -349,104 +451,215 @@ function validateObjectImplementsInterface(context, object, iface) {
     } // Assert each interface field arg is implemented.
 
 
-    ifaceField.args.forEach(function (ifaceArg) {
-      var argName = ifaceArg.name;
-      var objectArg = (0, _find.default)(objectField.args, function (arg) {
-        return arg.name === argName;
-      }); // Assert interface field arg exists on object field.
+    var _iteratorNormalCompletion8 = true;
+    var _didIteratorError8 = false;
+    var _iteratorError8 = undefined;
+
+    try {
+      var _loop = function _loop() {
+        var ifaceArg = _step8.value;
+        var argName = ifaceArg.name;
+        var objectArg = (0, _find.default)(objectField.args, function (arg) {
+          return arg.name === argName;
+        }); // Assert interface field arg exists on object field.
 
-      if (!objectArg) {
-        context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expected but ".concat(object.name, ".").concat(fieldName, " does not provide it."), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]); // Continue loop over arguments.
+        if (!objectArg) {
+          context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expected but ".concat(object.name, ".").concat(fieldName, " does not provide it."), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);
+          return "continue";
+        } // Assert interface field arg type matches object field arg type.
+        // (invariant)
+        // TODO: change to contravariant?
 
-        return;
-      } // Assert interface field arg type matches object field arg type.
-      // (invariant)
-      // TODO: change to contravariant?
 
+        if (!(0, _typeComparators.isEqualType)(ifaceArg.type, objectArg.type)) {
+          context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expects type ".concat((0, _inspect.default)(ifaceArg.type), " but ") + "".concat(object.name, ".").concat(fieldName, "(").concat(argName, ":) is type ") + "".concat((0, _inspect.default)(objectArg.type), "."), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);
+        } // TODO: validate default values?
 
-      if (!(0, _typeComparators.isEqualType)(ifaceArg.type, objectArg.type)) {
-        context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expects type ".concat((0, _inspect.default)(ifaceArg.type), " but ") + "".concat(object.name, ".").concat(fieldName, "(").concat(argName, ":) is type ") + "".concat((0, _inspect.default)(objectArg.type), "."), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);
-      } // TODO: validate default values?
+      };
 
-    }); // Assert additional arguments must not be required.
+      for (var _iterator8 = ifaceField.args[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
+        var _ret = _loop();
 
-    objectField.args.forEach(function (objectArg) {
-      var argName = objectArg.name;
-      var ifaceArg = (0, _find.default)(ifaceField.args, function (arg) {
-        return arg.name === argName;
-      });
+        if (_ret === "continue") continue;
+      } // Assert additional arguments must not be required.
 
-      if (!ifaceArg && (0, _definition.isNonNullType)(objectArg.type)) {
-        context.reportError("Object field argument ".concat(object.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "is of required type ".concat((0, _inspect.default)(objectArg.type), " but is not also ") + "provided by the Interface field ".concat(iface.name, ".").concat(fieldName, "."), [getFieldArgTypeNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);
+    } catch (err) {
+      _didIteratorError8 = true;
+      _iteratorError8 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
+          _iterator8.return();
+        }
+      } finally {
+        if (_didIteratorError8) {
+          throw _iteratorError8;
+        }
       }
-    });
-  });
+    }
+
+    var _iteratorNormalCompletion9 = true;
+    var _didIteratorError9 = false;
+    var _iteratorError9 = undefined;
+
+    try {
+      var _loop2 = function _loop2() {
+        var objectArg = _step9.value;
+        var argName = objectArg.name;
+        var ifaceArg = (0, _find.default)(ifaceField.args, function (arg) {
+          return arg.name === argName;
+        });
+
+        if (!ifaceArg && (0, _definition.isNonNullType)(objectArg.type)) {
+          context.reportError("Object field argument ".concat(object.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "is of required type ".concat((0, _inspect.default)(objectArg.type), " but is not also ") + "provided by the Interface field ".concat(iface.name, ".").concat(fieldName, "."), [getFieldArgTypeNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);
+        }
+      };
+
+      for (var _iterator9 = objectField.args[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
+        _loop2();
+      }
+    } catch (err) {
+      _didIteratorError9 = true;
+      _iteratorError9 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
+          _iterator9.return();
+        }
+      } finally {
+        if (_didIteratorError9) {
+          throw _iteratorError9;
+        }
+      }
+    }
+  }
 }
 
 function validateUnionMembers(context, union) {
   var memberTypes = union.getTypes();
 
   if (memberTypes.length === 0) {
-    context.reportError("Union type ".concat(union.name, " must define one or more member types."), union.astNode);
+    context.reportError("Union type ".concat(union.name, " must define one or more member types."), getAllNodes(union));
   }
 
   var includedTypeNames = Object.create(null);
-  memberTypes.forEach(function (memberType) {
-    if (includedTypeNames[memberType.name]) {
-      context.reportError("Union type ".concat(union.name, " can only include type ") + "".concat(memberType.name, " once."), getUnionMemberTypeNodes(union, memberType.name));
-      return; // continue loop
-    }
+  var _iteratorNormalCompletion10 = true;
+  var _didIteratorError10 = false;
+  var _iteratorError10 = undefined;
+
+  try {
+    for (var _iterator10 = memberTypes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
+      var memberType = _step10.value;
 
-    includedTypeNames[memberType.name] = true;
+      if (includedTypeNames[memberType.name]) {
+        context.reportError("Union type ".concat(union.name, " can only include type ") + "".concat(memberType.name, " once."), getUnionMemberTypeNodes(union, memberType.name));
+        continue;
+      }
+
+      includedTypeNames[memberType.name] = true;
 
-    if (!(0, _definition.isObjectType)(memberType)) {
-      context.reportError("Union type ".concat(union.name, " can only include Object types, ") + "it cannot include ".concat((0, _inspect.default)(memberType), "."), getUnionMemberTypeNodes(union, String(memberType)));
+      if (!(0, _definition.isObjectType)(memberType)) {
+        context.reportError("Union type ".concat(union.name, " can only include Object types, ") + "it cannot include ".concat((0, _inspect.default)(memberType), "."), getUnionMemberTypeNodes(union, String(memberType)));
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError10 = true;
+    _iteratorError10 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
+        _iterator10.return();
+      }
+    } finally {
+      if (_didIteratorError10) {
+        throw _iteratorError10;
+      }
+    }
+  }
 }
 
 function validateEnumValues(context, enumType) {
   var enumValues = enumType.getValues();
 
   if (enumValues.length === 0) {
-    context.reportError("Enum type ".concat(enumType.name, " must define one or more values."), enumType.astNode);
+    context.reportError("Enum type ".concat(enumType.name, " must define one or more values."), getAllNodes(enumType));
   }
 
-  enumValues.forEach(function (enumValue) {
-    var valueName = enumValue.name; // Ensure no duplicates.
+  var _iteratorNormalCompletion11 = true;
+  var _didIteratorError11 = false;
+  var _iteratorError11 = undefined;
 
-    var allNodes = getEnumValueNodes(enumType, valueName);
+  try {
+    for (var _iterator11 = enumValues[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
+      var enumValue = _step11.value;
+      var valueName = enumValue.name; // Ensure no duplicates.
+
+      var allNodes = getEnumValueNodes(enumType, valueName);
 
-    if (allNodes && allNodes.length > 1) {
-      context.reportError("Enum type ".concat(enumType.name, " can include value ").concat(valueName, " only once."), allNodes);
-    } // Ensure valid name.
+      if (allNodes && allNodes.length > 1) {
+        context.reportError("Enum type ".concat(enumType.name, " can include value ").concat(valueName, " only once."), allNodes);
+      } // Ensure valid name.
 
 
-    validateName(context, enumValue);
+      validateName(context, enumValue);
 
-    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {
-      context.reportError("Enum type ".concat(enumType.name, " cannot include value: ").concat(valueName, "."), enumValue.astNode);
+      if (valueName === 'true' || valueName === 'false' || valueName === 'null') {
+        context.reportError("Enum type ".concat(enumType.name, " cannot include value: ").concat(valueName, "."), enumValue.astNode);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError11 = true;
+    _iteratorError11 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
+        _iterator11.return();
+      }
+    } finally {
+      if (_didIteratorError11) {
+        throw _iteratorError11;
+      }
+    }
+  }
 }
 
 function validateInputFields(context, inputObj) {
   var fields = (0, _objectValues.default)(inputObj.getFields());
 
   if (fields.length === 0) {
-    context.reportError("Input Object type ".concat(inputObj.name, " must define one or more fields."), inputObj.astNode);
+    context.reportError("Input Object type ".concat(inputObj.name, " must define one or more fields."), getAllNodes(inputObj));
   } // Ensure the arguments are valid
 
 
-  fields.forEach(function (field) {
-    // Ensure they are named correctly.
-    validateName(context, field); // TODO: Ensure they are unique per field.
-    // Ensure the type is an input type
+  var _iteratorNormalCompletion12 = true;
+  var _didIteratorError12 = false;
+  var _iteratorError12 = undefined;
 
-    if (!(0, _definition.isInputType)(field.type)) {
-      context.reportError("The type of ".concat(inputObj.name, ".").concat(field.name, " must be Input Type ") + "but got: ".concat((0, _inspect.default)(field.type), "."), field.astNode && field.astNode.type);
+  try {
+    for (var _iterator12 = fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
+      var field = _step12.value;
+      // Ensure they are named correctly.
+      validateName(context, field); // TODO: Ensure they are unique per field.
+      // Ensure the type is an input type
+
+      if (!(0, _definition.isInputType)(field.type)) {
+        context.reportError("The type of ".concat(inputObj.name, ".").concat(field.name, " must be Input Type ") + "but got: ".concat((0, _inspect.default)(field.type), "."), field.astNode && field.astNode.type);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError12 = true;
+    _iteratorError12 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
+        _iterator12.return();
+      }
+    } finally {
+      if (_didIteratorError12) {
+        throw _iteratorError12;
+      }
+    }
+  }
 }
 
 function getAllNodes(object) {
@@ -455,27 +668,52 @@ function getAllNodes(object) {
   return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];
 }
 
-function getImplementsInterfaceNode(type, iface) {
-  return getAllImplementsInterfaceNodes(type, iface)[0];
-}
+function getAllSubNodes(object, getter) {
+  var result = [];
+  var _iteratorNormalCompletion13 = true;
+  var _didIteratorError13 = false;
+  var _iteratorError13 = undefined;
 
-function getAllImplementsInterfaceNodes(type, iface) {
-  var implementsNodes = [];
-  var astNodes = getAllNodes(type);
+  try {
+    for (var _iterator13 = getAllNodes(object)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
+      var astNode = _step13.value;
 
-  for (var i = 0; i < astNodes.length; i++) {
-    var _astNode = astNodes[i];
+      if (astNode) {
+        var subNodes = getter(astNode);
 
-    if (_astNode && _astNode.interfaces) {
-      _astNode.interfaces.forEach(function (node) {
-        if (node.name.value === iface.name) {
-          implementsNodes.push(node);
+        if (subNodes) {
+          result = result.concat(subNodes);
         }
-      });
+      }
+    }
+  } catch (err) {
+    _didIteratorError13 = true;
+    _iteratorError13 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
+        _iterator13.return();
+      }
+    } finally {
+      if (_didIteratorError13) {
+        throw _iteratorError13;
+      }
     }
   }
 
-  return implementsNodes;
+  return result;
+}
+
+function getImplementsInterfaceNode(type, iface) {
+  return getAllImplementsInterfaceNodes(type, iface)[0];
+}
+
+function getAllImplementsInterfaceNodes(type, iface) {
+  return getAllSubNodes(type, function (typeNode) {
+    return typeNode.interfaces;
+  }).filter(function (ifaceNode) {
+    return ifaceNode.name.value === iface.name;
+  });
 }
 
 function getFieldNode(type, fieldName) {
@@ -483,22 +721,11 @@ function getFieldNode(type, fieldName) {
 }
 
 function getAllFieldNodes(type, fieldName) {
-  var fieldNodes = [];
-  var astNodes = getAllNodes(type);
-
-  for (var i = 0; i < astNodes.length; i++) {
-    var _astNode2 = astNodes[i];
-
-    if (_astNode2 && _astNode2.fields) {
-      _astNode2.fields.forEach(function (node) {
-        if (node.name.value === fieldName) {
-          fieldNodes.push(node);
-        }
-      });
-    }
-  }
-
-  return fieldNodes;
+  return getAllSubNodes(type, function (typeNode) {
+    return typeNode.fields;
+  }).filter(function (fieldNode) {
+    return fieldNode.name.value === fieldName;
+  });
 }
 
 function getFieldTypeNode(type, fieldName) {
@@ -515,11 +742,32 @@ function getAllFieldArgNodes(type, fieldName, argName) {
   var fieldNode = getFieldNode(type, fieldName);
 
   if (fieldNode && fieldNode.arguments) {
-    fieldNode.arguments.forEach(function (node) {
-      if (node.name.value === argName) {
-        argNodes.push(node);
+    var _iteratorNormalCompletion14 = true;
+    var _didIteratorError14 = false;
+    var _iteratorError14 = undefined;
+
+    try {
+      for (var _iterator14 = fieldNode.arguments[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
+        var node = _step14.value;
+
+        if (node.name.value === argName) {
+          argNodes.push(node);
+        }
       }
-    });
+    } catch (err) {
+      _didIteratorError14 = true;
+      _iteratorError14 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
+          _iterator14.return();
+        }
+      } finally {
+        if (_didIteratorError14) {
+          throw _iteratorError14;
+        }
+      }
+    }
   }
 
   return argNodes;
@@ -531,18 +779,11 @@ function getFieldArgTypeNode(type, fieldName, argName) {
 }
 
 function getAllDirectiveArgNodes(directive, argName) {
-  var argNodes = [];
-  var directiveNode = directive.astNode;
-
-  if (directiveNode && directiveNode.arguments) {
-    directiveNode.arguments.forEach(function (node) {
-      if (node.name.value === argName) {
-        argNodes.push(node);
-      }
-    });
-  }
-
-  return argNodes;
+  return getAllSubNodes(directive, function (directiveNode) {
+    return directiveNode.arguments;
+  }).filter(function (argNode) {
+    return argNode.name.value === argName;
+  });
 }
 
 function getDirectiveArgTypeNode(directive, argName) {
@@ -551,13 +792,17 @@ function getDirectiveArgTypeNode(directive, argName) {
 }
 
 function getUnionMemberTypeNodes(union, typeName) {
-  return union.astNode && union.astNode.types && union.astNode.types.filter(function (type) {
-    return type.name.value === typeName;
+  return getAllSubNodes(union, function (unionNode) {
+    return unionNode.types;
+  }).filter(function (typeNode) {
+    return typeNode.name.value === typeName;
   });
 }
 
 function getEnumValueNodes(enumType, valueName) {
-  return enumType.astNode && enumType.astNode.values && enumType.astNode.values.filter(function (value) {
-    return value.name.value === valueName;
+  return getAllSubNodes(enumType, function (enumNode) {
+    return enumNode.values;
+  }).filter(function (valueNode) {
+    return valueNode.name.value === valueName;
   });
 }
\ No newline at end of file
diff --git a/type/validate.js.flow b/type/validate.js.flow
index b021347..1d8bdb1 100644
--- a/type/validate.js.flow
+++ b/type/validate.js.flow
@@ -155,13 +155,10 @@ function getOperationTypeNode(
   type: GraphQLObjectType,
   operation: string,
 ): ?ASTNode {
-  for (const node of getAllNodes(schema)) {
-    if (node.operationTypes) {
-      for (const operationType of node.operationTypes) {
-        if (operationType.operation === operation) {
-          return operationType.type;
-        }
-      }
+  const operationNodes = getAllSubNodes(schema, node => node.operationTypes);
+  for (const node of operationNodes) {
+    if (node.operation === operation) {
+      return node.type;
     }
   }
 
@@ -169,15 +166,14 @@ function getOperationTypeNode(
 }
 
 function validateDirectives(context: SchemaValidationContext): void {
-  const directives = context.schema.getDirectives();
-  directives.forEach(directive => {
+  for (const directive of context.schema.getDirectives()) {
     // Ensure all directives are in fact GraphQL directives.
     if (!isDirective(directive)) {
       context.reportError(
         `Expected directive but got: ${inspect(directive)}.`,
         directive && directive.astNode,
       );
-      return;
+      continue;
     }
 
     // Ensure they are named correctly.
@@ -187,7 +183,7 @@ function validateDirectives(context: SchemaValidationContext): void {
 
     // Ensure the arguments are valid.
     const argNames = Object.create(null);
-    directive.args.forEach(arg => {
+    for (const arg of directive.args) {
       const argName = arg.name;
 
       // Ensure they are named correctly.
@@ -199,7 +195,7 @@ function validateDirectives(context: SchemaValidationContext): void {
           `Argument @${directive.name}(${argName}:) can only be defined once.`,
           getAllDirectiveArgNodes(directive, argName),
         );
-        return; // continue loop
+        continue;
       }
       argNames[argName] = true;
 
@@ -211,8 +207,8 @@ function validateDirectives(context: SchemaValidationContext): void {
           getDirectiveArgTypeNode(directive, argName),
         );
       }
-    });
-  });
+    }
+  }
 }
 
 function validateName(
@@ -233,14 +229,14 @@ function validateName(
 
 function validateTypes(context: SchemaValidationContext): void {
   const typeMap = context.schema.getTypeMap();
-  objectValues(typeMap).forEach(type => {
+  for (const type of objectValues(typeMap)) {
     // Ensure all provided types are in fact GraphQL type.
     if (!isNamedType(type)) {
       context.reportError(
         `Expected GraphQL named type but got: ${inspect(type)}.`,
         type && type.astNode,
       );
-      return;
+      continue;
     }
 
     // Ensure it is named correctly (excluding introspection types).
@@ -267,7 +263,7 @@ function validateTypes(context: SchemaValidationContext): void {
       // Ensure Input Object fields are valid.
       validateInputFields(context, type);
     }
-  });
+  }
 }
 
 function validateFields(
@@ -284,7 +280,7 @@ function validateFields(
     );
   }
 
-  fields.forEach(field => {
+  for (const field of fields) {
     // Ensure they are named correctly.
     validateName(context, field);
 
@@ -295,7 +291,7 @@ function validateFields(
         `Field ${type.name}.${field.name} can only be defined once.`,
         fieldNodes,
       );
-      return; // continue loop
+      continue;
     }
 
     // Ensure the type is an output type
@@ -309,7 +305,7 @@ function validateFields(
 
     // Ensure the arguments are valid
     const argNames = Object.create(null);
-    field.args.forEach(arg => {
+    for (const arg of field.args) {
       const argName = arg.name;
 
       // Ensure they are named correctly.
@@ -333,8 +329,8 @@ function validateFields(
           getFieldArgTypeNode(type, field.name, argName),
         );
       }
-    });
-  });
+    }
+  }
 }
 
 function validateObjectInterfaces(
@@ -342,14 +338,14 @@ function validateObjectInterfaces(
   object: GraphQLObjectType,
 ): void {
   const implementedTypeNames = Object.create(null);
-  object.getInterfaces().forEach(iface => {
+  for (const iface of object.getInterfaces()) {
     if (!isInterfaceType(iface)) {
       context.reportError(
         `Type ${inspect(object)} must only implement Interface types, ` +
           `it cannot implement ${inspect(iface)}.`,
         getImplementsInterfaceNode(object, iface),
       );
-      return;
+      continue;
     }
 
     if (implementedTypeNames[iface.name]) {
@@ -357,11 +353,11 @@ function validateObjectInterfaces(
         `Type ${object.name} can only implement ${iface.name} once.`,
         getAllImplementsInterfaceNodes(object, iface),
       );
-      return; // continue loop
+      continue;
     }
     implementedTypeNames[iface.name] = true;
     validateObjectImplementsInterface(context, object, iface);
-  });
+  }
 }
 
 function validateObjectImplementsInterface(
@@ -373,7 +369,7 @@ function validateObjectImplementsInterface(
   const ifaceFieldMap = iface.getFields();
 
   // Assert each interface field is implemented.
-  Object.keys(ifaceFieldMap).forEach(fieldName => {
+  for (const fieldName of Object.keys(ifaceFieldMap)) {
     const objectField = objectFieldMap[fieldName];
     const ifaceField = ifaceFieldMap[fieldName];
 
@@ -382,10 +378,9 @@ function validateObjectImplementsInterface(
       context.reportError(
         `Interface field ${iface.name}.${fieldName} expected but ` +
           `${object.name} does not provide it.`,
-        [getFieldNode(iface, fieldName), object.astNode],
+        [getFieldNode(iface, fieldName), ...getAllNodes(object)],
       );
-      // Continue loop over fields.
-      return;
+      continue;
     }
 
     // Assert interface field type is satisfied by object field type, by being
@@ -403,7 +398,7 @@ function validateObjectImplementsInterface(
     }
 
     // Assert each interface field arg is implemented.
-    ifaceField.args.forEach(ifaceArg => {
+    for (const ifaceArg of ifaceField.args) {
       const argName = ifaceArg.name;
       const objectArg = find(objectField.args, arg => arg.name === argName);
 
@@ -417,8 +412,7 @@ function validateObjectImplementsInterface(
             getFieldNode(object, fieldName),
           ],
         );
-        // Continue loop over arguments.
-        return;
+        continue;
       }
 
       // Assert interface field arg type matches object field arg type.
@@ -438,10 +432,10 @@ function validateObjectImplementsInterface(
       }
 
       // TODO: validate default values?
-    });
+    }
 
     // Assert additional arguments must not be required.
-    objectField.args.forEach(objectArg => {
+    for (const objectArg of objectField.args) {
       const argName = objectArg.name;
       const ifaceArg = find(ifaceField.args, arg => arg.name === argName);
       if (!ifaceArg && isNonNullType(objectArg.type)) {
@@ -455,8 +449,8 @@ function validateObjectImplementsInterface(
           ],
         );
       }
-    });
-  });
+    }
+  }
 }
 
 function validateUnionMembers(
@@ -468,19 +462,19 @@ function validateUnionMembers(
   if (memberTypes.length === 0) {
     context.reportError(
       `Union type ${union.name} must define one or more member types.`,
-      union.astNode,
+      getAllNodes(union),
     );
   }
 
   const includedTypeNames = Object.create(null);
-  memberTypes.forEach(memberType => {
+  for (const memberType of memberTypes) {
     if (includedTypeNames[memberType.name]) {
       context.reportError(
         `Union type ${union.name} can only include type ` +
           `${memberType.name} once.`,
         getUnionMemberTypeNodes(union, memberType.name),
       );
-      return; // continue loop
+      continue;
     }
     includedTypeNames[memberType.name] = true;
     if (!isObjectType(memberType)) {
@@ -490,7 +484,7 @@ function validateUnionMembers(
         getUnionMemberTypeNodes(union, String(memberType)),
       );
     }
-  });
+  }
 }
 
 function validateEnumValues(
@@ -502,11 +496,11 @@ function validateEnumValues(
   if (enumValues.length === 0) {
     context.reportError(
       `Enum type ${enumType.name} must define one or more values.`,
-      enumType.astNode,
+      getAllNodes(enumType),
     );
   }
 
-  enumValues.forEach(enumValue => {
+  for (const enumValue of enumValues) {
     const valueName = enumValue.name;
 
     // Ensure no duplicates.
@@ -526,7 +520,7 @@ function validateEnumValues(
         enumValue.astNode,
       );
     }
-  });
+  }
 }
 
 function validateInputFields(
@@ -538,12 +532,12 @@ function validateInputFields(
   if (fields.length === 0) {
     context.reportError(
       `Input Object type ${inputObj.name} must define one or more fields.`,
-      inputObj.astNode,
+      getAllNodes(inputObj),
     );
   }
 
   // Ensure the arguments are valid
-  fields.forEach(field => {
+  for (const field of fields) {
     // Ensure they are named correctly.
     validateName(context, field);
 
@@ -557,13 +551,17 @@ function validateInputFields(
         field.astNode && field.astNode.type,
       );
     }
-  });
+  }
 }
 
-function getAllNodes<T: ASTNode, K: ASTNode>(object: {
+type SDLDefinedObject<T, K> = {
   +astNode: ?T,
   +extensionASTNodes?: ?$ReadOnlyArray<K>,
-}): $ReadOnlyArray<T | K> {
+};
+
+function getAllNodes<T: ASTNode, K: ASTNode>(
+  object: SDLDefinedObject<T, K>,
+): $ReadOnlyArray<T | K> {
   const { astNode, extensionASTNodes } = object;
   return astNode
     ? extensionASTNodes
@@ -572,6 +570,22 @@ function getAllNodes<T: ASTNode, K: ASTNode>(object: {
     : extensionASTNodes || [];
 }
 
+function getAllSubNodes<T: ASTNode, K: ASTNode, L: ASTNode>(
+  object: SDLDefinedObject<T, K>,
+  getter: (T | K) => ?(L | $ReadOnlyArray<L>),
+): $ReadOnlyArray<L> {
+  let result = [];
+  for (const astNode of getAllNodes(object)) {
+    if (astNode) {
+      const subNodes = getter(astNode);
+      if (subNodes) {
+        result = result.concat(subNodes);
+      }
+    }
+  }
+  return result;
+}
+
 function getImplementsInterfaceNode(
   type: GraphQLObjectType,
   iface: GraphQLInterfaceType,
@@ -583,19 +597,9 @@ function getAllImplementsInterfaceNodes(
   type: GraphQLObjectType,
   iface: GraphQLInterfaceType,
 ): $ReadOnlyArray<NamedTypeNode> {
-  const implementsNodes = [];
-  const astNodes = getAllNodes(type);
-  for (let i = 0; i < astNodes.length; i++) {
-    const astNode = astNodes[i];
-    if (astNode && astNode.interfaces) {
-      astNode.interfaces.forEach(node => {
-        if (node.name.value === iface.name) {
-          implementsNodes.push(node);
-        }
-      });
-    }
-  }
-  return implementsNodes;
+  return getAllSubNodes(type, typeNode => typeNode.interfaces).filter(
+    ifaceNode => ifaceNode.name.value === iface.name,
+  );
 }
 
 function getFieldNode(
@@ -609,19 +613,9 @@ function getAllFieldNodes(
   type: GraphQLObjectType | GraphQLInterfaceType,
   fieldName: string,
 ): $ReadOnlyArray<FieldDefinitionNode> {
-  const fieldNodes = [];
-  const astNodes = getAllNodes(type);
-  for (let i = 0; i < astNodes.length; i++) {
-    const astNode = astNodes[i];
-    if (astNode && astNode.fields) {
-      astNode.fields.forEach(node => {
-        if (node.name.value === fieldName) {
-          fieldNodes.push(node);
-        }
-      });
-    }
-  }
-  return fieldNodes;
+  return getAllSubNodes(type, typeNode => typeNode.fields).filter(
+    fieldNode => fieldNode.name.value === fieldName,
+  );
 }
 
 function getFieldTypeNode(
@@ -648,11 +642,11 @@ function getAllFieldArgNodes(
   const argNodes = [];
   const fieldNode = getFieldNode(type, fieldName);
   if (fieldNode && fieldNode.arguments) {
-    fieldNode.arguments.forEach(node => {
+    for (const node of fieldNode.arguments) {
       if (node.name.value === argName) {
         argNodes.push(node);
       }
-    });
+    }
   }
   return argNodes;
 }
@@ -670,16 +664,10 @@ function getAllDirectiveArgNodes(
   directive: GraphQLDirective,
   argName: string,
 ): $ReadOnlyArray<InputValueDefinitionNode> {
-  const argNodes = [];
-  const directiveNode = directive.astNode;
-  if (directiveNode && directiveNode.arguments) {
-    directiveNode.arguments.forEach(node => {
-      if (node.name.value === argName) {
-        argNodes.push(node);
-      }
-    });
-  }
-  return argNodes;
+  return getAllSubNodes(
+    directive,
+    directiveNode => directiveNode.arguments,
+  ).filter(argNode => argNode.name.value === argName);
 }
 
 function getDirectiveArgTypeNode(
@@ -694,10 +682,8 @@ function getUnionMemberTypeNodes(
   union: GraphQLUnionType,
   typeName: string,
 ): ?$ReadOnlyArray<NamedTypeNode> {
-  return (
-    union.astNode &&
-    union.astNode.types &&
-    union.astNode.types.filter(type => type.name.value === typeName)
+  return getAllSubNodes(union, unionNode => unionNode.types).filter(
+    typeNode => typeNode.name.value === typeName,
   );
 }
 
@@ -705,9 +691,7 @@ function getEnumValueNodes(
   enumType: GraphQLEnumType,
   valueName: string,
 ): ?$ReadOnlyArray<EnumValueDefinitionNode> {
-  return (
-    enumType.astNode &&
-    enumType.astNode.values &&
-    enumType.astNode.values.filter(value => value.name.value === valueName)
+  return getAllSubNodes(enumType, enumNode => enumNode.values).filter(
+    valueNode => valueNode.name.value === valueName,
   );
 }
diff --git a/type/validate.mjs b/type/validate.mjs
index af668a1..b0bd911 100644
--- a/type/validate.mjs
+++ b/type/validate.mjs
@@ -116,41 +116,19 @@ function validateRootTypes(context) {
 }
 
 function getOperationTypeNode(schema, type, operation) {
+  var operationNodes = getAllSubNodes(schema, function (node) {
+    return node.operationTypes;
+  });
   var _iteratorNormalCompletion = true;
   var _didIteratorError = false;
   var _iteratorError = undefined;
 
   try {
-    for (var _iterator = getAllNodes(schema)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+    for (var _iterator = operationNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
       var node = _step.value;
 
-      if (node.operationTypes) {
-        var _iteratorNormalCompletion2 = true;
-        var _didIteratorError2 = false;
-        var _iteratorError2 = undefined;
-
-        try {
-          for (var _iterator2 = node.operationTypes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
-            var operationType = _step2.value;
-
-            if (operationType.operation === operation) {
-              return operationType.type;
-            }
-          }
-        } catch (err) {
-          _didIteratorError2 = true;
-          _iteratorError2 = err;
-        } finally {
-          try {
-            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
-              _iterator2.return();
-            }
-          } finally {
-            if (_didIteratorError2) {
-              throw _iteratorError2;
-            }
-          }
-        }
+      if (node.operation === operation) {
+        return node.type;
       }
     }
   } catch (err) {
@@ -172,36 +150,76 @@ function getOperationTypeNode(schema, type, operation) {
 }
 
 function validateDirectives(context) {
-  var directives = context.schema.getDirectives();
-  directives.forEach(function (directive) {
-    // Ensure all directives are in fact GraphQL directives.
-    if (!isDirective(directive)) {
-      context.reportError("Expected directive but got: ".concat(inspect(directive), "."), directive && directive.astNode);
-      return;
-    } // Ensure they are named correctly.
+  var _iteratorNormalCompletion2 = true;
+  var _didIteratorError2 = false;
+  var _iteratorError2 = undefined;
+
+  try {
+    for (var _iterator2 = context.schema.getDirectives()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+      var directive = _step2.value;
 
+      // Ensure all directives are in fact GraphQL directives.
+      if (!isDirective(directive)) {
+        context.reportError("Expected directive but got: ".concat(inspect(directive), "."), directive && directive.astNode);
+        continue;
+      } // Ensure they are named correctly.
 
-    validateName(context, directive); // TODO: Ensure proper locations.
-    // Ensure the arguments are valid.
 
-    var argNames = Object.create(null);
-    directive.args.forEach(function (arg) {
-      var argName = arg.name; // Ensure they are named correctly.
+      validateName(context, directive); // TODO: Ensure proper locations.
+      // Ensure the arguments are valid.
 
-      validateName(context, arg); // Ensure they are unique per directive.
+      var argNames = Object.create(null);
+      var _iteratorNormalCompletion3 = true;
+      var _didIteratorError3 = false;
+      var _iteratorError3 = undefined;
 
-      if (argNames[argName]) {
-        context.reportError("Argument @".concat(directive.name, "(").concat(argName, ":) can only be defined once."), getAllDirectiveArgNodes(directive, argName));
-        return; // continue loop
-      }
+      try {
+        for (var _iterator3 = directive.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
+          var arg = _step3.value;
+          var argName = arg.name; // Ensure they are named correctly.
+
+          validateName(context, arg); // Ensure they are unique per directive.
 
-      argNames[argName] = true; // Ensure the type is an input type.
+          if (argNames[argName]) {
+            context.reportError("Argument @".concat(directive.name, "(").concat(argName, ":) can only be defined once."), getAllDirectiveArgNodes(directive, argName));
+            continue;
+          }
+
+          argNames[argName] = true; // Ensure the type is an input type.
 
-      if (!isInputType(arg.type)) {
-        context.reportError("The type of @".concat(directive.name, "(").concat(argName, ":) must be Input Type ") + "but got: ".concat(inspect(arg.type), "."), getDirectiveArgTypeNode(directive, argName));
+          if (!isInputType(arg.type)) {
+            context.reportError("The type of @".concat(directive.name, "(").concat(argName, ":) must be Input Type ") + "but got: ".concat(inspect(arg.type), "."), getDirectiveArgTypeNode(directive, argName));
+          }
+        }
+      } catch (err) {
+        _didIteratorError3 = true;
+        _iteratorError3 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
+            _iterator3.return();
+          }
+        } finally {
+          if (_didIteratorError3) {
+            throw _iteratorError3;
+          }
+        }
       }
-    });
-  });
+    }
+  } catch (err) {
+    _didIteratorError2 = true;
+    _iteratorError2 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+        _iterator2.return();
+      }
+    } finally {
+      if (_didIteratorError2) {
+        throw _iteratorError2;
+      }
+    }
+  }
 }
 
 function validateName(context, node) {
@@ -221,37 +239,58 @@ function validateName(context, node) {
 
 function validateTypes(context) {
   var typeMap = context.schema.getTypeMap();
-  objectValues(typeMap).forEach(function (type) {
-    // Ensure all provided types are in fact GraphQL type.
-    if (!isNamedType(type)) {
-      context.reportError("Expected GraphQL named type but got: ".concat(inspect(type), "."), type && type.astNode);
-      return;
-    } // Ensure it is named correctly (excluding introspection types).
+  var _iteratorNormalCompletion4 = true;
+  var _didIteratorError4 = false;
+  var _iteratorError4 = undefined;
 
+  try {
+    for (var _iterator4 = objectValues(typeMap)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
+      var type = _step4.value;
 
-    if (!isIntrospectionType(type)) {
-      validateName(context, type);
-    }
+      // Ensure all provided types are in fact GraphQL type.
+      if (!isNamedType(type)) {
+        context.reportError("Expected GraphQL named type but got: ".concat(inspect(type), "."), type && type.astNode);
+        continue;
+      } // Ensure it is named correctly (excluding introspection types).
+
+
+      if (!isIntrospectionType(type)) {
+        validateName(context, type);
+      }
 
-    if (isObjectType(type)) {
-      // Ensure fields are valid
-      validateFields(context, type); // Ensure objects implement the interfaces they claim to.
-
-      validateObjectInterfaces(context, type);
-    } else if (isInterfaceType(type)) {
-      // Ensure fields are valid.
-      validateFields(context, type);
-    } else if (isUnionType(type)) {
-      // Ensure Unions include valid member types.
-      validateUnionMembers(context, type);
-    } else if (isEnumType(type)) {
-      // Ensure Enums have valid values.
-      validateEnumValues(context, type);
-    } else if (isInputObjectType(type)) {
-      // Ensure Input Object fields are valid.
-      validateInputFields(context, type);
+      if (isObjectType(type)) {
+        // Ensure fields are valid
+        validateFields(context, type); // Ensure objects implement the interfaces they claim to.
+
+        validateObjectInterfaces(context, type);
+      } else if (isInterfaceType(type)) {
+        // Ensure fields are valid.
+        validateFields(context, type);
+      } else if (isUnionType(type)) {
+        // Ensure Unions include valid member types.
+        validateUnionMembers(context, type);
+      } else if (isEnumType(type)) {
+        // Ensure Enums have valid values.
+        validateEnumValues(context, type);
+      } else if (isInputObjectType(type)) {
+        // Ensure Input Object fields are valid.
+        validateInputFields(context, type);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError4 = true;
+    _iteratorError4 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
+        _iterator4.return();
+      }
+    } finally {
+      if (_didIteratorError4) {
+        throw _iteratorError4;
+      }
+    }
+  }
 }
 
 function validateFields(context, type) {
@@ -261,72 +300,135 @@ function validateFields(context, type) {
     context.reportError("Type ".concat(type.name, " must define one or more fields."), getAllNodes(type));
   }
 
-  fields.forEach(function (field) {
-    // Ensure they are named correctly.
-    validateName(context, field); // Ensure they were defined at most once.
+  var _iteratorNormalCompletion5 = true;
+  var _didIteratorError5 = false;
+  var _iteratorError5 = undefined;
+
+  try {
+    for (var _iterator5 = fields[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
+      var field = _step5.value;
+      // Ensure they are named correctly.
+      validateName(context, field); // Ensure they were defined at most once.
 
-    var fieldNodes = getAllFieldNodes(type, field.name);
+      var fieldNodes = getAllFieldNodes(type, field.name);
 
-    if (fieldNodes.length > 1) {
-      context.reportError("Field ".concat(type.name, ".").concat(field.name, " can only be defined once."), fieldNodes);
-      return; // continue loop
-    } // Ensure the type is an output type
+      if (fieldNodes.length > 1) {
+        context.reportError("Field ".concat(type.name, ".").concat(field.name, " can only be defined once."), fieldNodes);
+        continue;
+      } // Ensure the type is an output type
 
 
-    if (!isOutputType(field.type)) {
-      context.reportError("The type of ".concat(type.name, ".").concat(field.name, " must be Output Type ") + "but got: ".concat(inspect(field.type), "."), getFieldTypeNode(type, field.name));
-    } // Ensure the arguments are valid
+      if (!isOutputType(field.type)) {
+        context.reportError("The type of ".concat(type.name, ".").concat(field.name, " must be Output Type ") + "but got: ".concat(inspect(field.type), "."), getFieldTypeNode(type, field.name));
+      } // Ensure the arguments are valid
 
 
-    var argNames = Object.create(null);
-    field.args.forEach(function (arg) {
-      var argName = arg.name; // Ensure they are named correctly.
+      var argNames = Object.create(null);
+      var _iteratorNormalCompletion6 = true;
+      var _didIteratorError6 = false;
+      var _iteratorError6 = undefined;
 
-      validateName(context, arg); // Ensure they are unique per field.
+      try {
+        for (var _iterator6 = field.args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
+          var arg = _step6.value;
+          var argName = arg.name; // Ensure they are named correctly.
 
-      if (argNames[argName]) {
-        context.reportError("Field argument ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) can only ") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));
-      }
+          validateName(context, arg); // Ensure they are unique per field.
+
+          if (argNames[argName]) {
+            context.reportError("Field argument ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) can only ") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));
+          }
 
-      argNames[argName] = true; // Ensure the type is an input type
+          argNames[argName] = true; // Ensure the type is an input type
 
-      if (!isInputType(arg.type)) {
-        context.reportError("The type of ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) must be Input ") + "Type but got: ".concat(inspect(arg.type), "."), getFieldArgTypeNode(type, field.name, argName));
+          if (!isInputType(arg.type)) {
+            context.reportError("The type of ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) must be Input ") + "Type but got: ".concat(inspect(arg.type), "."), getFieldArgTypeNode(type, field.name, argName));
+          }
+        }
+      } catch (err) {
+        _didIteratorError6 = true;
+        _iteratorError6 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
+            _iterator6.return();
+          }
+        } finally {
+          if (_didIteratorError6) {
+            throw _iteratorError6;
+          }
+        }
       }
-    });
-  });
+    }
+  } catch (err) {
+    _didIteratorError5 = true;
+    _iteratorError5 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
+        _iterator5.return();
+      }
+    } finally {
+      if (_didIteratorError5) {
+        throw _iteratorError5;
+      }
+    }
+  }
 }
 
 function validateObjectInterfaces(context, object) {
   var implementedTypeNames = Object.create(null);
-  object.getInterfaces().forEach(function (iface) {
-    if (!isInterfaceType(iface)) {
-      context.reportError("Type ".concat(inspect(object), " must only implement Interface types, ") + "it cannot implement ".concat(inspect(iface), "."), getImplementsInterfaceNode(object, iface));
-      return;
-    }
+  var _iteratorNormalCompletion7 = true;
+  var _didIteratorError7 = false;
+  var _iteratorError7 = undefined;
 
-    if (implementedTypeNames[iface.name]) {
-      context.reportError("Type ".concat(object.name, " can only implement ").concat(iface.name, " once."), getAllImplementsInterfaceNodes(object, iface));
-      return; // continue loop
-    }
+  try {
+    for (var _iterator7 = object.getInterfaces()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
+      var iface = _step7.value;
 
-    implementedTypeNames[iface.name] = true;
-    validateObjectImplementsInterface(context, object, iface);
-  });
+      if (!isInterfaceType(iface)) {
+        context.reportError("Type ".concat(inspect(object), " must only implement Interface types, ") + "it cannot implement ".concat(inspect(iface), "."), getImplementsInterfaceNode(object, iface));
+        continue;
+      }
+
+      if (implementedTypeNames[iface.name]) {
+        context.reportError("Type ".concat(object.name, " can only implement ").concat(iface.name, " once."), getAllImplementsInterfaceNodes(object, iface));
+        continue;
+      }
+
+      implementedTypeNames[iface.name] = true;
+      validateObjectImplementsInterface(context, object, iface);
+    }
+  } catch (err) {
+    _didIteratorError7 = true;
+    _iteratorError7 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
+        _iterator7.return();
+      }
+    } finally {
+      if (_didIteratorError7) {
+        throw _iteratorError7;
+      }
+    }
+  }
 }
 
 function validateObjectImplementsInterface(context, object, iface) {
   var objectFieldMap = object.getFields();
   var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.
 
-  Object.keys(ifaceFieldMap).forEach(function (fieldName) {
+  var _arr = Object.keys(ifaceFieldMap);
+
+  for (var _i = 0; _i < _arr.length; _i++) {
+    var fieldName = _arr[_i];
     var objectField = objectFieldMap[fieldName];
     var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.
 
     if (!objectField) {
-      context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expected but ") + "".concat(object.name, " does not provide it."), [getFieldNode(iface, fieldName), object.astNode]); // Continue loop over fields.
-
-      return;
+      context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expected but ") + "".concat(object.name, " does not provide it."), [getFieldNode(iface, fieldName)].concat(getAllNodes(object)));
+      continue;
     } // Assert interface field type is satisfied by object field type, by being
     // a valid subtype. (covariant)
 
@@ -336,104 +438,215 @@ function validateObjectImplementsInterface(context, object, iface) {
     } // Assert each interface field arg is implemented.
 
 
-    ifaceField.args.forEach(function (ifaceArg) {
-      var argName = ifaceArg.name;
-      var objectArg = find(objectField.args, function (arg) {
-        return arg.name === argName;
-      }); // Assert interface field arg exists on object field.
+    var _iteratorNormalCompletion8 = true;
+    var _didIteratorError8 = false;
+    var _iteratorError8 = undefined;
+
+    try {
+      var _loop = function _loop() {
+        var ifaceArg = _step8.value;
+        var argName = ifaceArg.name;
+        var objectArg = find(objectField.args, function (arg) {
+          return arg.name === argName;
+        }); // Assert interface field arg exists on object field.
 
-      if (!objectArg) {
-        context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expected but ".concat(object.name, ".").concat(fieldName, " does not provide it."), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]); // Continue loop over arguments.
+        if (!objectArg) {
+          context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expected but ".concat(object.name, ".").concat(fieldName, " does not provide it."), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);
+          return "continue";
+        } // Assert interface field arg type matches object field arg type.
+        // (invariant)
+        // TODO: change to contravariant?
 
-        return;
-      } // Assert interface field arg type matches object field arg type.
-      // (invariant)
-      // TODO: change to contravariant?
 
+        if (!isEqualType(ifaceArg.type, objectArg.type)) {
+          context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expects type ".concat(inspect(ifaceArg.type), " but ") + "".concat(object.name, ".").concat(fieldName, "(").concat(argName, ":) is type ") + "".concat(inspect(objectArg.type), "."), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);
+        } // TODO: validate default values?
 
-      if (!isEqualType(ifaceArg.type, objectArg.type)) {
-        context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expects type ".concat(inspect(ifaceArg.type), " but ") + "".concat(object.name, ".").concat(fieldName, "(").concat(argName, ":) is type ") + "".concat(inspect(objectArg.type), "."), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);
-      } // TODO: validate default values?
+      };
 
-    }); // Assert additional arguments must not be required.
+      for (var _iterator8 = ifaceField.args[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
+        var _ret = _loop();
 
-    objectField.args.forEach(function (objectArg) {
-      var argName = objectArg.name;
-      var ifaceArg = find(ifaceField.args, function (arg) {
-        return arg.name === argName;
-      });
+        if (_ret === "continue") continue;
+      } // Assert additional arguments must not be required.
 
-      if (!ifaceArg && isNonNullType(objectArg.type)) {
-        context.reportError("Object field argument ".concat(object.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "is of required type ".concat(inspect(objectArg.type), " but is not also ") + "provided by the Interface field ".concat(iface.name, ".").concat(fieldName, "."), [getFieldArgTypeNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);
+    } catch (err) {
+      _didIteratorError8 = true;
+      _iteratorError8 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
+          _iterator8.return();
+        }
+      } finally {
+        if (_didIteratorError8) {
+          throw _iteratorError8;
+        }
       }
-    });
-  });
+    }
+
+    var _iteratorNormalCompletion9 = true;
+    var _didIteratorError9 = false;
+    var _iteratorError9 = undefined;
+
+    try {
+      var _loop2 = function _loop2() {
+        var objectArg = _step9.value;
+        var argName = objectArg.name;
+        var ifaceArg = find(ifaceField.args, function (arg) {
+          return arg.name === argName;
+        });
+
+        if (!ifaceArg && isNonNullType(objectArg.type)) {
+          context.reportError("Object field argument ".concat(object.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "is of required type ".concat(inspect(objectArg.type), " but is not also ") + "provided by the Interface field ".concat(iface.name, ".").concat(fieldName, "."), [getFieldArgTypeNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);
+        }
+      };
+
+      for (var _iterator9 = objectField.args[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
+        _loop2();
+      }
+    } catch (err) {
+      _didIteratorError9 = true;
+      _iteratorError9 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
+          _iterator9.return();
+        }
+      } finally {
+        if (_didIteratorError9) {
+          throw _iteratorError9;
+        }
+      }
+    }
+  }
 }
 
 function validateUnionMembers(context, union) {
   var memberTypes = union.getTypes();
 
   if (memberTypes.length === 0) {
-    context.reportError("Union type ".concat(union.name, " must define one or more member types."), union.astNode);
+    context.reportError("Union type ".concat(union.name, " must define one or more member types."), getAllNodes(union));
   }
 
   var includedTypeNames = Object.create(null);
-  memberTypes.forEach(function (memberType) {
-    if (includedTypeNames[memberType.name]) {
-      context.reportError("Union type ".concat(union.name, " can only include type ") + "".concat(memberType.name, " once."), getUnionMemberTypeNodes(union, memberType.name));
-      return; // continue loop
-    }
+  var _iteratorNormalCompletion10 = true;
+  var _didIteratorError10 = false;
+  var _iteratorError10 = undefined;
+
+  try {
+    for (var _iterator10 = memberTypes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
+      var memberType = _step10.value;
 
-    includedTypeNames[memberType.name] = true;
+      if (includedTypeNames[memberType.name]) {
+        context.reportError("Union type ".concat(union.name, " can only include type ") + "".concat(memberType.name, " once."), getUnionMemberTypeNodes(union, memberType.name));
+        continue;
+      }
+
+      includedTypeNames[memberType.name] = true;
 
-    if (!isObjectType(memberType)) {
-      context.reportError("Union type ".concat(union.name, " can only include Object types, ") + "it cannot include ".concat(inspect(memberType), "."), getUnionMemberTypeNodes(union, String(memberType)));
+      if (!isObjectType(memberType)) {
+        context.reportError("Union type ".concat(union.name, " can only include Object types, ") + "it cannot include ".concat(inspect(memberType), "."), getUnionMemberTypeNodes(union, String(memberType)));
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError10 = true;
+    _iteratorError10 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
+        _iterator10.return();
+      }
+    } finally {
+      if (_didIteratorError10) {
+        throw _iteratorError10;
+      }
+    }
+  }
 }
 
 function validateEnumValues(context, enumType) {
   var enumValues = enumType.getValues();
 
   if (enumValues.length === 0) {
-    context.reportError("Enum type ".concat(enumType.name, " must define one or more values."), enumType.astNode);
+    context.reportError("Enum type ".concat(enumType.name, " must define one or more values."), getAllNodes(enumType));
   }
 
-  enumValues.forEach(function (enumValue) {
-    var valueName = enumValue.name; // Ensure no duplicates.
+  var _iteratorNormalCompletion11 = true;
+  var _didIteratorError11 = false;
+  var _iteratorError11 = undefined;
 
-    var allNodes = getEnumValueNodes(enumType, valueName);
+  try {
+    for (var _iterator11 = enumValues[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
+      var enumValue = _step11.value;
+      var valueName = enumValue.name; // Ensure no duplicates.
+
+      var allNodes = getEnumValueNodes(enumType, valueName);
 
-    if (allNodes && allNodes.length > 1) {
-      context.reportError("Enum type ".concat(enumType.name, " can include value ").concat(valueName, " only once."), allNodes);
-    } // Ensure valid name.
+      if (allNodes && allNodes.length > 1) {
+        context.reportError("Enum type ".concat(enumType.name, " can include value ").concat(valueName, " only once."), allNodes);
+      } // Ensure valid name.
 
 
-    validateName(context, enumValue);
+      validateName(context, enumValue);
 
-    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {
-      context.reportError("Enum type ".concat(enumType.name, " cannot include value: ").concat(valueName, "."), enumValue.astNode);
+      if (valueName === 'true' || valueName === 'false' || valueName === 'null') {
+        context.reportError("Enum type ".concat(enumType.name, " cannot include value: ").concat(valueName, "."), enumValue.astNode);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError11 = true;
+    _iteratorError11 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
+        _iterator11.return();
+      }
+    } finally {
+      if (_didIteratorError11) {
+        throw _iteratorError11;
+      }
+    }
+  }
 }
 
 function validateInputFields(context, inputObj) {
   var fields = objectValues(inputObj.getFields());
 
   if (fields.length === 0) {
-    context.reportError("Input Object type ".concat(inputObj.name, " must define one or more fields."), inputObj.astNode);
+    context.reportError("Input Object type ".concat(inputObj.name, " must define one or more fields."), getAllNodes(inputObj));
   } // Ensure the arguments are valid
 
 
-  fields.forEach(function (field) {
-    // Ensure they are named correctly.
-    validateName(context, field); // TODO: Ensure they are unique per field.
-    // Ensure the type is an input type
+  var _iteratorNormalCompletion12 = true;
+  var _didIteratorError12 = false;
+  var _iteratorError12 = undefined;
 
-    if (!isInputType(field.type)) {
-      context.reportError("The type of ".concat(inputObj.name, ".").concat(field.name, " must be Input Type ") + "but got: ".concat(inspect(field.type), "."), field.astNode && field.astNode.type);
+  try {
+    for (var _iterator12 = fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
+      var field = _step12.value;
+      // Ensure they are named correctly.
+      validateName(context, field); // TODO: Ensure they are unique per field.
+      // Ensure the type is an input type
+
+      if (!isInputType(field.type)) {
+        context.reportError("The type of ".concat(inputObj.name, ".").concat(field.name, " must be Input Type ") + "but got: ".concat(inspect(field.type), "."), field.astNode && field.astNode.type);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError12 = true;
+    _iteratorError12 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
+        _iterator12.return();
+      }
+    } finally {
+      if (_didIteratorError12) {
+        throw _iteratorError12;
+      }
+    }
+  }
 }
 
 function getAllNodes(object) {
@@ -442,27 +655,52 @@ function getAllNodes(object) {
   return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];
 }
 
-function getImplementsInterfaceNode(type, iface) {
-  return getAllImplementsInterfaceNodes(type, iface)[0];
-}
+function getAllSubNodes(object, getter) {
+  var result = [];
+  var _iteratorNormalCompletion13 = true;
+  var _didIteratorError13 = false;
+  var _iteratorError13 = undefined;
 
-function getAllImplementsInterfaceNodes(type, iface) {
-  var implementsNodes = [];
-  var astNodes = getAllNodes(type);
+  try {
+    for (var _iterator13 = getAllNodes(object)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
+      var astNode = _step13.value;
 
-  for (var i = 0; i < astNodes.length; i++) {
-    var _astNode = astNodes[i];
+      if (astNode) {
+        var subNodes = getter(astNode);
 
-    if (_astNode && _astNode.interfaces) {
-      _astNode.interfaces.forEach(function (node) {
-        if (node.name.value === iface.name) {
-          implementsNodes.push(node);
+        if (subNodes) {
+          result = result.concat(subNodes);
         }
-      });
+      }
+    }
+  } catch (err) {
+    _didIteratorError13 = true;
+    _iteratorError13 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
+        _iterator13.return();
+      }
+    } finally {
+      if (_didIteratorError13) {
+        throw _iteratorError13;
+      }
     }
   }
 
-  return implementsNodes;
+  return result;
+}
+
+function getImplementsInterfaceNode(type, iface) {
+  return getAllImplementsInterfaceNodes(type, iface)[0];
+}
+
+function getAllImplementsInterfaceNodes(type, iface) {
+  return getAllSubNodes(type, function (typeNode) {
+    return typeNode.interfaces;
+  }).filter(function (ifaceNode) {
+    return ifaceNode.name.value === iface.name;
+  });
 }
 
 function getFieldNode(type, fieldName) {
@@ -470,22 +708,11 @@ function getFieldNode(type, fieldName) {
 }
 
 function getAllFieldNodes(type, fieldName) {
-  var fieldNodes = [];
-  var astNodes = getAllNodes(type);
-
-  for (var i = 0; i < astNodes.length; i++) {
-    var _astNode2 = astNodes[i];
-
-    if (_astNode2 && _astNode2.fields) {
-      _astNode2.fields.forEach(function (node) {
-        if (node.name.value === fieldName) {
-          fieldNodes.push(node);
-        }
-      });
-    }
-  }
-
-  return fieldNodes;
+  return getAllSubNodes(type, function (typeNode) {
+    return typeNode.fields;
+  }).filter(function (fieldNode) {
+    return fieldNode.name.value === fieldName;
+  });
 }
 
 function getFieldTypeNode(type, fieldName) {
@@ -502,11 +729,32 @@ function getAllFieldArgNodes(type, fieldName, argName) {
   var fieldNode = getFieldNode(type, fieldName);
 
   if (fieldNode && fieldNode.arguments) {
-    fieldNode.arguments.forEach(function (node) {
-      if (node.name.value === argName) {
-        argNodes.push(node);
+    var _iteratorNormalCompletion14 = true;
+    var _didIteratorError14 = false;
+    var _iteratorError14 = undefined;
+
+    try {
+      for (var _iterator14 = fieldNode.arguments[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
+        var node = _step14.value;
+
+        if (node.name.value === argName) {
+          argNodes.push(node);
+        }
       }
-    });
+    } catch (err) {
+      _didIteratorError14 = true;
+      _iteratorError14 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
+          _iterator14.return();
+        }
+      } finally {
+        if (_didIteratorError14) {
+          throw _iteratorError14;
+        }
+      }
+    }
   }
 
   return argNodes;
@@ -518,18 +766,11 @@ function getFieldArgTypeNode(type, fieldName, argName) {
 }
 
 function getAllDirectiveArgNodes(directive, argName) {
-  var argNodes = [];
-  var directiveNode = directive.astNode;
-
-  if (directiveNode && directiveNode.arguments) {
-    directiveNode.arguments.forEach(function (node) {
-      if (node.name.value === argName) {
-        argNodes.push(node);
-      }
-    });
-  }
-
-  return argNodes;
+  return getAllSubNodes(directive, function (directiveNode) {
+    return directiveNode.arguments;
+  }).filter(function (argNode) {
+    return argNode.name.value === argName;
+  });
 }
 
 function getDirectiveArgTypeNode(directive, argName) {
@@ -538,13 +779,17 @@ function getDirectiveArgTypeNode(directive, argName) {
 }
 
 function getUnionMemberTypeNodes(union, typeName) {
-  return union.astNode && union.astNode.types && union.astNode.types.filter(function (type) {
-    return type.name.value === typeName;
+  return getAllSubNodes(union, function (unionNode) {
+    return unionNode.types;
+  }).filter(function (typeNode) {
+    return typeNode.name.value === typeName;
   });
 }
 
 function getEnumValueNodes(enumType, valueName) {
-  return enumType.astNode && enumType.astNode.values && enumType.astNode.values.filter(function (value) {
-    return value.name.value === valueName;
+  return getAllSubNodes(enumType, function (enumNode) {
+    return enumNode.values;
+  }).filter(function (valueNode) {
+    return valueNode.name.value === valueName;
   });
 }
\ No newline at end of file
diff --git a/utilities/TypeInfo.js b/utilities/TypeInfo.js
index c3b260b..81813c1 100644
--- a/utilities/TypeInfo.js
+++ b/utilities/TypeInfo.js
@@ -125,12 +125,9 @@ function () {
 
   _proto.getEnumValue = function getEnumValue() {
     return this._enumValue;
-  }; // Flow does not yet handle this case.
-
+  };
 
-  _proto.enter = function enter(node
-  /* ASTNode */
-  ) {
+  _proto.enter = function enter(node) {
     var schema = this._schema; // Note: many of the types below are explicitly typed as "mixed" to drop
     // any assumptions of a valid schema to ensure runtime types are properly
     // checked before continuing since TypeInfo is used as part of validation
diff --git a/utilities/TypeInfo.js.flow b/utilities/TypeInfo.js.flow
index 6791175..b217131 100644
--- a/utilities/TypeInfo.js.flow
+++ b/utilities/TypeInfo.js.flow
@@ -139,8 +139,7 @@ export class TypeInfo {
     return this._enumValue;
   }
 
-  // Flow does not yet handle this case.
-  enter(node: any /* ASTNode */) {
+  enter(node: ASTNode) {
     const schema = this._schema;
     // Note: many of the types below are explicitly typed as "mixed" to drop
     // any assumptions of a valid schema to ensure runtime types are properly
diff --git a/utilities/TypeInfo.mjs b/utilities/TypeInfo.mjs
index 7c06618..d74e661 100644
--- a/utilities/TypeInfo.mjs
+++ b/utilities/TypeInfo.mjs
@@ -120,12 +120,9 @@ function () {
 
   _proto.getEnumValue = function getEnumValue() {
     return this._enumValue;
-  }; // Flow does not yet handle this case.
-
+  };
 
-  _proto.enter = function enter(node
-  /* ASTNode */
-  ) {
+  _proto.enter = function enter(node) {
     var schema = this._schema; // Note: many of the types below are explicitly typed as "mixed" to drop
     // any assumptions of a valid schema to ensure runtime types are properly
     // checked before continuing since TypeInfo is used as part of validation
diff --git a/utilities/astFromValue.js b/utilities/astFromValue.js
index 99ba5c6..bbebca5 100644
--- a/utilities/astFromValue.js
+++ b/utilities/astFromValue.js
@@ -97,20 +97,41 @@ function astFromValue(value, type) {
 
     var fields = (0, _objectValues.default)(type.getFields());
     var fieldNodes = [];
-    fields.forEach(function (field) {
-      var fieldValue = astFromValue(value[field.name], field.type);
-
-      if (fieldValue) {
-        fieldNodes.push({
-          kind: _kinds.Kind.OBJECT_FIELD,
-          name: {
-            kind: _kinds.Kind.NAME,
-            value: field.name
-          },
-          value: fieldValue
-        });
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
+    try {
+      for (var _iterator = fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+        var field = _step.value;
+        var fieldValue = astFromValue(value[field.name], field.type);
+
+        if (fieldValue) {
+          fieldNodes.push({
+            kind: _kinds.Kind.OBJECT_FIELD,
+            name: {
+              kind: _kinds.Kind.NAME,
+              value: field.name
+            },
+            value: fieldValue
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return != null) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
       }
-    });
+    }
+
     return {
       kind: _kinds.Kind.OBJECT,
       fields: fieldNodes
diff --git a/utilities/astFromValue.js.flow b/utilities/astFromValue.js.flow
index 883eb79..cf73305 100644
--- a/utilities/astFromValue.js.flow
+++ b/utilities/astFromValue.js.flow
@@ -86,7 +86,7 @@ export function astFromValue(value: mixed, type: GraphQLInputType): ?ValueNode {
     }
     const fields = objectValues(type.getFields());
     const fieldNodes = [];
-    fields.forEach(field => {
+    for (const field of fields) {
       const fieldValue = astFromValue(value[field.name], field.type);
       if (fieldValue) {
         fieldNodes.push({
@@ -95,7 +95,7 @@ export function astFromValue(value: mixed, type: GraphQLInputType): ?ValueNode {
           value: fieldValue,
         });
       }
-    });
+    }
     return { kind: Kind.OBJECT, fields: fieldNodes };
   }
 
diff --git a/utilities/astFromValue.mjs b/utilities/astFromValue.mjs
index 3962582..1403f3d 100644
--- a/utilities/astFromValue.mjs
+++ b/utilities/astFromValue.mjs
@@ -89,20 +89,41 @@ export function astFromValue(value, type) {
 
     var fields = objectValues(type.getFields());
     var fieldNodes = [];
-    fields.forEach(function (field) {
-      var fieldValue = astFromValue(value[field.name], field.type);
-
-      if (fieldValue) {
-        fieldNodes.push({
-          kind: Kind.OBJECT_FIELD,
-          name: {
-            kind: Kind.NAME,
-            value: field.name
-          },
-          value: fieldValue
-        });
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
+    try {
+      for (var _iterator = fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+        var field = _step.value;
+        var fieldValue = astFromValue(value[field.name], field.type);
+
+        if (fieldValue) {
+          fieldNodes.push({
+            kind: Kind.OBJECT_FIELD,
+            name: {
+              kind: Kind.NAME,
+              value: field.name
+            },
+            value: fieldValue
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return != null) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
       }
-    });
+    }
+
     return {
       kind: Kind.OBJECT,
       fields: fieldNodes
diff --git a/utilities/buildASTSchema.js b/utilities/buildASTSchema.js
index 22dadf2..ff3bea3 100644
--- a/utilities/buildASTSchema.js
+++ b/utilities/buildASTSchema.js
@@ -14,6 +14,8 @@ var _keyValMap = _interopRequireDefault(require("../jsutils/keyValMap"));
 
 var _valueFromAST = require("./valueFromAST");
 
+var _validate = require("../validation/validate");
+
 var _blockStringValue = _interopRequireDefault(require("../language/blockStringValue"));
 
 var _lexer = require("../language/lexer");
@@ -38,28 +40,6 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
 
 function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
 
-function buildWrappedType(innerType, inputTypeNode) {
-  if (inputTypeNode.kind === _kinds.Kind.LIST_TYPE) {
-    return (0, _definition.GraphQLList)(buildWrappedType(innerType, inputTypeNode.type));
-  }
-
-  if (inputTypeNode.kind === _kinds.Kind.NON_NULL_TYPE) {
-    var wrappedType = buildWrappedType(innerType, inputTypeNode.type);
-    return (0, _definition.GraphQLNonNull)((0, _definition.assertNullableType)(wrappedType));
-  }
-
-  return innerType;
-}
-
-function getNamedTypeNode(typeNode) {
-  var namedType = typeNode;
-
-  while (namedType.kind === _kinds.Kind.LIST_TYPE || namedType.kind === _kinds.Kind.NON_NULL_TYPE) {
-    namedType = namedType.type;
-  }
-
-  return namedType;
-}
 /**
  * This takes the ast of a schema document produced by the parse function in
  * src/language/parser.js.
@@ -76,13 +56,15 @@ function getNamedTypeNode(typeNode) {
  *        Provide true to use preceding comments as the description.
  *
  */
-
-
 function buildASTSchema(ast, options) {
   if (!ast || ast.kind !== _kinds.Kind.DOCUMENT) {
     throw new Error('Must provide a document ast.');
   }
 
+  if (!options || !(options.assumeValid || options.assumeValidSDL)) {
+    (0, _validate.assertValidSDL)(ast);
+  }
+
   var schemaDef;
   var typeDefs = [];
   var nodeMap = Object.create(null);
@@ -93,10 +75,6 @@ function buildASTSchema(ast, options) {
 
     switch (d.kind) {
       case _kinds.Kind.SCHEMA_DEFINITION:
-        if (schemaDef) {
-          throw new Error('Must provide only one schema definition.');
-        }
-
         schemaDef = d;
         break;
 
@@ -130,7 +108,6 @@ function buildASTSchema(ast, options) {
   var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeRef) {
     throw new Error("Type \"".concat(typeRef.name.value, "\" not found in document."));
   });
-  var types = definitionBuilder.buildTypes(typeDefs);
   var directives = directiveDefs.map(function (def) {
     return definitionBuilder.buildDirective(def);
   }); // If specified directives were not explicitly declared, add them.
@@ -151,6 +128,12 @@ function buildASTSchema(ast, options) {
     return directive.name === 'deprecated';
   })) {
     directives.push(_directives.GraphQLDeprecatedDirective);
+  }
+
+  if (!directives.some(function (directive) {
+    return directive.name === 'iam';
+  })) {
+    directives.push(_directives.GraphQLIAMDirective);
   } // Note: While this could make early assertions to get the correctly
   // typed values below, that would throw immediately while type system
   // validation with validateSchema() will produce more actionable results.
@@ -160,7 +143,9 @@ function buildASTSchema(ast, options) {
     query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,
     mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,
     subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,
-    types: types,
+    types: typeDefs.map(function (node) {
+      return definitionBuilder.buildType(node);
+    }),
     directives: directives,
     astNode: schemaDef,
     assumeValid: options && options.assumeValid,
@@ -169,20 +154,41 @@ function buildASTSchema(ast, options) {
 
   function getOperationTypes(schema) {
     var opTypes = {};
-    schema.operationTypes.forEach(function (operationType) {
-      var typeName = operationType.type.name.value;
-      var operation = operationType.operation;
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
+    try {
+      for (var _iterator = schema.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+        var operationType = _step.value;
+        var _typeName = operationType.type.name.value;
+        var operation = operationType.operation;
+
+        if (opTypes[operation]) {
+          throw new Error("Must provide only one ".concat(operation, " type in schema."));
+        }
 
-      if (opTypes[operation]) {
-        throw new Error("Must provide only one ".concat(operation, " type in schema."));
-      }
+        if (!nodeMap[_typeName]) {
+          throw new Error("Specified ".concat(operation, " type \"").concat(_typeName, "\" not found in document."));
+        }
 
-      if (!nodeMap[typeName]) {
-        throw new Error("Specified ".concat(operation, " type \"").concat(typeName, "\" not found in document."));
+        opTypes[operation] = operationType.type;
       }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return != null) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
+    }
 
-      opTypes[operation] = operationType.type;
-    });
     return opTypes;
   }
 }
@@ -210,14 +216,6 @@ function () {
 
   var _proto = ASTDefinitionBuilder.prototype;
 
-  _proto.buildTypes = function buildTypes(nodes) {
-    var _this = this;
-
-    return nodes.map(function (node) {
-      return _this.buildType(node);
-    });
-  };
-
   _proto.buildType = function buildType(node) {
     var typeName = node.name.value;
 
@@ -234,8 +232,16 @@ function () {
   };
 
   _proto._buildWrappedType = function _buildWrappedType(typeNode) {
-    var typeDef = this.buildType(getNamedTypeNode(typeNode));
-    return buildWrappedType(typeDef, typeNode);
+    if (typeNode.kind === _kinds.Kind.LIST_TYPE) {
+      return (0, _definition.GraphQLList)(this._buildWrappedType(typeNode.type));
+    }
+
+    if (typeNode.kind === _kinds.Kind.NON_NULL_TYPE) {
+      return (0, _definition.GraphQLNonNull)( // Note: GraphQLNonNull constructor validates this type
+      this._buildWrappedType(typeNode.type));
+    }
+
+    return this.buildType(typeNode);
   };
 
   _proto.buildDirective = function buildDirective(directiveNode) {
@@ -259,6 +265,7 @@ function () {
       description: getDescription(field, this._options),
       args: field.arguments && this._makeInputValues(field.arguments),
       deprecationReason: getDeprecationReason(field),
+      iamName: getIAMName(field),
       astNode: field
     };
   };
@@ -311,54 +318,55 @@ function () {
   };
 
   _proto._makeTypeDef = function _makeTypeDef(def) {
-    var _this2 = this;
+    var _this = this;
 
-    var typeName = def.name.value;
     var interfaces = def.interfaces;
     return new _definition.GraphQLObjectType({
-      name: typeName,
+      name: def.name.value,
       description: getDescription(def, this._options),
       fields: function fields() {
-        return _this2._makeFieldDefMap(def);
+        return _this._makeFieldDefMap(def);
       },
       // Note: While this could make early assertions to get the correctly
       // typed values, that would throw immediately while type system
       // validation with validateSchema() will produce more actionable results.
       interfaces: interfaces ? function () {
-        return _this2.buildTypes(interfaces);
+        return interfaces.map(function (ref) {
+          return _this.buildType(ref);
+        });
       } : [],
       astNode: def
     });
   };
 
   _proto._makeFieldDefMap = function _makeFieldDefMap(def) {
-    var _this3 = this;
+    var _this2 = this;
 
     return def.fields ? (0, _keyValMap.default)(def.fields, function (field) {
       return field.name.value;
     }, function (field) {
-      return _this3.buildField(field);
+      return _this2.buildField(field);
     }) : {};
   };
 
   _proto._makeInputValues = function _makeInputValues(values) {
-    var _this4 = this;
+    var _this3 = this;
 
     return (0, _keyValMap.default)(values, function (value) {
       return value.name.value;
     }, function (value) {
-      return _this4.buildInputField(value);
+      return _this3.buildInputField(value);
     });
   };
 
   _proto._makeInterfaceDef = function _makeInterfaceDef(def) {
-    var _this5 = this;
+    var _this4 = this;
 
     return new _definition.GraphQLInterfaceType({
       name: def.name.value,
       description: getDescription(def, this._options),
       fields: function fields() {
-        return _this5._makeFieldDefMap(def);
+        return _this4._makeFieldDefMap(def);
       },
       astNode: def
     });
@@ -374,23 +382,30 @@ function () {
   };
 
   _proto._makeValueDefMap = function _makeValueDefMap(def) {
-    var _this6 = this;
+    var _this5 = this;
 
     return def.values ? (0, _keyValMap.default)(def.values, function (enumValue) {
       return enumValue.name.value;
     }, function (enumValue) {
-      return _this6.buildEnumValue(enumValue);
+      return _this5.buildEnumValue(enumValue);
     }) : {};
   };
 
   _proto._makeUnionDef = function _makeUnionDef(def) {
+    var _this6 = this;
+
+    var types = def.types;
     return new _definition.GraphQLUnionType({
       name: def.name.value,
       description: getDescription(def, this._options),
       // Note: While this could make assertions to get the correctly typed
       // values below, that would throw immediately while type system
       // validation with validateSchema() will produce more actionable results.
-      types: def.types ? this.buildTypes(def.types) : [],
+      types: types ? function () {
+        return types.map(function (ref) {
+          return _this6.buildType(ref);
+        });
+      } : [],
       astNode: def
     });
   };
@@ -433,8 +448,19 @@ function getDeprecationReason(node) {
   var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);
   return deprecated && deprecated.reason;
 }
+/**
+ * Given a field or enum value node, returns the string value for the
+ * iam access key (i.e. its name).
+ */
+
+
+function getIAMName(node) {
+  var iam = (0, _values.getDirectiveValues)(_directives.GraphQLIAMDirective, node);
+  return iam && iam.name;
+}
 /**
  * Given an ast node, returns its string description.
+ * @deprecated: provided to ease adoption and will be removed in v16.
  *
  * Accepts options as a second argument:
  *
diff --git a/utilities/buildASTSchema.js.flow b/utilities/buildASTSchema.js.flow
index 85f85ac..739972d 100644
--- a/utilities/buildASTSchema.js.flow
+++ b/utilities/buildASTSchema.js.flow
@@ -11,6 +11,7 @@ import keyMap from '../jsutils/keyMap';
 import keyValMap from '../jsutils/keyValMap';
 import type { ObjMap } from '../jsutils/ObjMap';
 import { valueFromAST } from './valueFromAST';
+import { assertValidSDL } from '../validation/validate';
 import blockStringValue from '../language/blockStringValue';
 import { TokenKind } from '../language/lexer';
 import { parse } from '../language/parser';
@@ -42,12 +43,14 @@ import type {
 import type { DirectiveLocationEnum } from '../language/directiveLocation';
 
 import type {
+  GraphQLType,
+  GraphQLNamedType,
+  GraphQLFieldConfig,
   GraphQLEnumValueConfig,
   GraphQLInputField,
 } from '../type/definition';
 
 import {
-  assertNullableType,
   GraphQLScalarType,
   GraphQLObjectType,
   GraphQLInterfaceType,
@@ -63,6 +66,7 @@ import {
   GraphQLSkipDirective,
   GraphQLIncludeDirective,
   GraphQLDeprecatedDirective,
+  GraphQLIAMDirective,
 } from '../type/directives';
 
 import { introspectionTypes } from '../type/introspection';
@@ -72,12 +76,6 @@ import { specifiedScalarTypes } from '../type/scalars';
 import { GraphQLSchema } from '../type/schema';
 import type { GraphQLSchemaValidationOptions } from '../type/schema';
 
-import type {
-  GraphQLType,
-  GraphQLNamedType,
-  GraphQLFieldConfig,
-} from '../type/definition';
-
 export type BuildSchemaOptions = {
   ...GraphQLSchemaValidationOptions,
 
@@ -85,36 +83,19 @@ export type BuildSchemaOptions = {
    * Descriptions are defined as preceding string literals, however an older
    * experimental version of the SDL supported preceding comments as
    * descriptions. Set to true to enable this deprecated behavior.
+   * This option is provided to ease adoption and will be removed in v16.
    *
    * Default: false
    */
   commentDescriptions?: boolean,
-};
 
-function buildWrappedType(
-  innerType: GraphQLType,
-  inputTypeNode: TypeNode,
-): GraphQLType {
-  if (inputTypeNode.kind === Kind.LIST_TYPE) {
-    return GraphQLList(buildWrappedType(innerType, inputTypeNode.type));
-  }
-  if (inputTypeNode.kind === Kind.NON_NULL_TYPE) {
-    const wrappedType = buildWrappedType(innerType, inputTypeNode.type);
-    return GraphQLNonNull(assertNullableType(wrappedType));
-  }
-  return innerType;
-}
-
-function getNamedTypeNode(typeNode: TypeNode): NamedTypeNode {
-  let namedType = typeNode;
-  while (
-    namedType.kind === Kind.LIST_TYPE ||
-    namedType.kind === Kind.NON_NULL_TYPE
-  ) {
-    namedType = namedType.type;
-  }
-  return namedType;
-}
+  /**
+   * Set to true to assume the SDL is valid.
+   *
+   * Default: false
+   */
+  assumeValidSDL?: boolean,
+};
 
 /**
  * This takes the ast of a schema document produced by the parse function in
@@ -140,6 +121,10 @@ export function buildASTSchema(
     throw new Error('Must provide a document ast.');
   }
 
+  if (!options || !(options.assumeValid || options.assumeValidSDL)) {
+    assertValidSDL(ast);
+  }
+
   let schemaDef: ?SchemaDefinitionNode;
 
   const typeDefs: Array<TypeDefinitionNode> = [];
@@ -149,9 +134,6 @@ export function buildASTSchema(
     const d = ast.definitions[i];
     switch (d.kind) {
       case Kind.SCHEMA_DEFINITION:
-        if (schemaDef) {
-          throw new Error('Must provide only one schema definition.');
-        }
         schemaDef = d;
         break;
       case Kind.SCALAR_TYPE_DEFINITION:
@@ -189,7 +171,6 @@ export function buildASTSchema(
     },
   );
 
-  const types = definitionBuilder.buildTypes(typeDefs);
   const directives = directiveDefs.map(def =>
     definitionBuilder.buildDirective(def),
   );
@@ -207,6 +188,10 @@ export function buildASTSchema(
     directives.push(GraphQLDeprecatedDirective);
   }
 
+  if (!directives.some(directive => directive.name === 'iam')) {
+    directives.push(GraphQLIAMDirective);
+  }
+
   // Note: While this could make early assertions to get the correctly
   // typed values below, that would throw immediately while type system
   // validation with validateSchema() will produce more actionable results.
@@ -220,7 +205,7 @@ export function buildASTSchema(
     subscription: operationTypes.subscription
       ? (definitionBuilder.buildType(operationTypes.subscription): any)
       : null,
-    types,
+    types: typeDefs.map(node => definitionBuilder.buildType(node)),
     directives,
     astNode: schemaDef,
     assumeValid: options && options.assumeValid,
@@ -229,7 +214,7 @@ export function buildASTSchema(
 
   function getOperationTypes(schema: SchemaDefinitionNode) {
     const opTypes = {};
-    schema.operationTypes.forEach(operationType => {
+    for (const operationType of schema.operationTypes) {
       const typeName = operationType.type.name.value;
       const operation = operationType.operation;
       if (opTypes[operation]) {
@@ -241,7 +226,7 @@ export function buildASTSchema(
         );
       }
       opTypes[operation] = operationType.type;
-    });
+    }
     return opTypes;
   }
 }
@@ -270,12 +255,6 @@ export class ASTDefinitionBuilder {
     );
   }
 
-  buildTypes(
-    nodes: $ReadOnlyArray<NamedTypeNode | TypeDefinitionNode>,
-  ): Array<GraphQLNamedType> {
-    return nodes.map(node => this.buildType(node));
-  }
-
   buildType(node: NamedTypeNode | TypeDefinitionNode): GraphQLNamedType {
     const typeName = node.name.value;
     if (!this._cache[typeName]) {
@@ -292,8 +271,16 @@ export class ASTDefinitionBuilder {
   }
 
   _buildWrappedType(typeNode: TypeNode): GraphQLType {
-    const typeDef = this.buildType(getNamedTypeNode(typeNode));
-    return buildWrappedType(typeDef, typeNode);
+    if (typeNode.kind === Kind.LIST_TYPE) {
+      return GraphQLList(this._buildWrappedType(typeNode.type));
+    }
+    if (typeNode.kind === Kind.NON_NULL_TYPE) {
+      return GraphQLNonNull(
+        // Note: GraphQLNonNull constructor validates this type
+        (this._buildWrappedType(typeNode.type): any),
+      );
+    }
+    return this.buildType(typeNode);
   }
 
   buildDirective(directiveNode: DirectiveDefinitionNode): GraphQLDirective {
@@ -319,6 +306,7 @@ export class ASTDefinitionBuilder {
       description: getDescription(field, this._options),
       args: field.arguments && this._makeInputValues(field.arguments),
       deprecationReason: getDeprecationReason(field),
+      iamName: getIAMName(field),
       astNode: field,
     };
   }
@@ -365,16 +353,17 @@ export class ASTDefinitionBuilder {
   }
 
   _makeTypeDef(def: ObjectTypeDefinitionNode) {
-    const typeName = def.name.value;
-    const interfaces = def.interfaces;
+    const interfaces: ?$ReadOnlyArray<NamedTypeNode> = def.interfaces;
     return new GraphQLObjectType({
-      name: typeName,
+      name: def.name.value,
       description: getDescription(def, this._options),
       fields: () => this._makeFieldDefMap(def),
       // Note: While this could make early assertions to get the correctly
       // typed values, that would throw immediately while type system
       // validation with validateSchema() will produce more actionable results.
-      interfaces: interfaces ? () => (this.buildTypes(interfaces): any) : [],
+      interfaces: interfaces
+        ? () => interfaces.map(ref => (this.buildType(ref): any))
+        : [],
       astNode: def,
     });
   }
@@ -428,13 +417,14 @@ export class ASTDefinitionBuilder {
   }
 
   _makeUnionDef(def: UnionTypeDefinitionNode) {
+    const types: ?$ReadOnlyArray<NamedTypeNode> = def.types;
     return new GraphQLUnionType({
       name: def.name.value,
       description: getDescription(def, this._options),
       // Note: While this could make assertions to get the correctly typed
       // values below, that would throw immediately while type system
       // validation with validateSchema() will produce more actionable results.
-      types: def.types ? (this.buildTypes(def.types): any) : [],
+      types: types ? () => types.map(ref => (this.buildType(ref): any)) : [],
       astNode: def,
     });
   }
@@ -469,8 +459,20 @@ function getDeprecationReason(
   return deprecated && (deprecated.reason: any);
 }
 
+/**
+ * Given a field or enum value node, returns the string value for the
+ * iam access key (i.e. its name).
+ */
+function getIAMName(
+  node: EnumValueDefinitionNode | FieldDefinitionNode,
+): ?string {
+  const iam = getDirectiveValues(GraphQLIAMDirective, node);
+  return iam && (iam.name: any);
+}
+
 /**
  * Given an ast node, returns its string description.
+ * @deprecated: provided to ease adoption and will be removed in v16.
  *
  * Accepts options as a second argument:
  *
diff --git a/utilities/buildASTSchema.mjs b/utilities/buildASTSchema.mjs
index d07fba4..1d2bc5e 100644
--- a/utilities/buildASTSchema.mjs
+++ b/utilities/buildASTSchema.mjs
@@ -11,39 +11,18 @@ function _defineProperty(obj, key, value) { if (key in obj) { Object.definePrope
 import keyMap from '../jsutils/keyMap';
 import keyValMap from '../jsutils/keyValMap';
 import { valueFromAST } from './valueFromAST';
+import { assertValidSDL } from '../validation/validate';
 import blockStringValue from '../language/blockStringValue';
 import { TokenKind } from '../language/lexer';
 import { parse } from '../language/parser';
 import { getDirectiveValues } from '../execution/values';
 import { Kind } from '../language/kinds';
-import { assertNullableType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';
-import { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';
+import { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';
+import { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective, GraphQLIAMDirective } from '../type/directives';
 import { introspectionTypes } from '../type/introspection';
 import { specifiedScalarTypes } from '../type/scalars';
 import { GraphQLSchema } from '../type/schema';
 
-function buildWrappedType(innerType, inputTypeNode) {
-  if (inputTypeNode.kind === Kind.LIST_TYPE) {
-    return GraphQLList(buildWrappedType(innerType, inputTypeNode.type));
-  }
-
-  if (inputTypeNode.kind === Kind.NON_NULL_TYPE) {
-    var wrappedType = buildWrappedType(innerType, inputTypeNode.type);
-    return GraphQLNonNull(assertNullableType(wrappedType));
-  }
-
-  return innerType;
-}
-
-function getNamedTypeNode(typeNode) {
-  var namedType = typeNode;
-
-  while (namedType.kind === Kind.LIST_TYPE || namedType.kind === Kind.NON_NULL_TYPE) {
-    namedType = namedType.type;
-  }
-
-  return namedType;
-}
 /**
  * This takes the ast of a schema document produced by the parse function in
  * src/language/parser.js.
@@ -60,13 +39,15 @@ function getNamedTypeNode(typeNode) {
  *        Provide true to use preceding comments as the description.
  *
  */
-
-
 export function buildASTSchema(ast, options) {
   if (!ast || ast.kind !== Kind.DOCUMENT) {
     throw new Error('Must provide a document ast.');
   }
 
+  if (!options || !(options.assumeValid || options.assumeValidSDL)) {
+    assertValidSDL(ast);
+  }
+
   var schemaDef;
   var typeDefs = [];
   var nodeMap = Object.create(null);
@@ -77,10 +58,6 @@ export function buildASTSchema(ast, options) {
 
     switch (d.kind) {
       case Kind.SCHEMA_DEFINITION:
-        if (schemaDef) {
-          throw new Error('Must provide only one schema definition.');
-        }
-
         schemaDef = d;
         break;
 
@@ -114,7 +91,6 @@ export function buildASTSchema(ast, options) {
   var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeRef) {
     throw new Error("Type \"".concat(typeRef.name.value, "\" not found in document."));
   });
-  var types = definitionBuilder.buildTypes(typeDefs);
   var directives = directiveDefs.map(function (def) {
     return definitionBuilder.buildDirective(def);
   }); // If specified directives were not explicitly declared, add them.
@@ -135,6 +111,12 @@ export function buildASTSchema(ast, options) {
     return directive.name === 'deprecated';
   })) {
     directives.push(GraphQLDeprecatedDirective);
+  }
+
+  if (!directives.some(function (directive) {
+    return directive.name === 'iam';
+  })) {
+    directives.push(GraphQLIAMDirective);
   } // Note: While this could make early assertions to get the correctly
   // typed values below, that would throw immediately while type system
   // validation with validateSchema() will produce more actionable results.
@@ -144,7 +126,9 @@ export function buildASTSchema(ast, options) {
     query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,
     mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,
     subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,
-    types: types,
+    types: typeDefs.map(function (node) {
+      return definitionBuilder.buildType(node);
+    }),
     directives: directives,
     astNode: schemaDef,
     assumeValid: options && options.assumeValid,
@@ -153,20 +137,41 @@ export function buildASTSchema(ast, options) {
 
   function getOperationTypes(schema) {
     var opTypes = {};
-    schema.operationTypes.forEach(function (operationType) {
-      var typeName = operationType.type.name.value;
-      var operation = operationType.operation;
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
+    try {
+      for (var _iterator = schema.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+        var operationType = _step.value;
+        var _typeName = operationType.type.name.value;
+        var operation = operationType.operation;
+
+        if (opTypes[operation]) {
+          throw new Error("Must provide only one ".concat(operation, " type in schema."));
+        }
 
-      if (opTypes[operation]) {
-        throw new Error("Must provide only one ".concat(operation, " type in schema."));
-      }
+        if (!nodeMap[_typeName]) {
+          throw new Error("Specified ".concat(operation, " type \"").concat(_typeName, "\" not found in document."));
+        }
 
-      if (!nodeMap[typeName]) {
-        throw new Error("Specified ".concat(operation, " type \"").concat(typeName, "\" not found in document."));
+        opTypes[operation] = operationType.type;
+      }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return != null) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
       }
+    }
 
-      opTypes[operation] = operationType.type;
-    });
     return opTypes;
   }
 }
@@ -193,14 +198,6 @@ function () {
 
   var _proto = ASTDefinitionBuilder.prototype;
 
-  _proto.buildTypes = function buildTypes(nodes) {
-    var _this = this;
-
-    return nodes.map(function (node) {
-      return _this.buildType(node);
-    });
-  };
-
   _proto.buildType = function buildType(node) {
     var typeName = node.name.value;
 
@@ -217,8 +214,16 @@ function () {
   };
 
   _proto._buildWrappedType = function _buildWrappedType(typeNode) {
-    var typeDef = this.buildType(getNamedTypeNode(typeNode));
-    return buildWrappedType(typeDef, typeNode);
+    if (typeNode.kind === Kind.LIST_TYPE) {
+      return GraphQLList(this._buildWrappedType(typeNode.type));
+    }
+
+    if (typeNode.kind === Kind.NON_NULL_TYPE) {
+      return GraphQLNonNull( // Note: GraphQLNonNull constructor validates this type
+      this._buildWrappedType(typeNode.type));
+    }
+
+    return this.buildType(typeNode);
   };
 
   _proto.buildDirective = function buildDirective(directiveNode) {
@@ -242,6 +247,7 @@ function () {
       description: getDescription(field, this._options),
       args: field.arguments && this._makeInputValues(field.arguments),
       deprecationReason: getDeprecationReason(field),
+      iamName: getIAMName(field),
       astNode: field
     };
   };
@@ -294,54 +300,55 @@ function () {
   };
 
   _proto._makeTypeDef = function _makeTypeDef(def) {
-    var _this2 = this;
+    var _this = this;
 
-    var typeName = def.name.value;
     var interfaces = def.interfaces;
     return new GraphQLObjectType({
-      name: typeName,
+      name: def.name.value,
       description: getDescription(def, this._options),
       fields: function fields() {
-        return _this2._makeFieldDefMap(def);
+        return _this._makeFieldDefMap(def);
       },
       // Note: While this could make early assertions to get the correctly
       // typed values, that would throw immediately while type system
       // validation with validateSchema() will produce more actionable results.
       interfaces: interfaces ? function () {
-        return _this2.buildTypes(interfaces);
+        return interfaces.map(function (ref) {
+          return _this.buildType(ref);
+        });
       } : [],
       astNode: def
     });
   };
 
   _proto._makeFieldDefMap = function _makeFieldDefMap(def) {
-    var _this3 = this;
+    var _this2 = this;
 
     return def.fields ? keyValMap(def.fields, function (field) {
       return field.name.value;
     }, function (field) {
-      return _this3.buildField(field);
+      return _this2.buildField(field);
     }) : {};
   };
 
   _proto._makeInputValues = function _makeInputValues(values) {
-    var _this4 = this;
+    var _this3 = this;
 
     return keyValMap(values, function (value) {
       return value.name.value;
     }, function (value) {
-      return _this4.buildInputField(value);
+      return _this3.buildInputField(value);
     });
   };
 
   _proto._makeInterfaceDef = function _makeInterfaceDef(def) {
-    var _this5 = this;
+    var _this4 = this;
 
     return new GraphQLInterfaceType({
       name: def.name.value,
       description: getDescription(def, this._options),
       fields: function fields() {
-        return _this5._makeFieldDefMap(def);
+        return _this4._makeFieldDefMap(def);
       },
       astNode: def
     });
@@ -357,23 +364,30 @@ function () {
   };
 
   _proto._makeValueDefMap = function _makeValueDefMap(def) {
-    var _this6 = this;
+    var _this5 = this;
 
     return def.values ? keyValMap(def.values, function (enumValue) {
       return enumValue.name.value;
     }, function (enumValue) {
-      return _this6.buildEnumValue(enumValue);
+      return _this5.buildEnumValue(enumValue);
     }) : {};
   };
 
   _proto._makeUnionDef = function _makeUnionDef(def) {
+    var _this6 = this;
+
+    var types = def.types;
     return new GraphQLUnionType({
       name: def.name.value,
       description: getDescription(def, this._options),
       // Note: While this could make assertions to get the correctly typed
       // values below, that would throw immediately while type system
       // validation with validateSchema() will produce more actionable results.
-      types: def.types ? this.buildTypes(def.types) : [],
+      types: types ? function () {
+        return types.map(function (ref) {
+          return _this6.buildType(ref);
+        });
+      } : [],
       astNode: def
     });
   };
@@ -413,8 +427,19 @@ function getDeprecationReason(node) {
   var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
   return deprecated && deprecated.reason;
 }
+/**
+ * Given a field or enum value node, returns the string value for the
+ * iam access key (i.e. its name).
+ */
+
+
+function getIAMName(node) {
+  var iam = getDirectiveValues(GraphQLIAMDirective, node);
+  return iam && iam.name;
+}
 /**
  * Given an ast node, returns its string description.
+ * @deprecated: provided to ease adoption and will be removed in v16.
  *
  * Accepts options as a second argument:
  *
diff --git a/utilities/buildClientSchema.js b/utilities/buildClientSchema.js
index 350900b..9ac1a5a 100644
--- a/utilities/buildClientSchema.js
+++ b/utilities/buildClientSchema.js
@@ -17,8 +17,6 @@ var _parser = require("../language/parser");
 
 var _schema = require("../type/schema");
 
-var _directiveLocation = require("../language/directiveLocation");
-
 var _definition = require("../type/definition");
 
 var _directives = require("../type/directives");
@@ -271,7 +269,6 @@ function buildClientSchema(introspection, options) {
     var type = getInputType(inputValueIntrospection.type);
     var defaultValue = inputValueIntrospection.defaultValue ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;
     return {
-      name: inputValueIntrospection.name,
       description: inputValueIntrospection.description,
       type: type,
       defaultValue: defaultValue
@@ -279,10 +276,6 @@ function buildClientSchema(introspection, options) {
   }
 
   function buildDirective(directiveIntrospection) {
-    // Support deprecated `on****` fields for building `locations`, as this
-    // is used by GraphiQL which may need to support outdated servers.
-    var locations = directiveIntrospection.locations ? directiveIntrospection.locations.slice() : [].concat(!directiveIntrospection.onField ? [] : [_directiveLocation.DirectiveLocation.FIELD], !directiveIntrospection.onOperation ? [] : [_directiveLocation.DirectiveLocation.QUERY, _directiveLocation.DirectiveLocation.MUTATION, _directiveLocation.DirectiveLocation.SUBSCRIPTION], !directiveIntrospection.onFragment ? [] : [_directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION, _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD, _directiveLocation.DirectiveLocation.INLINE_FRAGMENT]);
-
     if (!directiveIntrospection.args) {
       throw new Error('Introspection result missing directive args: ' + JSON.stringify(directiveIntrospection));
     }
@@ -290,7 +283,7 @@ function buildClientSchema(introspection, options) {
     return new _directives.GraphQLDirective({
       name: directiveIntrospection.name,
       description: directiveIntrospection.description,
-      locations: locations,
+      locations: directiveIntrospection.locations.slice(),
       args: buildInputValueDefMap(directiveIntrospection.args)
     });
   } // Iterate through all types, getting the type definition for each, ensuring
diff --git a/utilities/buildClientSchema.js.flow b/utilities/buildClientSchema.js.flow
index b86b9bf..1fa0774 100644
--- a/utilities/buildClientSchema.js.flow
+++ b/utilities/buildClientSchema.js.flow
@@ -14,8 +14,6 @@ import { valueFromAST } from './valueFromAST';
 import { parseValue } from '../language/parser';
 import { GraphQLSchema } from '../type/schema';
 
-import { DirectiveLocation } from '../language/directiveLocation';
-
 import {
   isInputType,
   isOutputType,
@@ -333,7 +331,6 @@ export function buildClientSchema(
       ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type)
       : undefined;
     return {
-      name: inputValueIntrospection.name,
       description: inputValueIntrospection.description,
       type,
       defaultValue,
@@ -341,27 +338,6 @@ export function buildClientSchema(
   }
 
   function buildDirective(directiveIntrospection) {
-    // Support deprecated `on****` fields for building `locations`, as this
-    // is used by GraphiQL which may need to support outdated servers.
-    const locations = directiveIntrospection.locations
-      ? directiveIntrospection.locations.slice()
-      : [].concat(
-          !directiveIntrospection.onField ? [] : [DirectiveLocation.FIELD],
-          !directiveIntrospection.onOperation
-            ? []
-            : [
-                DirectiveLocation.QUERY,
-                DirectiveLocation.MUTATION,
-                DirectiveLocation.SUBSCRIPTION,
-              ],
-          !directiveIntrospection.onFragment
-            ? []
-            : [
-                DirectiveLocation.FRAGMENT_DEFINITION,
-                DirectiveLocation.FRAGMENT_SPREAD,
-                DirectiveLocation.INLINE_FRAGMENT,
-              ],
-        );
     if (!directiveIntrospection.args) {
       throw new Error(
         'Introspection result missing directive args: ' +
@@ -371,7 +347,7 @@ export function buildClientSchema(
     return new GraphQLDirective({
       name: directiveIntrospection.name,
       description: directiveIntrospection.description,
-      locations,
+      locations: directiveIntrospection.locations.slice(),
       args: buildInputValueDefMap(directiveIntrospection.args),
     });
   }
diff --git a/utilities/buildClientSchema.mjs b/utilities/buildClientSchema.mjs
index 06b2cee..a7be3f6 100644
--- a/utilities/buildClientSchema.mjs
+++ b/utilities/buildClientSchema.mjs
@@ -12,7 +12,6 @@ import keyValMap from '../jsutils/keyValMap';
 import { valueFromAST } from './valueFromAST';
 import { parseValue } from '../language/parser';
 import { GraphQLSchema } from '../type/schema';
-import { DirectiveLocation } from '../language/directiveLocation';
 import { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from '../type/definition';
 import { GraphQLDirective } from '../type/directives';
 import { introspectionTypes, TypeKind } from '../type/introspection';
@@ -251,7 +250,6 @@ export function buildClientSchema(introspection, options) {
     var type = getInputType(inputValueIntrospection.type);
     var defaultValue = inputValueIntrospection.defaultValue ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;
     return {
-      name: inputValueIntrospection.name,
       description: inputValueIntrospection.description,
       type: type,
       defaultValue: defaultValue
@@ -259,10 +257,6 @@ export function buildClientSchema(introspection, options) {
   }
 
   function buildDirective(directiveIntrospection) {
-    // Support deprecated `on****` fields for building `locations`, as this
-    // is used by GraphiQL which may need to support outdated servers.
-    var locations = directiveIntrospection.locations ? directiveIntrospection.locations.slice() : [].concat(!directiveIntrospection.onField ? [] : [DirectiveLocation.FIELD], !directiveIntrospection.onOperation ? [] : [DirectiveLocation.QUERY, DirectiveLocation.MUTATION, DirectiveLocation.SUBSCRIPTION], !directiveIntrospection.onFragment ? [] : [DirectiveLocation.FRAGMENT_DEFINITION, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT]);
-
     if (!directiveIntrospection.args) {
       throw new Error('Introspection result missing directive args: ' + JSON.stringify(directiveIntrospection));
     }
@@ -270,7 +264,7 @@ export function buildClientSchema(introspection, options) {
     return new GraphQLDirective({
       name: directiveIntrospection.name,
       description: directiveIntrospection.description,
-      locations: locations,
+      locations: directiveIntrospection.locations.slice(),
       args: buildInputValueDefMap(directiveIntrospection.args)
     });
   } // Iterate through all types, getting the type definition for each, ensuring
diff --git a/utilities/coerceValue.js b/utilities/coerceValue.js
index 40f6da8..bb2a6f8 100644
--- a/utilities/coerceValue.js
+++ b/utilities/coerceValue.js
@@ -82,19 +82,18 @@ function coerceValue(value, type, blameNode, path) {
     var itemType = type.ofType;
 
     if ((0, _iterall.isCollection)(value)) {
-      var _errors;
-
+      var errors;
       var coercedValue = [];
       (0, _iterall.forEach)(value, function (itemValue, index) {
         var coercedItem = coerceValue(itemValue, itemType, blameNode, atPath(path, index));
 
         if (coercedItem.errors) {
-          _errors = add(_errors, coercedItem.errors);
-        } else if (!_errors) {
+          errors = add(errors, coercedItem.errors);
+        } else if (!errors) {
           coercedValue.push(coercedItem.value);
         }
       });
-      return _errors ? ofErrors(_errors) : ofValue(coercedValue);
+      return errors ? ofErrors(errors) : ofValue(coercedValue);
     } // Lists accept a non-list value as a list of one.
 
 
@@ -107,7 +106,7 @@ function coerceValue(value, type, blameNode, path) {
       return ofErrors([coercionError("Expected type ".concat(type.name, " to be an object"), blameNode, path)]);
     }
 
-    var _errors2;
+    var _errors;
 
     var _coercedValue = {};
     var fields = type.getFields(); // Ensure every defined field is valid.
@@ -121,14 +120,14 @@ function coerceValue(value, type, blameNode, path) {
           if (!(0, _isInvalid.default)(field.defaultValue)) {
             _coercedValue[fieldName] = field.defaultValue;
           } else if ((0, _definition.isNonNullType)(field.type)) {
-            _errors2 = add(_errors2, coercionError("Field ".concat(printPath(atPath(path, fieldName)), " of required ") + "type ".concat((0, _inspect.default)(field.type), " was not provided"), blameNode));
+            _errors = add(_errors, coercionError("Field ".concat(printPath(atPath(path, fieldName)), " of required ") + "type ".concat((0, _inspect.default)(field.type), " was not provided"), blameNode));
           }
         } else {
           var coercedField = coerceValue(fieldValue, field.type, blameNode, atPath(path, fieldName));
 
           if (coercedField.errors) {
-            _errors2 = add(_errors2, coercedField.errors);
-          } else if (!_errors2) {
+            _errors = add(_errors, coercedField.errors);
+          } else if (!_errors) {
             _coercedValue[fieldName] = coercedField.value;
           }
         }
@@ -143,12 +142,12 @@ function coerceValue(value, type, blameNode, path) {
 
           var _didYouMean = _suggestions.length !== 0 ? "did you mean ".concat((0, _orList.default)(_suggestions), "?") : undefined;
 
-          _errors2 = add(_errors2, coercionError("Field \"".concat(_fieldName, "\" is not defined by type ").concat(type.name), blameNode, path, _didYouMean));
+          _errors = add(_errors, coercionError("Field \"".concat(_fieldName, "\" is not defined by type ").concat(type.name), blameNode, path, _didYouMean));
         }
       }
     }
 
-    return _errors2 ? ofErrors(_errors2) : ofValue(_coercedValue);
+    return _errors ? ofErrors(_errors) : ofValue(_coercedValue);
   }
   /* istanbul ignore next */
 
diff --git a/utilities/coerceValue.mjs b/utilities/coerceValue.mjs
index c6f3eaa..656ee25 100644
--- a/utilities/coerceValue.mjs
+++ b/utilities/coerceValue.mjs
@@ -75,19 +75,18 @@ export function coerceValue(value, type, blameNode, path) {
     var itemType = type.ofType;
 
     if (isCollection(value)) {
-      var _errors;
-
+      var errors;
       var coercedValue = [];
       forEach(value, function (itemValue, index) {
         var coercedItem = coerceValue(itemValue, itemType, blameNode, atPath(path, index));
 
         if (coercedItem.errors) {
-          _errors = add(_errors, coercedItem.errors);
-        } else if (!_errors) {
+          errors = add(errors, coercedItem.errors);
+        } else if (!errors) {
           coercedValue.push(coercedItem.value);
         }
       });
-      return _errors ? ofErrors(_errors) : ofValue(coercedValue);
+      return errors ? ofErrors(errors) : ofValue(coercedValue);
     } // Lists accept a non-list value as a list of one.
 
 
@@ -100,7 +99,7 @@ export function coerceValue(value, type, blameNode, path) {
       return ofErrors([coercionError("Expected type ".concat(type.name, " to be an object"), blameNode, path)]);
     }
 
-    var _errors2;
+    var _errors;
 
     var _coercedValue = {};
     var fields = type.getFields(); // Ensure every defined field is valid.
@@ -114,14 +113,14 @@ export function coerceValue(value, type, blameNode, path) {
           if (!isInvalid(field.defaultValue)) {
             _coercedValue[fieldName] = field.defaultValue;
           } else if (isNonNullType(field.type)) {
-            _errors2 = add(_errors2, coercionError("Field ".concat(printPath(atPath(path, fieldName)), " of required ") + "type ".concat(inspect(field.type), " was not provided"), blameNode));
+            _errors = add(_errors, coercionError("Field ".concat(printPath(atPath(path, fieldName)), " of required ") + "type ".concat(inspect(field.type), " was not provided"), blameNode));
           }
         } else {
           var coercedField = coerceValue(fieldValue, field.type, blameNode, atPath(path, fieldName));
 
           if (coercedField.errors) {
-            _errors2 = add(_errors2, coercedField.errors);
-          } else if (!_errors2) {
+            _errors = add(_errors, coercedField.errors);
+          } else if (!_errors) {
             _coercedValue[fieldName] = coercedField.value;
           }
         }
@@ -136,12 +135,12 @@ export function coerceValue(value, type, blameNode, path) {
 
           var _didYouMean = _suggestions.length !== 0 ? "did you mean ".concat(orList(_suggestions), "?") : undefined;
 
-          _errors2 = add(_errors2, coercionError("Field \"".concat(_fieldName, "\" is not defined by type ").concat(type.name), blameNode, path, _didYouMean));
+          _errors = add(_errors, coercionError("Field \"".concat(_fieldName, "\" is not defined by type ").concat(type.name), blameNode, path, _didYouMean));
         }
       }
     }
 
-    return _errors2 ? ofErrors(_errors2) : ofValue(_coercedValue);
+    return _errors ? ofErrors(_errors) : ofValue(_coercedValue);
   }
   /* istanbul ignore next */
 
diff --git a/utilities/extendSchema.js b/utilities/extendSchema.js
index 48292a5..6bbfc16 100644
--- a/utilities/extendSchema.js
+++ b/utilities/extendSchema.js
@@ -15,12 +15,16 @@ var _objectValues = _interopRequireDefault(require("../jsutils/objectValues"));
 
 var _buildASTSchema = require("./buildASTSchema");
 
+var _validate = require("../validation/validate");
+
 var _GraphQLError = require("../error/GraphQLError");
 
 var _schema = require("../type/schema");
 
 var _introspection = require("../type/introspection");
 
+var _scalars = require("../type/scalars");
+
 var _definition = require("../type/definition");
 
 var _directives = require("../type/directives");
@@ -29,14 +33,9 @@ var _kinds = require("../language/kinds");
 
 function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
 
-/**
- * Copyright (c) 2015-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict
- */
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
 
 /**
  * Produces a new schema given an existing schema and a document which may
@@ -58,13 +57,19 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
  */
 function extendSchema(schema, documentAST, options) {
   !(0, _schema.isSchema)(schema) ? (0, _invariant.default)(0, 'Must provide valid GraphQLSchema') : void 0;
-  !(documentAST && documentAST.kind === _kinds.Kind.DOCUMENT) ? (0, _invariant.default)(0, 'Must provide valid Document AST') : void 0; // Collect the type definitions and extensions found in the document.
+  !(documentAST && documentAST.kind === _kinds.Kind.DOCUMENT) ? (0, _invariant.default)(0, 'Must provide valid Document AST') : void 0;
+
+  if (!options || !(options.assumeValid || options.assumeValidSDL)) {
+    (0, _validate.assertValidSDLExtension)(documentAST, schema);
+  } // Collect the type definitions and extensions found in the document.
+
 
   var typeDefinitionMap = Object.create(null);
   var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can
   // have the same name. For example, a type named "skip".
 
-  var directiveDefinitions = []; // Schema extensions are collected which may add additional operation types.
+  var directiveDefinitions = [];
+  var schemaDef; // Schema extensions are collected which may add additional operation types.
 
   var schemaExtensions = [];
 
@@ -73,8 +78,8 @@ function extendSchema(schema, documentAST, options) {
 
     switch (def.kind) {
       case _kinds.Kind.SCHEMA_DEFINITION:
-        // Sanity check that a schema extension is not defining a new schema
-        throw new _GraphQLError.GraphQLError('Cannot define a new schema within a schema extension.', [def]);
+        schemaDef = def;
+        break;
 
       case _kinds.Kind.SCHEMA_EXTENSION:
         schemaExtensions.push(def);
@@ -97,6 +102,7 @@ function extendSchema(schema, documentAST, options) {
         typeDefinitionMap[typeName] = def;
         break;
 
+      case _kinds.Kind.SCALAR_TYPE_EXTENSION:
       case _kinds.Kind.OBJECT_TYPE_EXTENSION:
       case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
       case _kinds.Kind.ENUM_TYPE_EXTENSION:
@@ -126,15 +132,12 @@ function extendSchema(schema, documentAST, options) {
 
         directiveDefinitions.push(def);
         break;
-
-      case _kinds.Kind.SCALAR_TYPE_EXTENSION:
-        throw new Error("The ".concat(def.kind, " kind is not yet supported by extendSchema()."));
     }
   } // If this document contains no new types, extensions, or directives then
   // return the same unmodified GraphQLSchema instance.
 
 
-  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0) {
+  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0 && !schemaDef) {
     return schema;
   }
 
@@ -154,43 +157,102 @@ function extendSchema(schema, documentAST, options) {
     query: extendMaybeNamedType(schema.getQueryType()),
     mutation: extendMaybeNamedType(schema.getMutationType()),
     subscription: extendMaybeNamedType(schema.getSubscriptionType())
-  }; // Then, incorporate all schema extensions.
+  };
 
-  schemaExtensions.forEach(function (schemaExtension) {
-    if (schemaExtension.operationTypes) {
-      schemaExtension.operationTypes.forEach(function (operationType) {
-        var operation = operationType.operation;
+  if (schemaDef) {
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
+    try {
+      for (var _iterator = schemaDef.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+        var _ref2 = _step.value;
+        var operation = _ref2.operation,
+            type = _ref2.type;
 
         if (operationTypes[operation]) {
           throw new Error("Must provide only one ".concat(operation, " type in schema."));
-        }
-
-        var typeRef = operationType.type; // Note: While this could make early assertions to get the correctly
+        } // Note: While this could make early assertions to get the correctly
         // typed values, that would throw immediately while type system
         // validation with validateSchema() will produce more actionable results.
 
-        operationTypes[operation] = astBuilder.buildType(typeRef);
-      });
+
+        operationTypes[operation] = astBuilder.buildType(type);
+      }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return != null) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
     }
-  });
+  } // Then, incorporate schema definition and all schema extensions.
+
+
+  for (var _i = 0; _i < schemaExtensions.length; _i++) {
+    var schemaExtension = schemaExtensions[_i];
+
+    if (schemaExtension.operationTypes) {
+      var _iteratorNormalCompletion12 = true;
+      var _didIteratorError12 = false;
+      var _iteratorError12 = undefined;
+
+      try {
+        for (var _iterator12 = schemaExtension.operationTypes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
+          var _ref4 = _step12.value;
+          var operation = _ref4.operation,
+              type = _ref4.type;
+
+          if (operationTypes[operation]) {
+            throw new Error("Must provide only one ".concat(operation, " type in schema."));
+          } // Note: While this could make early assertions to get the correctly
+          // typed values, that would throw immediately while type system
+          // validation with validateSchema() will produce more actionable results.
+
+
+          operationTypes[operation] = astBuilder.buildType(type);
+        }
+      } catch (err) {
+        _didIteratorError12 = true;
+        _iteratorError12 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
+            _iterator12.return();
+          }
+        } finally {
+          if (_didIteratorError12) {
+            throw _iteratorError12;
+          }
+        }
+      }
+    }
+  }
+
   var schemaExtensionASTNodes = schemaExtensions ? schema.extensionASTNodes ? schema.extensionASTNodes.concat(schemaExtensions) : schemaExtensions : schema.extensionASTNodes;
   var types = (0, _objectValues.default)(schema.getTypeMap()).map(function (type) {
     return extendNamedType(type);
-  }).concat(astBuilder.buildTypes((0, _objectValues.default)(typeDefinitionMap))); // Support both original legacy names and extended legacy names.
+  }).concat((0, _objectValues.default)(typeDefinitionMap).map(function (type) {
+    return astBuilder.buildType(type);
+  })); // Support both original legacy names and extended legacy names.
 
   var allowedLegacyNames = schema.__allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.
 
 
-  return new _schema.GraphQLSchema({
-    query: operationTypes.query,
-    mutation: operationTypes.mutation,
-    subscription: operationTypes.subscription,
+  return new _schema.GraphQLSchema(_objectSpread({}, operationTypes, {
     types: types,
     directives: getMergedDirectives(),
     astNode: schema.astNode,
     extensionASTNodes: schemaExtensionASTNodes,
     allowedLegacyNames: allowedLegacyNames
-  }); // Below are functions used for producing this schema that have closed over
+  })); // Below are functions used for producing this schema that have closed over
   // this scope and have access to the schema, cache, and newly defined types.
 
   function getMergedDirectives() {
@@ -206,15 +268,17 @@ function extendSchema(schema, documentAST, options) {
   }
 
   function extendNamedType(type) {
-    if ((0, _introspection.isIntrospectionType)(type)) {
-      // Introspection types are not extended.
+    if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
+      // Builtin types are not extended.
       return type;
     }
 
     var name = type.name;
 
     if (!extendTypeCache[name]) {
-      if ((0, _definition.isObjectType)(type)) {
+      if ((0, _definition.isScalarType)(type)) {
+        extendTypeCache[name] = extendScalarType(type);
+      } else if ((0, _definition.isObjectType)(type)) {
         extendTypeCache[name] = extendObjectType(type);
       } else if ((0, _definition.isInterfaceType)(type)) {
         extendTypeCache[name] = extendInterfaceType(type);
@@ -224,9 +288,6 @@ function extendSchema(schema, documentAST, options) {
         extendTypeCache[name] = extendEnumType(type);
       } else if ((0, _definition.isInputObjectType)(type)) {
         extendTypeCache[name] = extendInputObjectType(type);
-      } else {
-        // This type is not yet extendable.
-        extendTypeCache[name] = type;
       }
     }
 
@@ -243,14 +304,6 @@ function extendSchema(schema, documentAST, options) {
     });
   }
 
-  function getExtendedType(type) {
-    if (!extendTypeCache[type.name]) {
-      extendTypeCache[type.name] = extendType(type);
-    }
-
-    return extendTypeCache[type.name];
-  }
-
   function extendInputObjectType(type) {
     var name = type.name;
     var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;
@@ -268,30 +321,75 @@ function extendSchema(schema, documentAST, options) {
   function extendInputFieldMap(type) {
     var newFieldMap = Object.create(null);
     var oldFieldMap = type.getFields();
-    Object.keys(oldFieldMap).forEach(function (fieldName) {
-      var field = oldFieldMap[fieldName];
-      newFieldMap[fieldName] = {
-        description: field.description,
-        type: extendType(field.type),
-        defaultValue: field.defaultValue,
-        astNode: field.astNode
+
+    var _arr = Object.keys(oldFieldMap);
+
+    for (var _i2 = 0; _i2 < _arr.length; _i2++) {
+      var _fieldName = _arr[_i2];
+      var _field = oldFieldMap[_fieldName];
+      newFieldMap[_fieldName] = {
+        description: _field.description,
+        type: extendType(_field.type),
+        defaultValue: _field.defaultValue,
+        astNode: _field.astNode
       };
-    }); // If there are any extensions to the fields, apply those here.
+    } // If there are any extensions to the fields, apply those here.
+
 
     var extensions = typeExtensionsMap[type.name];
 
     if (extensions) {
-      extensions.forEach(function (extension) {
-        extension.fields.forEach(function (field) {
-          var fieldName = field.name.value;
-
-          if (oldFieldMap[fieldName]) {
-            throw new _GraphQLError.GraphQLError("Field \"".concat(type.name, ".").concat(fieldName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [field]);
+      var _iteratorNormalCompletion2 = true;
+      var _didIteratorError2 = false;
+      var _iteratorError2 = undefined;
+
+      try {
+        for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+          var extension = _step2.value;
+          var _iteratorNormalCompletion3 = true;
+          var _didIteratorError3 = false;
+          var _iteratorError3 = undefined;
+
+          try {
+            for (var _iterator3 = extension.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
+              var field = _step3.value;
+              var fieldName = field.name.value;
+
+              if (oldFieldMap[fieldName]) {
+                throw new _GraphQLError.GraphQLError("Field \"".concat(type.name, ".").concat(fieldName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [field]);
+              }
+
+              newFieldMap[fieldName] = astBuilder.buildInputField(field);
+            }
+          } catch (err) {
+            _didIteratorError3 = true;
+            _iteratorError3 = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
+                _iterator3.return();
+              }
+            } finally {
+              if (_didIteratorError3) {
+                throw _iteratorError3;
+              }
+            }
           }
-
-          newFieldMap[fieldName] = astBuilder.buildInputField(field);
-        });
-      });
+        }
+      } catch (err) {
+        _didIteratorError2 = true;
+        _iteratorError2 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+            _iterator2.return();
+          }
+        } finally {
+          if (_didIteratorError2) {
+            throw _iteratorError2;
+          }
+        }
+      }
     }
 
     return newFieldMap;
@@ -314,36 +412,95 @@ function extendSchema(schema, documentAST, options) {
     var oldValueMap = (0, _keyMap.default)(type.getValues(), function (value) {
       return value.name;
     });
-    Object.keys(oldValueMap).forEach(function (valueName) {
-      var value = oldValueMap[valueName];
-      newValueMap[valueName] = {
-        name: value.name,
-        description: value.description,
-        value: value.value,
-        deprecationReason: value.deprecationReason,
-        astNode: value.astNode
+
+    var _arr2 = Object.keys(oldValueMap);
+
+    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {
+      var _valueName = _arr2[_i3];
+      var _value = oldValueMap[_valueName];
+      newValueMap[_valueName] = {
+        name: _value.name,
+        description: _value.description,
+        value: _value.value,
+        deprecationReason: _value.deprecationReason,
+        astNode: _value.astNode
       };
-    }); // If there are any extensions to the values, apply those here.
+    } // If there are any extensions to the values, apply those here.
+
 
     var extensions = typeExtensionsMap[type.name];
 
     if (extensions) {
-      extensions.forEach(function (extension) {
-        extension.values.forEach(function (value) {
-          var valueName = value.name.value;
-
-          if (oldValueMap[valueName]) {
-            throw new _GraphQLError.GraphQLError("Enum value \"".concat(type.name, ".").concat(valueName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [value]);
+      var _iteratorNormalCompletion4 = true;
+      var _didIteratorError4 = false;
+      var _iteratorError4 = undefined;
+
+      try {
+        for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
+          var extension = _step4.value;
+          var _iteratorNormalCompletion5 = true;
+          var _didIteratorError5 = false;
+          var _iteratorError5 = undefined;
+
+          try {
+            for (var _iterator5 = extension.values[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
+              var value = _step5.value;
+              var valueName = value.name.value;
+
+              if (oldValueMap[valueName]) {
+                throw new _GraphQLError.GraphQLError("Enum value \"".concat(type.name, ".").concat(valueName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [value]);
+              }
+
+              newValueMap[valueName] = astBuilder.buildEnumValue(value);
+            }
+          } catch (err) {
+            _didIteratorError5 = true;
+            _iteratorError5 = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
+                _iterator5.return();
+              }
+            } finally {
+              if (_didIteratorError5) {
+                throw _iteratorError5;
+              }
+            }
           }
-
-          newValueMap[valueName] = astBuilder.buildEnumValue(value);
-        });
-      });
+        }
+      } catch (err) {
+        _didIteratorError4 = true;
+        _iteratorError4 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
+            _iterator4.return();
+          }
+        } finally {
+          if (_didIteratorError4) {
+            throw _iteratorError4;
+          }
+        }
+      }
     }
 
     return newValueMap;
   }
 
+  function extendScalarType(type) {
+    var name = type.name;
+    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;
+    return new _definition.GraphQLScalarType({
+      name: name,
+      description: type.description,
+      astNode: type.astNode,
+      extensionASTNodes: extensionASTNodes,
+      serialize: type.serialize,
+      parseValue: type.parseValue,
+      parseLiteral: type.parseLiteral
+    });
+  }
+
   function extendObjectType(type) {
     var name = type.name;
     var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;
@@ -393,45 +550,131 @@ function extendSchema(schema, documentAST, options) {
   function extendUnionType(type) {
     var name = type.name;
     var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;
-    var unionTypes = type.getTypes().map(getExtendedType); // If there are any extensions to the union, apply those here.
-
-    var extensions = typeExtensionsMap[type.name];
-
-    if (extensions) {
-      extensions.forEach(function (extension) {
-        extension.types.forEach(function (namedType) {
-          // Note: While this could make early assertions to get the correctly
-          // typed values, that would throw immediately while type system
-          // validation with validateSchema() will produce more actionable results.
-          unionTypes.push(astBuilder.buildType(namedType));
-        });
-      });
-    }
-
     return new _definition.GraphQLUnionType({
       name: name,
       description: type.description,
-      types: unionTypes,
+      types: function types() {
+        return extendPossibleTypes(type);
+      },
       astNode: type.astNode,
       resolveType: type.resolveType,
       extensionASTNodes: extensionASTNodes
     });
   }
 
+  function extendPossibleTypes(type) {
+    var possibleTypes = type.getTypes().map(extendNamedType); // If there are any extensions to the union, apply those here.
+
+    var extensions = typeExtensionsMap[type.name];
+
+    if (extensions) {
+      var _iteratorNormalCompletion6 = true;
+      var _didIteratorError6 = false;
+      var _iteratorError6 = undefined;
+
+      try {
+        for (var _iterator6 = extensions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
+          var extension = _step6.value;
+          var _iteratorNormalCompletion7 = true;
+          var _didIteratorError7 = false;
+          var _iteratorError7 = undefined;
+
+          try {
+            for (var _iterator7 = extension.types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
+              var namedType = _step7.value;
+              // Note: While this could make early assertions to get the correctly
+              // typed values, that would throw immediately while type system
+              // validation with validateSchema() will produce more actionable results.
+              possibleTypes.push(astBuilder.buildType(namedType));
+            }
+          } catch (err) {
+            _didIteratorError7 = true;
+            _iteratorError7 = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
+                _iterator7.return();
+              }
+            } finally {
+              if (_didIteratorError7) {
+                throw _iteratorError7;
+              }
+            }
+          }
+        }
+      } catch (err) {
+        _didIteratorError6 = true;
+        _iteratorError6 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
+            _iterator6.return();
+          }
+        } finally {
+          if (_didIteratorError6) {
+            throw _iteratorError6;
+          }
+        }
+      }
+    }
+
+    return possibleTypes;
+  }
+
   function extendImplementedInterfaces(type) {
     var interfaces = type.getInterfaces().map(extendNamedType); // If there are any extensions to the interfaces, apply those here.
 
     var extensions = typeExtensionsMap[type.name];
 
     if (extensions) {
-      extensions.forEach(function (extension) {
-        extension.interfaces.forEach(function (namedType) {
-          // Note: While this could make early assertions to get the correctly
-          // typed values, that would throw immediately while type system
-          // validation with validateSchema() will produce more actionable results.
-          interfaces.push(astBuilder.buildType(namedType));
-        });
-      });
+      var _iteratorNormalCompletion8 = true;
+      var _didIteratorError8 = false;
+      var _iteratorError8 = undefined;
+
+      try {
+        for (var _iterator8 = extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
+          var extension = _step8.value;
+          var _iteratorNormalCompletion9 = true;
+          var _didIteratorError9 = false;
+          var _iteratorError9 = undefined;
+
+          try {
+            for (var _iterator9 = extension.interfaces[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
+              var namedType = _step9.value;
+              // Note: While this could make early assertions to get the correctly
+              // typed values, that would throw immediately while type system
+              // validation with validateSchema() will produce more actionable results.
+              interfaces.push(astBuilder.buildType(namedType));
+            }
+          } catch (err) {
+            _didIteratorError9 = true;
+            _iteratorError9 = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
+                _iterator9.return();
+              }
+            } finally {
+              if (_didIteratorError9) {
+                throw _iteratorError9;
+              }
+            }
+          }
+        }
+      } catch (err) {
+        _didIteratorError8 = true;
+        _iteratorError8 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
+            _iterator8.return();
+          }
+        } finally {
+          if (_didIteratorError8) {
+            throw _iteratorError8;
+          }
+        }
+      }
     }
 
     return interfaces;
@@ -440,32 +683,77 @@ function extendSchema(schema, documentAST, options) {
   function extendFieldMap(type) {
     var newFieldMap = Object.create(null);
     var oldFieldMap = type.getFields();
-    Object.keys(oldFieldMap).forEach(function (fieldName) {
-      var field = oldFieldMap[fieldName];
-      newFieldMap[fieldName] = {
-        description: field.description,
-        deprecationReason: field.deprecationReason,
-        type: extendType(field.type),
-        args: extendArgs(field.args),
-        astNode: field.astNode,
-        resolve: field.resolve
+
+    var _arr3 = Object.keys(oldFieldMap);
+
+    for (var _i4 = 0; _i4 < _arr3.length; _i4++) {
+      var _fieldName2 = _arr3[_i4];
+      var _field2 = oldFieldMap[_fieldName2];
+      newFieldMap[_fieldName2] = {
+        description: _field2.description,
+        deprecationReason: _field2.deprecationReason,
+        type: extendType(_field2.type),
+        args: extendArgs(_field2.args),
+        astNode: _field2.astNode,
+        resolve: _field2.resolve
       };
-    }); // If there are any extensions to the fields, apply those here.
+    } // If there are any extensions to the fields, apply those here.
+
 
     var extensions = typeExtensionsMap[type.name];
 
     if (extensions) {
-      extensions.forEach(function (extension) {
-        extension.fields.forEach(function (field) {
-          var fieldName = field.name.value;
-
-          if (oldFieldMap[fieldName]) {
-            throw new _GraphQLError.GraphQLError("Field \"".concat(type.name, ".").concat(fieldName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [field]);
+      var _iteratorNormalCompletion10 = true;
+      var _didIteratorError10 = false;
+      var _iteratorError10 = undefined;
+
+      try {
+        for (var _iterator10 = extensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
+          var extension = _step10.value;
+          var _iteratorNormalCompletion11 = true;
+          var _didIteratorError11 = false;
+          var _iteratorError11 = undefined;
+
+          try {
+            for (var _iterator11 = extension.fields[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
+              var field = _step11.value;
+              var fieldName = field.name.value;
+
+              if (oldFieldMap[fieldName]) {
+                throw new _GraphQLError.GraphQLError("Field \"".concat(type.name, ".").concat(fieldName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [field]);
+              }
+
+              newFieldMap[fieldName] = astBuilder.buildField(field);
+            }
+          } catch (err) {
+            _didIteratorError11 = true;
+            _iteratorError11 = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
+                _iterator11.return();
+              }
+            } finally {
+              if (_didIteratorError11) {
+                throw _iteratorError11;
+              }
+            }
           }
-
-          newFieldMap[fieldName] = astBuilder.buildField(field);
-        });
-      });
+        }
+      } catch (err) {
+        _didIteratorError10 = true;
+        _iteratorError10 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
+            _iterator10.return();
+          }
+        } finally {
+          if (_didIteratorError10) {
+            throw _iteratorError10;
+          }
+        }
+      }
     }
 
     return newFieldMap;
diff --git a/utilities/extendSchema.js.flow b/utilities/extendSchema.js.flow
index ae4d439..7be0a0d 100644
--- a/utilities/extendSchema.js.flow
+++ b/utilities/extendSchema.js.flow
@@ -12,18 +12,23 @@ import keyMap from '../jsutils/keyMap';
 import keyValMap from '../jsutils/keyValMap';
 import objectValues from '../jsutils/objectValues';
 import { ASTDefinitionBuilder } from './buildASTSchema';
+import { assertValidSDLExtension } from '../validation/validate';
 import { GraphQLError } from '../error/GraphQLError';
 import { isSchema, GraphQLSchema } from '../type/schema';
 import { isIntrospectionType } from '../type/introspection';
+import { isSpecifiedScalarType } from '../type/scalars';
 
 import type { GraphQLSchemaValidationOptions } from '../type/schema';
 
 import type {
+  GraphQLType,
+  GraphQLNamedType,
   GraphQLArgument,
   GraphQLFieldConfigArgumentMap,
 } from '../type/definition';
 
 import {
+  isScalarType,
   isObjectType,
   isInterfaceType,
   isUnionType,
@@ -33,6 +38,7 @@ import {
   isInputObjectType,
   GraphQLList,
   GraphQLNonNull,
+  GraphQLScalarType,
   GraphQLObjectType,
   GraphQLInterfaceType,
   GraphQLUnionType,
@@ -44,11 +50,11 @@ import { GraphQLDirective } from '../type/directives';
 
 import { Kind } from '../language/kinds';
 
-import type { GraphQLType, GraphQLNamedType } from '../type/definition';
 import type {
   DocumentNode,
   DirectiveDefinitionNode,
   SchemaExtensionNode,
+  SchemaDefinitionNode,
 } from '../language/ast';
 
 type Options = {|
@@ -62,6 +68,13 @@ type Options = {|
    * Default: false
    */
   commentDescriptions?: boolean,
+
+  /**
+   * Set to true to assume the SDL is valid.
+   *
+   * Default: false
+   */
+  assumeValidSDL?: boolean,
 |};
 
 /**
@@ -94,6 +107,10 @@ export function extendSchema(
     'Must provide valid Document AST',
   );
 
+  if (!options || !(options.assumeValid || options.assumeValidSDL)) {
+    assertValidSDLExtension(documentAST, schema);
+  }
+
   // Collect the type definitions and extensions found in the document.
   const typeDefinitionMap = Object.create(null);
   const typeExtensionsMap = Object.create(null);
@@ -102,6 +119,7 @@ export function extendSchema(
   // have the same name. For example, a type named "skip".
   const directiveDefinitions: Array<DirectiveDefinitionNode> = [];
 
+  let schemaDef: ?SchemaDefinitionNode;
   // Schema extensions are collected which may add additional operation types.
   const schemaExtensions: Array<SchemaExtensionNode> = [];
 
@@ -109,11 +127,8 @@ export function extendSchema(
     const def = documentAST.definitions[i];
     switch (def.kind) {
       case Kind.SCHEMA_DEFINITION:
-        // Sanity check that a schema extension is not defining a new schema
-        throw new GraphQLError(
-          'Cannot define a new schema within a schema extension.',
-          [def],
-        );
+        schemaDef = def;
+        break;
       case Kind.SCHEMA_EXTENSION:
         schemaExtensions.push(def);
         break;
@@ -135,6 +150,7 @@ export function extendSchema(
         }
         typeDefinitionMap[typeName] = def;
         break;
+      case Kind.SCALAR_TYPE_EXTENSION:
       case Kind.OBJECT_TYPE_EXTENSION:
       case Kind.INTERFACE_TYPE_EXTENSION:
       case Kind.ENUM_TYPE_EXTENSION:
@@ -170,10 +186,6 @@ export function extendSchema(
         }
         directiveDefinitions.push(def);
         break;
-      case Kind.SCALAR_TYPE_EXTENSION:
-        throw new Error(
-          `The ${def.kind} kind is not yet supported by extendSchema().`,
-        );
     }
   }
 
@@ -183,7 +195,8 @@ export function extendSchema(
     Object.keys(typeExtensionsMap).length === 0 &&
     Object.keys(typeDefinitionMap).length === 0 &&
     directiveDefinitions.length === 0 &&
-    schemaExtensions.length === 0
+    schemaExtensions.length === 0 &&
+    !schemaDef
   ) {
     return schema;
   }
@@ -215,22 +228,31 @@ export function extendSchema(
     subscription: extendMaybeNamedType(schema.getSubscriptionType()),
   };
 
-  // Then, incorporate all schema extensions.
-  schemaExtensions.forEach(schemaExtension => {
+  if (schemaDef) {
+    for (const { operation, type } of schemaDef.operationTypes) {
+      if (operationTypes[operation]) {
+        throw new Error(`Must provide only one ${operation} type in schema.`);
+      }
+      // Note: While this could make early assertions to get the correctly
+      // typed values, that would throw immediately while type system
+      // validation with validateSchema() will produce more actionable results.
+      operationTypes[operation] = (astBuilder.buildType(type): any);
+    }
+  }
+  // Then, incorporate schema definition and all schema extensions.
+  for (const schemaExtension of schemaExtensions) {
     if (schemaExtension.operationTypes) {
-      schemaExtension.operationTypes.forEach(operationType => {
-        const operation = operationType.operation;
+      for (const { operation, type } of schemaExtension.operationTypes) {
         if (operationTypes[operation]) {
           throw new Error(`Must provide only one ${operation} type in schema.`);
         }
-        const typeRef = operationType.type;
         // Note: While this could make early assertions to get the correctly
         // typed values, that would throw immediately while type system
         // validation with validateSchema() will produce more actionable results.
-        operationTypes[operation] = (astBuilder.buildType(typeRef): any);
-      });
+        operationTypes[operation] = (astBuilder.buildType(type): any);
+      }
     }
-  });
+  }
 
   const schemaExtensionASTNodes = schemaExtensions
     ? schema.extensionASTNodes
@@ -243,7 +265,7 @@ export function extendSchema(
     // that any type not directly referenced by a field will get created.
     ...objectValues(schema.getTypeMap()).map(type => extendNamedType(type)),
     // Do the same with new types.
-    ...astBuilder.buildTypes(objectValues(typeDefinitionMap)),
+    ...objectValues(typeDefinitionMap).map(type => astBuilder.buildType(type)),
   ];
 
   // Support both original legacy names and extended legacy names.
@@ -253,9 +275,7 @@ export function extendSchema(
 
   // Then produce and return a Schema with these types.
   return new GraphQLSchema({
-    query: operationTypes.query,
-    mutation: operationTypes.mutation,
-    subscription: operationTypes.subscription,
+    ...operationTypes,
     types,
     directives: getMergedDirectives(),
     astNode: schema.astNode,
@@ -280,14 +300,16 @@ export function extendSchema(
   }
 
   function extendNamedType<T: GraphQLNamedType>(type: T): T {
-    if (isIntrospectionType(type)) {
-      // Introspection types are not extended.
+    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {
+      // Builtin types are not extended.
       return type;
     }
 
     const name = type.name;
     if (!extendTypeCache[name]) {
-      if (isObjectType(type)) {
+      if (isScalarType(type)) {
+        extendTypeCache[name] = extendScalarType(type);
+      } else if (isObjectType(type)) {
         extendTypeCache[name] = extendObjectType(type);
       } else if (isInterfaceType(type)) {
         extendTypeCache[name] = extendInterfaceType(type);
@@ -297,9 +319,6 @@ export function extendSchema(
         extendTypeCache[name] = extendEnumType(type);
       } else if (isInputObjectType(type)) {
         extendTypeCache[name] = extendInputObjectType(type);
-      } else {
-        // This type is not yet extendable.
-        extendTypeCache[name] = type;
       }
     }
     return (extendTypeCache[name]: any);
@@ -315,13 +334,6 @@ export function extendSchema(
     });
   }
 
-  function getExtendedType<T: GraphQLNamedType>(type: T): T {
-    if (!extendTypeCache[type.name]) {
-      extendTypeCache[type.name] = extendType(type);
-    }
-    return (extendTypeCache[type.name]: any);
-  }
-
   function extendInputObjectType(
     type: GraphQLInputObjectType,
   ): GraphQLInputObjectType {
@@ -343,7 +355,7 @@ export function extendSchema(
   function extendInputFieldMap(type: GraphQLInputObjectType) {
     const newFieldMap = Object.create(null);
     const oldFieldMap = type.getFields();
-    Object.keys(oldFieldMap).forEach(fieldName => {
+    for (const fieldName of Object.keys(oldFieldMap)) {
       const field = oldFieldMap[fieldName];
       newFieldMap[fieldName] = {
         description: field.description,
@@ -351,13 +363,13 @@ export function extendSchema(
         defaultValue: field.defaultValue,
         astNode: field.astNode,
       };
-    });
+    }
 
     // If there are any extensions to the fields, apply those here.
     const extensions = typeExtensionsMap[type.name];
     if (extensions) {
-      extensions.forEach(extension => {
-        extension.fields.forEach(field => {
+      for (const extension of extensions) {
+        for (const field of extension.fields) {
           const fieldName = field.name.value;
           if (oldFieldMap[fieldName]) {
             throw new GraphQLError(
@@ -367,8 +379,8 @@ export function extendSchema(
             );
           }
           newFieldMap[fieldName] = astBuilder.buildInputField(field);
-        });
-      });
+        }
+      }
     }
 
     return newFieldMap;
@@ -393,7 +405,7 @@ export function extendSchema(
   function extendValueMap(type: GraphQLEnumType) {
     const newValueMap = Object.create(null);
     const oldValueMap = keyMap(type.getValues(), value => value.name);
-    Object.keys(oldValueMap).forEach(valueName => {
+    for (const valueName of Object.keys(oldValueMap)) {
       const value = oldValueMap[valueName];
       newValueMap[valueName] = {
         name: value.name,
@@ -402,13 +414,13 @@ export function extendSchema(
         deprecationReason: value.deprecationReason,
         astNode: value.astNode,
       };
-    });
+    }
 
     // If there are any extensions to the values, apply those here.
     const extensions = typeExtensionsMap[type.name];
     if (extensions) {
-      extensions.forEach(extension => {
-        extension.values.forEach(value => {
+      for (const extension of extensions) {
+        for (const value of extension.values) {
           const valueName = value.name.value;
           if (oldValueMap[valueName]) {
             throw new GraphQLError(
@@ -418,13 +430,31 @@ export function extendSchema(
             );
           }
           newValueMap[valueName] = astBuilder.buildEnumValue(value);
-        });
-      });
+        }
+      }
     }
 
     return newValueMap;
   }
 
+  function extendScalarType(type: GraphQLScalarType): GraphQLScalarType {
+    const name = type.name;
+    const extensionASTNodes = typeExtensionsMap[name]
+      ? type.extensionASTNodes
+        ? type.extensionASTNodes.concat(typeExtensionsMap[name])
+        : typeExtensionsMap[name]
+      : type.extensionASTNodes;
+    return new GraphQLScalarType({
+      name,
+      description: type.description,
+      astNode: type.astNode,
+      extensionASTNodes,
+      serialize: type.serialize,
+      parseValue: type.parseValue,
+      parseLiteral: type.parseLiteral,
+    });
+  }
+
   function extendObjectType(type: GraphQLObjectType): GraphQLObjectType {
     const name = type.name;
     const extensionASTNodes = typeExtensionsMap[name]
@@ -484,29 +514,34 @@ export function extendSchema(
         ? type.extensionASTNodes.concat(typeExtensionsMap[name])
         : typeExtensionsMap[name]
       : type.extensionASTNodes;
-    const unionTypes = type.getTypes().map(getExtendedType);
+    return new GraphQLUnionType({
+      name,
+      description: type.description,
+      types: () => extendPossibleTypes(type),
+      astNode: type.astNode,
+      resolveType: type.resolveType,
+      extensionASTNodes,
+    });
+  }
+
+  function extendPossibleTypes(
+    type: GraphQLUnionType,
+  ): Array<GraphQLObjectType> {
+    const possibleTypes = type.getTypes().map(extendNamedType);
 
     // If there are any extensions to the union, apply those here.
     const extensions = typeExtensionsMap[type.name];
     if (extensions) {
-      extensions.forEach(extension => {
-        extension.types.forEach(namedType => {
+      for (const extension of extensions) {
+        for (const namedType of extension.types) {
           // Note: While this could make early assertions to get the correctly
           // typed values, that would throw immediately while type system
           // validation with validateSchema() will produce more actionable results.
-          unionTypes.push((astBuilder.buildType(namedType): any));
-        });
-      });
+          possibleTypes.push((astBuilder.buildType(namedType): any));
+        }
+      }
     }
-
-    return new GraphQLUnionType({
-      name,
-      description: type.description,
-      types: unionTypes,
-      astNode: type.astNode,
-      resolveType: type.resolveType,
-      extensionASTNodes,
-    });
+    return possibleTypes;
   }
 
   function extendImplementedInterfaces(
@@ -517,14 +552,14 @@ export function extendSchema(
     // If there are any extensions to the interfaces, apply those here.
     const extensions = typeExtensionsMap[type.name];
     if (extensions) {
-      extensions.forEach(extension => {
-        extension.interfaces.forEach(namedType => {
+      for (const extension of extensions) {
+        for (const namedType of extension.interfaces) {
           // Note: While this could make early assertions to get the correctly
           // typed values, that would throw immediately while type system
           // validation with validateSchema() will produce more actionable results.
           interfaces.push((astBuilder.buildType(namedType): any));
-        });
-      });
+        }
+      }
     }
 
     return interfaces;
@@ -533,7 +568,7 @@ export function extendSchema(
   function extendFieldMap(type: GraphQLObjectType | GraphQLInterfaceType) {
     const newFieldMap = Object.create(null);
     const oldFieldMap = type.getFields();
-    Object.keys(oldFieldMap).forEach(fieldName => {
+    for (const fieldName of Object.keys(oldFieldMap)) {
       const field = oldFieldMap[fieldName];
       newFieldMap[fieldName] = {
         description: field.description,
@@ -543,13 +578,13 @@ export function extendSchema(
         astNode: field.astNode,
         resolve: field.resolve,
       };
-    });
+    }
 
     // If there are any extensions to the fields, apply those here.
     const extensions = typeExtensionsMap[type.name];
     if (extensions) {
-      extensions.forEach(extension => {
-        extension.fields.forEach(field => {
+      for (const extension of extensions) {
+        for (const field of extension.fields) {
           const fieldName = field.name.value;
           if (oldFieldMap[fieldName]) {
             throw new GraphQLError(
@@ -559,8 +594,8 @@ export function extendSchema(
             );
           }
           newFieldMap[fieldName] = astBuilder.buildField(field);
-        });
-      });
+        }
+      }
     }
 
     return newFieldMap;
diff --git a/utilities/extendSchema.mjs b/utilities/extendSchema.mjs
index 83245ff..2e5399c 100644
--- a/utilities/extendSchema.mjs
+++ b/utilities/extendSchema.mjs
@@ -1,3 +1,7 @@
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
 /**
  * Copyright (c) 2015-present, Facebook, Inc.
  *
@@ -11,10 +15,12 @@ import keyMap from '../jsutils/keyMap';
 import keyValMap from '../jsutils/keyValMap';
 import objectValues from '../jsutils/objectValues';
 import { ASTDefinitionBuilder } from './buildASTSchema';
+import { assertValidSDLExtension } from '../validation/validate';
 import { GraphQLError } from '../error/GraphQLError';
 import { isSchema, GraphQLSchema } from '../type/schema';
 import { isIntrospectionType } from '../type/introspection';
-import { isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';
+import { isSpecifiedScalarType } from '../type/scalars';
+import { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';
 import { GraphQLDirective } from '../type/directives';
 import { Kind } from '../language/kinds';
 
@@ -38,13 +44,19 @@ import { Kind } from '../language/kinds';
  */
 export function extendSchema(schema, documentAST, options) {
   !isSchema(schema) ? invariant(0, 'Must provide valid GraphQLSchema') : void 0;
-  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0; // Collect the type definitions and extensions found in the document.
+  !(documentAST && documentAST.kind === Kind.DOCUMENT) ? invariant(0, 'Must provide valid Document AST') : void 0;
+
+  if (!options || !(options.assumeValid || options.assumeValidSDL)) {
+    assertValidSDLExtension(documentAST, schema);
+  } // Collect the type definitions and extensions found in the document.
+
 
   var typeDefinitionMap = Object.create(null);
   var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can
   // have the same name. For example, a type named "skip".
 
-  var directiveDefinitions = []; // Schema extensions are collected which may add additional operation types.
+  var directiveDefinitions = [];
+  var schemaDef; // Schema extensions are collected which may add additional operation types.
 
   var schemaExtensions = [];
 
@@ -53,8 +65,8 @@ export function extendSchema(schema, documentAST, options) {
 
     switch (def.kind) {
       case Kind.SCHEMA_DEFINITION:
-        // Sanity check that a schema extension is not defining a new schema
-        throw new GraphQLError('Cannot define a new schema within a schema extension.', [def]);
+        schemaDef = def;
+        break;
 
       case Kind.SCHEMA_EXTENSION:
         schemaExtensions.push(def);
@@ -77,6 +89,7 @@ export function extendSchema(schema, documentAST, options) {
         typeDefinitionMap[typeName] = def;
         break;
 
+      case Kind.SCALAR_TYPE_EXTENSION:
       case Kind.OBJECT_TYPE_EXTENSION:
       case Kind.INTERFACE_TYPE_EXTENSION:
       case Kind.ENUM_TYPE_EXTENSION:
@@ -106,15 +119,12 @@ export function extendSchema(schema, documentAST, options) {
 
         directiveDefinitions.push(def);
         break;
-
-      case Kind.SCALAR_TYPE_EXTENSION:
-        throw new Error("The ".concat(def.kind, " kind is not yet supported by extendSchema()."));
     }
   } // If this document contains no new types, extensions, or directives then
   // return the same unmodified GraphQLSchema instance.
 
 
-  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0) {
+  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0 && !schemaDef) {
     return schema;
   }
 
@@ -134,43 +144,102 @@ export function extendSchema(schema, documentAST, options) {
     query: extendMaybeNamedType(schema.getQueryType()),
     mutation: extendMaybeNamedType(schema.getMutationType()),
     subscription: extendMaybeNamedType(schema.getSubscriptionType())
-  }; // Then, incorporate all schema extensions.
+  };
 
-  schemaExtensions.forEach(function (schemaExtension) {
-    if (schemaExtension.operationTypes) {
-      schemaExtension.operationTypes.forEach(function (operationType) {
-        var operation = operationType.operation;
+  if (schemaDef) {
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
+    try {
+      for (var _iterator = schemaDef.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+        var _ref2 = _step.value;
+        var operation = _ref2.operation,
+            type = _ref2.type;
 
         if (operationTypes[operation]) {
           throw new Error("Must provide only one ".concat(operation, " type in schema."));
-        }
-
-        var typeRef = operationType.type; // Note: While this could make early assertions to get the correctly
+        } // Note: While this could make early assertions to get the correctly
         // typed values, that would throw immediately while type system
         // validation with validateSchema() will produce more actionable results.
 
-        operationTypes[operation] = astBuilder.buildType(typeRef);
-      });
+
+        operationTypes[operation] = astBuilder.buildType(type);
+      }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return != null) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
     }
-  });
+  } // Then, incorporate schema definition and all schema extensions.
+
+
+  for (var _i = 0; _i < schemaExtensions.length; _i++) {
+    var schemaExtension = schemaExtensions[_i];
+
+    if (schemaExtension.operationTypes) {
+      var _iteratorNormalCompletion12 = true;
+      var _didIteratorError12 = false;
+      var _iteratorError12 = undefined;
+
+      try {
+        for (var _iterator12 = schemaExtension.operationTypes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
+          var _ref4 = _step12.value;
+          var operation = _ref4.operation,
+              type = _ref4.type;
+
+          if (operationTypes[operation]) {
+            throw new Error("Must provide only one ".concat(operation, " type in schema."));
+          } // Note: While this could make early assertions to get the correctly
+          // typed values, that would throw immediately while type system
+          // validation with validateSchema() will produce more actionable results.
+
+
+          operationTypes[operation] = astBuilder.buildType(type);
+        }
+      } catch (err) {
+        _didIteratorError12 = true;
+        _iteratorError12 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
+            _iterator12.return();
+          }
+        } finally {
+          if (_didIteratorError12) {
+            throw _iteratorError12;
+          }
+        }
+      }
+    }
+  }
+
   var schemaExtensionASTNodes = schemaExtensions ? schema.extensionASTNodes ? schema.extensionASTNodes.concat(schemaExtensions) : schemaExtensions : schema.extensionASTNodes;
   var types = objectValues(schema.getTypeMap()).map(function (type) {
     return extendNamedType(type);
-  }).concat(astBuilder.buildTypes(objectValues(typeDefinitionMap))); // Support both original legacy names and extended legacy names.
+  }).concat(objectValues(typeDefinitionMap).map(function (type) {
+    return astBuilder.buildType(type);
+  })); // Support both original legacy names and extended legacy names.
 
   var allowedLegacyNames = schema.__allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.
 
 
-  return new GraphQLSchema({
-    query: operationTypes.query,
-    mutation: operationTypes.mutation,
-    subscription: operationTypes.subscription,
+  return new GraphQLSchema(_objectSpread({}, operationTypes, {
     types: types,
     directives: getMergedDirectives(),
     astNode: schema.astNode,
     extensionASTNodes: schemaExtensionASTNodes,
     allowedLegacyNames: allowedLegacyNames
-  }); // Below are functions used for producing this schema that have closed over
+  })); // Below are functions used for producing this schema that have closed over
   // this scope and have access to the schema, cache, and newly defined types.
 
   function getMergedDirectives() {
@@ -186,15 +255,17 @@ export function extendSchema(schema, documentAST, options) {
   }
 
   function extendNamedType(type) {
-    if (isIntrospectionType(type)) {
-      // Introspection types are not extended.
+    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {
+      // Builtin types are not extended.
       return type;
     }
 
     var name = type.name;
 
     if (!extendTypeCache[name]) {
-      if (isObjectType(type)) {
+      if (isScalarType(type)) {
+        extendTypeCache[name] = extendScalarType(type);
+      } else if (isObjectType(type)) {
         extendTypeCache[name] = extendObjectType(type);
       } else if (isInterfaceType(type)) {
         extendTypeCache[name] = extendInterfaceType(type);
@@ -204,9 +275,6 @@ export function extendSchema(schema, documentAST, options) {
         extendTypeCache[name] = extendEnumType(type);
       } else if (isInputObjectType(type)) {
         extendTypeCache[name] = extendInputObjectType(type);
-      } else {
-        // This type is not yet extendable.
-        extendTypeCache[name] = type;
       }
     }
 
@@ -223,14 +291,6 @@ export function extendSchema(schema, documentAST, options) {
     });
   }
 
-  function getExtendedType(type) {
-    if (!extendTypeCache[type.name]) {
-      extendTypeCache[type.name] = extendType(type);
-    }
-
-    return extendTypeCache[type.name];
-  }
-
   function extendInputObjectType(type) {
     var name = type.name;
     var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;
@@ -248,30 +308,75 @@ export function extendSchema(schema, documentAST, options) {
   function extendInputFieldMap(type) {
     var newFieldMap = Object.create(null);
     var oldFieldMap = type.getFields();
-    Object.keys(oldFieldMap).forEach(function (fieldName) {
-      var field = oldFieldMap[fieldName];
-      newFieldMap[fieldName] = {
-        description: field.description,
-        type: extendType(field.type),
-        defaultValue: field.defaultValue,
-        astNode: field.astNode
+
+    var _arr = Object.keys(oldFieldMap);
+
+    for (var _i2 = 0; _i2 < _arr.length; _i2++) {
+      var _fieldName = _arr[_i2];
+      var _field = oldFieldMap[_fieldName];
+      newFieldMap[_fieldName] = {
+        description: _field.description,
+        type: extendType(_field.type),
+        defaultValue: _field.defaultValue,
+        astNode: _field.astNode
       };
-    }); // If there are any extensions to the fields, apply those here.
+    } // If there are any extensions to the fields, apply those here.
+
 
     var extensions = typeExtensionsMap[type.name];
 
     if (extensions) {
-      extensions.forEach(function (extension) {
-        extension.fields.forEach(function (field) {
-          var fieldName = field.name.value;
-
-          if (oldFieldMap[fieldName]) {
-            throw new GraphQLError("Field \"".concat(type.name, ".").concat(fieldName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [field]);
+      var _iteratorNormalCompletion2 = true;
+      var _didIteratorError2 = false;
+      var _iteratorError2 = undefined;
+
+      try {
+        for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+          var extension = _step2.value;
+          var _iteratorNormalCompletion3 = true;
+          var _didIteratorError3 = false;
+          var _iteratorError3 = undefined;
+
+          try {
+            for (var _iterator3 = extension.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
+              var field = _step3.value;
+              var fieldName = field.name.value;
+
+              if (oldFieldMap[fieldName]) {
+                throw new GraphQLError("Field \"".concat(type.name, ".").concat(fieldName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [field]);
+              }
+
+              newFieldMap[fieldName] = astBuilder.buildInputField(field);
+            }
+          } catch (err) {
+            _didIteratorError3 = true;
+            _iteratorError3 = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
+                _iterator3.return();
+              }
+            } finally {
+              if (_didIteratorError3) {
+                throw _iteratorError3;
+              }
+            }
           }
-
-          newFieldMap[fieldName] = astBuilder.buildInputField(field);
-        });
-      });
+        }
+      } catch (err) {
+        _didIteratorError2 = true;
+        _iteratorError2 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+            _iterator2.return();
+          }
+        } finally {
+          if (_didIteratorError2) {
+            throw _iteratorError2;
+          }
+        }
+      }
     }
 
     return newFieldMap;
@@ -294,36 +399,95 @@ export function extendSchema(schema, documentAST, options) {
     var oldValueMap = keyMap(type.getValues(), function (value) {
       return value.name;
     });
-    Object.keys(oldValueMap).forEach(function (valueName) {
-      var value = oldValueMap[valueName];
-      newValueMap[valueName] = {
-        name: value.name,
-        description: value.description,
-        value: value.value,
-        deprecationReason: value.deprecationReason,
-        astNode: value.astNode
+
+    var _arr2 = Object.keys(oldValueMap);
+
+    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {
+      var _valueName = _arr2[_i3];
+      var _value = oldValueMap[_valueName];
+      newValueMap[_valueName] = {
+        name: _value.name,
+        description: _value.description,
+        value: _value.value,
+        deprecationReason: _value.deprecationReason,
+        astNode: _value.astNode
       };
-    }); // If there are any extensions to the values, apply those here.
+    } // If there are any extensions to the values, apply those here.
+
 
     var extensions = typeExtensionsMap[type.name];
 
     if (extensions) {
-      extensions.forEach(function (extension) {
-        extension.values.forEach(function (value) {
-          var valueName = value.name.value;
-
-          if (oldValueMap[valueName]) {
-            throw new GraphQLError("Enum value \"".concat(type.name, ".").concat(valueName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [value]);
+      var _iteratorNormalCompletion4 = true;
+      var _didIteratorError4 = false;
+      var _iteratorError4 = undefined;
+
+      try {
+        for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
+          var extension = _step4.value;
+          var _iteratorNormalCompletion5 = true;
+          var _didIteratorError5 = false;
+          var _iteratorError5 = undefined;
+
+          try {
+            for (var _iterator5 = extension.values[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
+              var value = _step5.value;
+              var valueName = value.name.value;
+
+              if (oldValueMap[valueName]) {
+                throw new GraphQLError("Enum value \"".concat(type.name, ".").concat(valueName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [value]);
+              }
+
+              newValueMap[valueName] = astBuilder.buildEnumValue(value);
+            }
+          } catch (err) {
+            _didIteratorError5 = true;
+            _iteratorError5 = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
+                _iterator5.return();
+              }
+            } finally {
+              if (_didIteratorError5) {
+                throw _iteratorError5;
+              }
+            }
           }
-
-          newValueMap[valueName] = astBuilder.buildEnumValue(value);
-        });
-      });
+        }
+      } catch (err) {
+        _didIteratorError4 = true;
+        _iteratorError4 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
+            _iterator4.return();
+          }
+        } finally {
+          if (_didIteratorError4) {
+            throw _iteratorError4;
+          }
+        }
+      }
     }
 
     return newValueMap;
   }
 
+  function extendScalarType(type) {
+    var name = type.name;
+    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;
+    return new GraphQLScalarType({
+      name: name,
+      description: type.description,
+      astNode: type.astNode,
+      extensionASTNodes: extensionASTNodes,
+      serialize: type.serialize,
+      parseValue: type.parseValue,
+      parseLiteral: type.parseLiteral
+    });
+  }
+
   function extendObjectType(type) {
     var name = type.name;
     var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;
@@ -373,45 +537,131 @@ export function extendSchema(schema, documentAST, options) {
   function extendUnionType(type) {
     var name = type.name;
     var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;
-    var unionTypes = type.getTypes().map(getExtendedType); // If there are any extensions to the union, apply those here.
-
-    var extensions = typeExtensionsMap[type.name];
-
-    if (extensions) {
-      extensions.forEach(function (extension) {
-        extension.types.forEach(function (namedType) {
-          // Note: While this could make early assertions to get the correctly
-          // typed values, that would throw immediately while type system
-          // validation with validateSchema() will produce more actionable results.
-          unionTypes.push(astBuilder.buildType(namedType));
-        });
-      });
-    }
-
     return new GraphQLUnionType({
       name: name,
       description: type.description,
-      types: unionTypes,
+      types: function types() {
+        return extendPossibleTypes(type);
+      },
       astNode: type.astNode,
       resolveType: type.resolveType,
       extensionASTNodes: extensionASTNodes
     });
   }
 
+  function extendPossibleTypes(type) {
+    var possibleTypes = type.getTypes().map(extendNamedType); // If there are any extensions to the union, apply those here.
+
+    var extensions = typeExtensionsMap[type.name];
+
+    if (extensions) {
+      var _iteratorNormalCompletion6 = true;
+      var _didIteratorError6 = false;
+      var _iteratorError6 = undefined;
+
+      try {
+        for (var _iterator6 = extensions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
+          var extension = _step6.value;
+          var _iteratorNormalCompletion7 = true;
+          var _didIteratorError7 = false;
+          var _iteratorError7 = undefined;
+
+          try {
+            for (var _iterator7 = extension.types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
+              var namedType = _step7.value;
+              // Note: While this could make early assertions to get the correctly
+              // typed values, that would throw immediately while type system
+              // validation with validateSchema() will produce more actionable results.
+              possibleTypes.push(astBuilder.buildType(namedType));
+            }
+          } catch (err) {
+            _didIteratorError7 = true;
+            _iteratorError7 = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
+                _iterator7.return();
+              }
+            } finally {
+              if (_didIteratorError7) {
+                throw _iteratorError7;
+              }
+            }
+          }
+        }
+      } catch (err) {
+        _didIteratorError6 = true;
+        _iteratorError6 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
+            _iterator6.return();
+          }
+        } finally {
+          if (_didIteratorError6) {
+            throw _iteratorError6;
+          }
+        }
+      }
+    }
+
+    return possibleTypes;
+  }
+
   function extendImplementedInterfaces(type) {
     var interfaces = type.getInterfaces().map(extendNamedType); // If there are any extensions to the interfaces, apply those here.
 
     var extensions = typeExtensionsMap[type.name];
 
     if (extensions) {
-      extensions.forEach(function (extension) {
-        extension.interfaces.forEach(function (namedType) {
-          // Note: While this could make early assertions to get the correctly
-          // typed values, that would throw immediately while type system
-          // validation with validateSchema() will produce more actionable results.
-          interfaces.push(astBuilder.buildType(namedType));
-        });
-      });
+      var _iteratorNormalCompletion8 = true;
+      var _didIteratorError8 = false;
+      var _iteratorError8 = undefined;
+
+      try {
+        for (var _iterator8 = extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
+          var extension = _step8.value;
+          var _iteratorNormalCompletion9 = true;
+          var _didIteratorError9 = false;
+          var _iteratorError9 = undefined;
+
+          try {
+            for (var _iterator9 = extension.interfaces[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
+              var namedType = _step9.value;
+              // Note: While this could make early assertions to get the correctly
+              // typed values, that would throw immediately while type system
+              // validation with validateSchema() will produce more actionable results.
+              interfaces.push(astBuilder.buildType(namedType));
+            }
+          } catch (err) {
+            _didIteratorError9 = true;
+            _iteratorError9 = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
+                _iterator9.return();
+              }
+            } finally {
+              if (_didIteratorError9) {
+                throw _iteratorError9;
+              }
+            }
+          }
+        }
+      } catch (err) {
+        _didIteratorError8 = true;
+        _iteratorError8 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
+            _iterator8.return();
+          }
+        } finally {
+          if (_didIteratorError8) {
+            throw _iteratorError8;
+          }
+        }
+      }
     }
 
     return interfaces;
@@ -420,32 +670,77 @@ export function extendSchema(schema, documentAST, options) {
   function extendFieldMap(type) {
     var newFieldMap = Object.create(null);
     var oldFieldMap = type.getFields();
-    Object.keys(oldFieldMap).forEach(function (fieldName) {
-      var field = oldFieldMap[fieldName];
-      newFieldMap[fieldName] = {
-        description: field.description,
-        deprecationReason: field.deprecationReason,
-        type: extendType(field.type),
-        args: extendArgs(field.args),
-        astNode: field.astNode,
-        resolve: field.resolve
+
+    var _arr3 = Object.keys(oldFieldMap);
+
+    for (var _i4 = 0; _i4 < _arr3.length; _i4++) {
+      var _fieldName2 = _arr3[_i4];
+      var _field2 = oldFieldMap[_fieldName2];
+      newFieldMap[_fieldName2] = {
+        description: _field2.description,
+        deprecationReason: _field2.deprecationReason,
+        type: extendType(_field2.type),
+        args: extendArgs(_field2.args),
+        astNode: _field2.astNode,
+        resolve: _field2.resolve
       };
-    }); // If there are any extensions to the fields, apply those here.
+    } // If there are any extensions to the fields, apply those here.
+
 
     var extensions = typeExtensionsMap[type.name];
 
     if (extensions) {
-      extensions.forEach(function (extension) {
-        extension.fields.forEach(function (field) {
-          var fieldName = field.name.value;
-
-          if (oldFieldMap[fieldName]) {
-            throw new GraphQLError("Field \"".concat(type.name, ".").concat(fieldName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [field]);
+      var _iteratorNormalCompletion10 = true;
+      var _didIteratorError10 = false;
+      var _iteratorError10 = undefined;
+
+      try {
+        for (var _iterator10 = extensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
+          var extension = _step10.value;
+          var _iteratorNormalCompletion11 = true;
+          var _didIteratorError11 = false;
+          var _iteratorError11 = undefined;
+
+          try {
+            for (var _iterator11 = extension.fields[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
+              var field = _step11.value;
+              var fieldName = field.name.value;
+
+              if (oldFieldMap[fieldName]) {
+                throw new GraphQLError("Field \"".concat(type.name, ".").concat(fieldName, "\" already exists in the ") + 'schema. It cannot also be defined in this type extension.', [field]);
+              }
+
+              newFieldMap[fieldName] = astBuilder.buildField(field);
+            }
+          } catch (err) {
+            _didIteratorError11 = true;
+            _iteratorError11 = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
+                _iterator11.return();
+              }
+            } finally {
+              if (_didIteratorError11) {
+                throw _iteratorError11;
+              }
+            }
           }
-
-          newFieldMap[fieldName] = astBuilder.buildField(field);
-        });
-      });
+        }
+      } catch (err) {
+        _didIteratorError10 = true;
+        _iteratorError10 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
+            _iterator10.return();
+          }
+        } finally {
+          if (_didIteratorError10) {
+            throw _iteratorError10;
+          }
+        }
+      }
     }
 
     return newFieldMap;
diff --git a/utilities/findBreakingChanges.js b/utilities/findBreakingChanges.js
index 90d209a..5b10d97 100644
--- a/utilities/findBreakingChanges.js
+++ b/utilities/findBreakingChanges.js
@@ -25,10 +25,6 @@ exports.DangerousChangeType = exports.BreakingChangeType = void 0;
 
 var _definition = require("../type/definition");
 
-var _directives = require("../type/directives");
-
-var _schema = require("../type/schema");
-
 var _keyMap = _interopRequireDefault(require("../jsutils/keyMap"));
 
 function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
@@ -95,14 +91,20 @@ function findRemovedTypes(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr = Object.keys(oldTypeMap);
+
+  for (var _i = 0; _i < _arr.length; _i++) {
+    var typeName = _arr[_i];
+
     if (!newTypeMap[typeName]) {
       breakingChanges.push({
         type: BreakingChangeType.TYPE_REMOVED,
         description: "".concat(typeName, " was removed.")
       });
     }
-  });
+  }
+
   return breakingChanges;
 }
 /**
@@ -115,9 +117,14 @@ function findTypesThatChangedKind(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr2 = Object.keys(oldTypeMap);
+
+  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
+    var typeName = _arr2[_i2];
+
     if (!newTypeMap[typeName]) {
-      return;
+      continue;
     }
 
     var oldType = oldTypeMap[typeName];
@@ -129,7 +136,8 @@ function findTypesThatChangedKind(oldSchema, newSchema) {
         description: "".concat(typeName, " changed from ") + "".concat(typeKindName(oldType), " to ").concat(typeKindName(newType), ".")
       });
     }
-  });
+  }
+
   return breakingChanges;
 }
 /**
@@ -145,71 +153,130 @@ function findArgChanges(oldSchema, newSchema) {
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
   var dangerousChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr3 = Object.keys(oldTypeMap);
+
+  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
+    var typeName = _arr3[_i3];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!((0, _definition.isObjectType)(oldType) || (0, _definition.isInterfaceType)(oldType)) || !((0, _definition.isObjectType)(newType) || (0, _definition.isInterfaceType)(newType)) || newType.constructor !== oldType.constructor) {
-      return;
+      continue;
     }
 
     var oldTypeFields = oldType.getFields();
     var newTypeFields = newType.getFields();
-    Object.keys(oldTypeFields).forEach(function (fieldName) {
+
+    var _arr4 = Object.keys(oldTypeFields);
+
+    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
+      var fieldName = _arr4[_i4];
+
       if (!newTypeFields[fieldName]) {
-        return;
+        continue;
       }
 
-      oldTypeFields[fieldName].args.forEach(function (oldArgDef) {
-        var newArgs = newTypeFields[fieldName].args;
-        var newArgDef = newArgs.find(function (arg) {
-          return arg.name === oldArgDef.name;
-        }); // Arg not present
+      var _iteratorNormalCompletion = true;
+      var _didIteratorError = false;
+      var _iteratorError = undefined;
 
-        if (!newArgDef) {
-          breakingChanges.push({
-            type: BreakingChangeType.ARG_REMOVED,
-            description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " was removed")
-          });
-        } else {
-          var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);
+      try {
+        var _loop = function _loop() {
+          var oldArgDef = _step.value;
+          var newArgs = newTypeFields[fieldName].args;
+          var newArgDef = newArgs.find(function (arg) {
+            return arg.name === oldArgDef.name;
+          }); // Arg not present
 
-          if (!isSafe) {
+          if (!newArgDef) {
             breakingChanges.push({
-              type: BreakingChangeType.ARG_CHANGED_KIND,
-              description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " has changed type from ") + "".concat(oldArgDef.type.toString(), " to ").concat(newArgDef.type.toString())
-            });
-          } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {
-            dangerousChanges.push({
-              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
-              description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " has changed defaultValue")
+              type: BreakingChangeType.ARG_REMOVED,
+              description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " was removed")
             });
+          } else {
+            var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);
+
+            if (!isSafe) {
+              breakingChanges.push({
+                type: BreakingChangeType.ARG_CHANGED_KIND,
+                description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " has changed type from ") + "".concat(oldArgDef.type.toString(), " to ").concat(newArgDef.type.toString())
+              });
+            } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {
+              dangerousChanges.push({
+                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
+                description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " has changed defaultValue")
+              });
+            }
+          }
+        };
+
+        for (var _iterator = oldTypeFields[fieldName].args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+          _loop();
+        } // Check if a non-null arg was added to the field
+
+      } catch (err) {
+        _didIteratorError = true;
+        _iteratorError = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion && _iterator.return != null) {
+            _iterator.return();
+          }
+        } finally {
+          if (_didIteratorError) {
+            throw _iteratorError;
           }
         }
-      }); // Check if a non-null arg was added to the field
+      }
 
-      newTypeFields[fieldName].args.forEach(function (newArgDef) {
-        var oldArgs = oldTypeFields[fieldName].args;
-        var oldArgDef = oldArgs.find(function (arg) {
-          return arg.name === newArgDef.name;
-        });
+      var _iteratorNormalCompletion2 = true;
+      var _didIteratorError2 = false;
+      var _iteratorError2 = undefined;
 
-        if (!oldArgDef) {
-          if ((0, _definition.isNonNullType)(newArgDef.type)) {
-            breakingChanges.push({
-              type: BreakingChangeType.NON_NULL_ARG_ADDED,
-              description: "A non-null arg ".concat(newArgDef.name, " on ") + "".concat(newType.name, ".").concat(fieldName, " was added")
-            });
-          } else {
-            dangerousChanges.push({
-              type: DangerousChangeType.NULLABLE_ARG_ADDED,
-              description: "A nullable arg ".concat(newArgDef.name, " on ") + "".concat(newType.name, ".").concat(fieldName, " was added")
-            });
+      try {
+        var _loop2 = function _loop2() {
+          var newArgDef = _step2.value;
+          var oldArgs = oldTypeFields[fieldName].args;
+          var oldArgDef = oldArgs.find(function (arg) {
+            return arg.name === newArgDef.name;
+          });
+
+          if (!oldArgDef) {
+            if ((0, _definition.isNonNullType)(newArgDef.type)) {
+              breakingChanges.push({
+                type: BreakingChangeType.NON_NULL_ARG_ADDED,
+                description: "A non-null arg ".concat(newArgDef.name, " on ") + "".concat(newType.name, ".").concat(fieldName, " was added")
+              });
+            } else {
+              dangerousChanges.push({
+                type: DangerousChangeType.NULLABLE_ARG_ADDED,
+                description: "A nullable arg ".concat(newArgDef.name, " on ") + "".concat(newType.name, ".").concat(fieldName, " was added")
+              });
+            }
           }
+        };
+
+        for (var _iterator2 = newTypeFields[fieldName].args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+          _loop2();
         }
-      });
-    });
-  });
+      } catch (err) {
+        _didIteratorError2 = true;
+        _iteratorError2 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+            _iterator2.return();
+          }
+        } finally {
+          if (_didIteratorError2) {
+            throw _iteratorError2;
+          }
+        }
+      }
+    }
+  }
+
   return {
     breakingChanges: breakingChanges,
     dangerousChanges: dangerousChanges
@@ -248,17 +315,26 @@ function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema)
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr5 = Object.keys(oldTypeMap);
+
+  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {
+    var typeName = _arr5[_i5];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!((0, _definition.isObjectType)(oldType) || (0, _definition.isInterfaceType)(oldType)) || !((0, _definition.isObjectType)(newType) || (0, _definition.isInterfaceType)(newType)) || newType.constructor !== oldType.constructor) {
-      return;
+      continue;
     }
 
     var oldTypeFieldsDef = oldType.getFields();
     var newTypeFieldsDef = newType.getFields();
-    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {
+
+    var _arr6 = Object.keys(oldTypeFieldsDef);
+
+    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {
+      var fieldName = _arr6[_i6];
+
       // Check if the field is missing on the type in the new schema.
       if (!(fieldName in newTypeFieldsDef)) {
         breakingChanges.push({
@@ -279,8 +355,9 @@ function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema)
           });
         }
       }
-    });
-  });
+    }
+  }
+
   return breakingChanges;
 }
 
@@ -289,17 +366,26 @@ function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
   var dangerousChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr7 = Object.keys(oldTypeMap);
+
+  for (var _i7 = 0; _i7 < _arr7.length; _i7++) {
+    var typeName = _arr7[_i7];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!(0, _definition.isInputObjectType)(oldType) || !(0, _definition.isInputObjectType)(newType)) {
-      return;
+      continue;
     }
 
     var oldTypeFieldsDef = oldType.getFields();
     var newTypeFieldsDef = newType.getFields();
-    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {
+
+    var _arr8 = Object.keys(oldTypeFieldsDef);
+
+    for (var _i8 = 0; _i8 < _arr8.length; _i8++) {
+      var fieldName = _arr8[_i8];
+
       // Check if the field is missing on the type in the new schema.
       if (!(fieldName in newTypeFieldsDef)) {
         breakingChanges.push({
@@ -320,24 +406,30 @@ function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {
           });
         }
       }
-    }); // Check if a field was added to the input object type
+    } // Check if a field was added to the input object type
 
-    Object.keys(newTypeFieldsDef).forEach(function (fieldName) {
-      if (!(fieldName in oldTypeFieldsDef)) {
-        if ((0, _definition.isNonNullType)(newTypeFieldsDef[fieldName].type)) {
+
+    var _arr9 = Object.keys(newTypeFieldsDef);
+
+    for (var _i9 = 0; _i9 < _arr9.length; _i9++) {
+      var _fieldName = _arr9[_i9];
+
+      if (!(_fieldName in oldTypeFieldsDef)) {
+        if ((0, _definition.isNonNullType)(newTypeFieldsDef[_fieldName].type)) {
           breakingChanges.push({
             type: BreakingChangeType.NON_NULL_INPUT_FIELD_ADDED,
-            description: "A non-null field ".concat(fieldName, " on ") + "input type ".concat(newType.name, " was added.")
+            description: "A non-null field ".concat(_fieldName, " on ") + "input type ".concat(newType.name, " was added.")
           });
         } else {
           dangerousChanges.push({
             type: DangerousChangeType.NULLABLE_INPUT_FIELD_ADDED,
-            description: "A nullable field ".concat(fieldName, " on ") + "input type ".concat(newType.name, " was added.")
+            description: "A nullable field ".concat(_fieldName, " on ") + "input type ".concat(newType.name, " was added.")
           });
         }
       }
-    });
-  });
+    }
+  }
+
   return {
     breakingChanges: breakingChanges,
     dangerousChanges: dangerousChanges
@@ -390,27 +482,74 @@ function findTypesRemovedFromUnions(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var typesRemovedFromUnion = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr10 = Object.keys(oldTypeMap);
+
+  for (var _i10 = 0; _i10 < _arr10.length; _i10++) {
+    var typeName = _arr10[_i10];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!(0, _definition.isUnionType)(oldType) || !(0, _definition.isUnionType)(newType)) {
-      return;
+      continue;
     }
 
     var typeNamesInNewUnion = Object.create(null);
-    newType.getTypes().forEach(function (type) {
-      typeNamesInNewUnion[type.name] = true;
-    });
-    oldType.getTypes().forEach(function (type) {
-      if (!typeNamesInNewUnion[type.name]) {
-        typesRemovedFromUnion.push({
-          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
-          description: "".concat(type.name, " was removed from union type ").concat(typeName, ".")
-        });
+    var _iteratorNormalCompletion3 = true;
+    var _didIteratorError3 = false;
+    var _iteratorError3 = undefined;
+
+    try {
+      for (var _iterator3 = newType.getTypes()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
+        var type = _step3.value;
+        typeNamesInNewUnion[type.name] = true;
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError3 = true;
+      _iteratorError3 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
+          _iterator3.return();
+        }
+      } finally {
+        if (_didIteratorError3) {
+          throw _iteratorError3;
+        }
+      }
+    }
+
+    var _iteratorNormalCompletion4 = true;
+    var _didIteratorError4 = false;
+    var _iteratorError4 = undefined;
+
+    try {
+      for (var _iterator4 = oldType.getTypes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
+        var _type = _step4.value;
+
+        if (!typeNamesInNewUnion[_type.name]) {
+          typesRemovedFromUnion.push({
+            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
+            description: "".concat(_type.name, " was removed from union type ").concat(typeName, ".")
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError4 = true;
+      _iteratorError4 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
+          _iterator4.return();
+        }
+      } finally {
+        if (_didIteratorError4) {
+          throw _iteratorError4;
+        }
+      }
+    }
+  }
+
   return typesRemovedFromUnion;
 }
 /**
@@ -423,27 +562,74 @@ function findTypesAddedToUnions(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var typesAddedToUnion = [];
-  Object.keys(newTypeMap).forEach(function (typeName) {
+
+  var _arr11 = Object.keys(newTypeMap);
+
+  for (var _i11 = 0; _i11 < _arr11.length; _i11++) {
+    var typeName = _arr11[_i11];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!(0, _definition.isUnionType)(oldType) || !(0, _definition.isUnionType)(newType)) {
-      return;
+      continue;
     }
 
     var typeNamesInOldUnion = Object.create(null);
-    oldType.getTypes().forEach(function (type) {
-      typeNamesInOldUnion[type.name] = true;
-    });
-    newType.getTypes().forEach(function (type) {
-      if (!typeNamesInOldUnion[type.name]) {
-        typesAddedToUnion.push({
-          type: DangerousChangeType.TYPE_ADDED_TO_UNION,
-          description: "".concat(type.name, " was added to union type ").concat(typeName, ".")
-        });
+    var _iteratorNormalCompletion5 = true;
+    var _didIteratorError5 = false;
+    var _iteratorError5 = undefined;
+
+    try {
+      for (var _iterator5 = oldType.getTypes()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
+        var type = _step5.value;
+        typeNamesInOldUnion[type.name] = true;
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError5 = true;
+      _iteratorError5 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
+          _iterator5.return();
+        }
+      } finally {
+        if (_didIteratorError5) {
+          throw _iteratorError5;
+        }
+      }
+    }
+
+    var _iteratorNormalCompletion6 = true;
+    var _didIteratorError6 = false;
+    var _iteratorError6 = undefined;
+
+    try {
+      for (var _iterator6 = newType.getTypes()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
+        var _type2 = _step6.value;
+
+        if (!typeNamesInOldUnion[_type2.name]) {
+          typesAddedToUnion.push({
+            type: DangerousChangeType.TYPE_ADDED_TO_UNION,
+            description: "".concat(_type2.name, " was added to union type ").concat(typeName, ".")
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError6 = true;
+      _iteratorError6 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
+          _iterator6.return();
+        }
+      } finally {
+        if (_didIteratorError6) {
+          throw _iteratorError6;
+        }
+      }
+    }
+  }
+
   return typesAddedToUnion;
 }
 /**
@@ -456,27 +642,74 @@ function findValuesRemovedFromEnums(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var valuesRemovedFromEnums = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr12 = Object.keys(oldTypeMap);
+
+  for (var _i12 = 0; _i12 < _arr12.length; _i12++) {
+    var typeName = _arr12[_i12];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!(0, _definition.isEnumType)(oldType) || !(0, _definition.isEnumType)(newType)) {
-      return;
+      continue;
     }
 
     var valuesInNewEnum = Object.create(null);
-    newType.getValues().forEach(function (value) {
-      valuesInNewEnum[value.name] = true;
-    });
-    oldType.getValues().forEach(function (value) {
-      if (!valuesInNewEnum[value.name]) {
-        valuesRemovedFromEnums.push({
-          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
-          description: "".concat(value.name, " was removed from enum type ").concat(typeName, ".")
-        });
+    var _iteratorNormalCompletion7 = true;
+    var _didIteratorError7 = false;
+    var _iteratorError7 = undefined;
+
+    try {
+      for (var _iterator7 = newType.getValues()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
+        var value = _step7.value;
+        valuesInNewEnum[value.name] = true;
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError7 = true;
+      _iteratorError7 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
+          _iterator7.return();
+        }
+      } finally {
+        if (_didIteratorError7) {
+          throw _iteratorError7;
+        }
+      }
+    }
+
+    var _iteratorNormalCompletion8 = true;
+    var _didIteratorError8 = false;
+    var _iteratorError8 = undefined;
+
+    try {
+      for (var _iterator8 = oldType.getValues()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
+        var _value = _step8.value;
+
+        if (!valuesInNewEnum[_value.name]) {
+          valuesRemovedFromEnums.push({
+            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
+            description: "".concat(_value.name, " was removed from enum type ").concat(typeName, ".")
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError8 = true;
+      _iteratorError8 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
+          _iterator8.return();
+        }
+      } finally {
+        if (_didIteratorError8) {
+          throw _iteratorError8;
+        }
+      }
+    }
+  }
+
   return valuesRemovedFromEnums;
 }
 /**
@@ -489,27 +722,74 @@ function findValuesAddedToEnums(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var valuesAddedToEnums = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr13 = Object.keys(oldTypeMap);
+
+  for (var _i13 = 0; _i13 < _arr13.length; _i13++) {
+    var typeName = _arr13[_i13];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!(0, _definition.isEnumType)(oldType) || !(0, _definition.isEnumType)(newType)) {
-      return;
+      continue;
     }
 
     var valuesInOldEnum = Object.create(null);
-    oldType.getValues().forEach(function (value) {
-      valuesInOldEnum[value.name] = true;
-    });
-    newType.getValues().forEach(function (value) {
-      if (!valuesInOldEnum[value.name]) {
-        valuesAddedToEnums.push({
-          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
-          description: "".concat(value.name, " was added to enum type ").concat(typeName, ".")
-        });
+    var _iteratorNormalCompletion9 = true;
+    var _didIteratorError9 = false;
+    var _iteratorError9 = undefined;
+
+    try {
+      for (var _iterator9 = oldType.getValues()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
+        var value = _step9.value;
+        valuesInOldEnum[value.name] = true;
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError9 = true;
+      _iteratorError9 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
+          _iterator9.return();
+        }
+      } finally {
+        if (_didIteratorError9) {
+          throw _iteratorError9;
+        }
+      }
+    }
+
+    var _iteratorNormalCompletion10 = true;
+    var _didIteratorError10 = false;
+    var _iteratorError10 = undefined;
+
+    try {
+      for (var _iterator10 = newType.getValues()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
+        var _value2 = _step10.value;
+
+        if (!valuesInOldEnum[_value2.name]) {
+          valuesAddedToEnums.push({
+            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
+            description: "".concat(_value2.name, " was added to enum type ").concat(typeName, ".")
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError10 = true;
+      _iteratorError10 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
+          _iterator10.return();
+        }
+      } finally {
+        if (_didIteratorError10) {
+          throw _iteratorError10;
+        }
+      }
+    }
+  }
+
   return valuesAddedToEnums;
 }
 
@@ -517,27 +797,57 @@ function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr14 = Object.keys(oldTypeMap);
+
+  for (var _i14 = 0; _i14 < _arr14.length; _i14++) {
+    var typeName = _arr14[_i14];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!(0, _definition.isObjectType)(oldType) || !(0, _definition.isObjectType)(newType)) {
-      return;
+      continue;
     }
 
     var oldInterfaces = oldType.getInterfaces();
     var newInterfaces = newType.getInterfaces();
-    oldInterfaces.forEach(function (oldInterface) {
-      if (!newInterfaces.some(function (int) {
-        return int.name === oldInterface.name;
-      })) {
-        breakingChanges.push({
-          type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,
-          description: "".concat(typeName, " no longer implements interface ") + "".concat(oldInterface.name, ".")
-        });
+    var _iteratorNormalCompletion11 = true;
+    var _didIteratorError11 = false;
+    var _iteratorError11 = undefined;
+
+    try {
+      var _loop3 = function _loop3() {
+        var oldInterface = _step11.value;
+
+        if (!newInterfaces.some(function (int) {
+          return int.name === oldInterface.name;
+        })) {
+          breakingChanges.push({
+            type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,
+            description: "".concat(typeName, " no longer implements interface ") + "".concat(oldInterface.name, ".")
+          });
+        }
+      };
+
+      for (var _iterator11 = oldInterfaces[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
+        _loop3();
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError11 = true;
+      _iteratorError11 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
+          _iterator11.return();
+        }
+      } finally {
+        if (_didIteratorError11) {
+          throw _iteratorError11;
+        }
+      }
+    }
+  }
+
   return breakingChanges;
 }
 
@@ -545,138 +855,380 @@ function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var interfacesAddedToObjectTypes = [];
-  Object.keys(newTypeMap).forEach(function (typeName) {
+
+  var _arr15 = Object.keys(newTypeMap);
+
+  for (var _i15 = 0; _i15 < _arr15.length; _i15++) {
+    var typeName = _arr15[_i15];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!(0, _definition.isObjectType)(oldType) || !(0, _definition.isObjectType)(newType)) {
-      return;
+      continue;
     }
 
     var oldInterfaces = oldType.getInterfaces();
     var newInterfaces = newType.getInterfaces();
-    newInterfaces.forEach(function (newInterface) {
-      if (!oldInterfaces.some(function (int) {
-        return int.name === newInterface.name;
-      })) {
-        interfacesAddedToObjectTypes.push({
-          type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,
-          description: "".concat(newInterface.name, " added to interfaces implemented ") + "by ".concat(typeName, ".")
-        });
+    var _iteratorNormalCompletion12 = true;
+    var _didIteratorError12 = false;
+    var _iteratorError12 = undefined;
+
+    try {
+      var _loop4 = function _loop4() {
+        var newInterface = _step12.value;
+
+        if (!oldInterfaces.some(function (int) {
+          return int.name === newInterface.name;
+        })) {
+          interfacesAddedToObjectTypes.push({
+            type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,
+            description: "".concat(newInterface.name, " added to interfaces implemented ") + "by ".concat(typeName, ".")
+          });
+        }
+      };
+
+      for (var _iterator12 = newInterfaces[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
+        _loop4();
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError12 = true;
+      _iteratorError12 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
+          _iterator12.return();
+        }
+      } finally {
+        if (_didIteratorError12) {
+          throw _iteratorError12;
+        }
+      }
+    }
+  }
+
   return interfacesAddedToObjectTypes;
 }
 
 function findRemovedDirectives(oldSchema, newSchema) {
   var removedDirectives = [];
   var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);
-  oldSchema.getDirectives().forEach(function (directive) {
-    if (!newSchemaDirectiveMap[directive.name]) {
-      removedDirectives.push({
-        type: BreakingChangeType.DIRECTIVE_REMOVED,
-        description: "".concat(directive.name, " was removed")
-      });
+  var _iteratorNormalCompletion13 = true;
+  var _didIteratorError13 = false;
+  var _iteratorError13 = undefined;
+
+  try {
+    for (var _iterator13 = oldSchema.getDirectives()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
+      var directive = _step13.value;
+
+      if (!newSchemaDirectiveMap[directive.name]) {
+        removedDirectives.push({
+          type: BreakingChangeType.DIRECTIVE_REMOVED,
+          description: "".concat(directive.name, " was removed")
+        });
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError13 = true;
+    _iteratorError13 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
+        _iterator13.return();
+      }
+    } finally {
+      if (_didIteratorError13) {
+        throw _iteratorError13;
+      }
+    }
+  }
+
   return removedDirectives;
 }
 
 function findRemovedArgsForDirective(oldDirective, newDirective) {
   var removedArgs = [];
   var newArgMap = getArgumentMapForDirective(newDirective);
-  oldDirective.args.forEach(function (arg) {
-    if (!newArgMap[arg.name]) {
-      removedArgs.push(arg);
+  var _iteratorNormalCompletion14 = true;
+  var _didIteratorError14 = false;
+  var _iteratorError14 = undefined;
+
+  try {
+    for (var _iterator14 = oldDirective.args[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
+      var arg = _step14.value;
+
+      if (!newArgMap[arg.name]) {
+        removedArgs.push(arg);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError14 = true;
+    _iteratorError14 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
+        _iterator14.return();
+      }
+    } finally {
+      if (_didIteratorError14) {
+        throw _iteratorError14;
+      }
+    }
+  }
+
   return removedArgs;
 }
 
 function findRemovedDirectiveArgs(oldSchema, newSchema) {
   var removedDirectiveArgs = [];
   var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);
-  newSchema.getDirectives().forEach(function (newDirective) {
-    var oldDirective = oldSchemaDirectiveMap[newDirective.name];
+  var _iteratorNormalCompletion15 = true;
+  var _didIteratorError15 = false;
+  var _iteratorError15 = undefined;
+
+  try {
+    for (var _iterator15 = newSchema.getDirectives()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
+      var newDirective = _step15.value;
+      var oldDirective = oldSchemaDirectiveMap[newDirective.name];
+
+      if (!oldDirective) {
+        continue;
+      }
+
+      var _iteratorNormalCompletion16 = true;
+      var _didIteratorError16 = false;
+      var _iteratorError16 = undefined;
 
-    if (!oldDirective) {
-      return;
+      try {
+        for (var _iterator16 = findRemovedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
+          var arg = _step16.value;
+          removedDirectiveArgs.push({
+            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
+            description: "".concat(arg.name, " was removed from ").concat(newDirective.name)
+          });
+        }
+      } catch (err) {
+        _didIteratorError16 = true;
+        _iteratorError16 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
+            _iterator16.return();
+          }
+        } finally {
+          if (_didIteratorError16) {
+            throw _iteratorError16;
+          }
+        }
+      }
+    }
+  } catch (err) {
+    _didIteratorError15 = true;
+    _iteratorError15 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
+        _iterator15.return();
+      }
+    } finally {
+      if (_didIteratorError15) {
+        throw _iteratorError15;
+      }
     }
+  }
 
-    findRemovedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {
-      removedDirectiveArgs.push({
-        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
-        description: "".concat(arg.name, " was removed from ").concat(newDirective.name)
-      });
-    });
-  });
   return removedDirectiveArgs;
 }
 
 function findAddedArgsForDirective(oldDirective, newDirective) {
   var addedArgs = [];
   var oldArgMap = getArgumentMapForDirective(oldDirective);
-  newDirective.args.forEach(function (arg) {
-    if (!oldArgMap[arg.name]) {
-      addedArgs.push(arg);
+  var _iteratorNormalCompletion17 = true;
+  var _didIteratorError17 = false;
+  var _iteratorError17 = undefined;
+
+  try {
+    for (var _iterator17 = newDirective.args[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
+      var arg = _step17.value;
+
+      if (!oldArgMap[arg.name]) {
+        addedArgs.push(arg);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError17 = true;
+    _iteratorError17 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
+        _iterator17.return();
+      }
+    } finally {
+      if (_didIteratorError17) {
+        throw _iteratorError17;
+      }
+    }
+  }
+
   return addedArgs;
 }
 
 function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {
   var addedNonNullableArgs = [];
   var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);
-  newSchema.getDirectives().forEach(function (newDirective) {
-    var oldDirective = oldSchemaDirectiveMap[newDirective.name];
+  var _iteratorNormalCompletion18 = true;
+  var _didIteratorError18 = false;
+  var _iteratorError18 = undefined;
 
-    if (!oldDirective) {
-      return;
-    }
+  try {
+    for (var _iterator18 = newSchema.getDirectives()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
+      var newDirective = _step18.value;
+      var oldDirective = oldSchemaDirectiveMap[newDirective.name];
 
-    findAddedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {
-      if (!(0, _definition.isNonNullType)(arg.type)) {
-        return;
+      if (!oldDirective) {
+        continue;
       }
 
-      addedNonNullableArgs.push({
-        type: BreakingChangeType.NON_NULL_DIRECTIVE_ARG_ADDED,
-        description: "A non-null arg ".concat(arg.name, " on directive ") + "".concat(newDirective.name, " was added")
-      });
-    });
-  });
+      var _iteratorNormalCompletion19 = true;
+      var _didIteratorError19 = false;
+      var _iteratorError19 = undefined;
+
+      try {
+        for (var _iterator19 = findAddedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
+          var arg = _step19.value;
+
+          if (!(0, _definition.isNonNullType)(arg.type)) {
+            continue;
+          }
+
+          addedNonNullableArgs.push({
+            type: BreakingChangeType.NON_NULL_DIRECTIVE_ARG_ADDED,
+            description: "A non-null arg ".concat(arg.name, " on directive ") + "".concat(newDirective.name, " was added")
+          });
+        }
+      } catch (err) {
+        _didIteratorError19 = true;
+        _iteratorError19 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
+            _iterator19.return();
+          }
+        } finally {
+          if (_didIteratorError19) {
+            throw _iteratorError19;
+          }
+        }
+      }
+    }
+  } catch (err) {
+    _didIteratorError18 = true;
+    _iteratorError18 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
+        _iterator18.return();
+      }
+    } finally {
+      if (_didIteratorError18) {
+        throw _iteratorError18;
+      }
+    }
+  }
+
   return addedNonNullableArgs;
 }
 
 function findRemovedLocationsForDirective(oldDirective, newDirective) {
   var removedLocations = [];
   var newLocationSet = new Set(newDirective.locations);
-  oldDirective.locations.forEach(function (oldLocation) {
-    if (!newLocationSet.has(oldLocation)) {
-      removedLocations.push(oldLocation);
+  var _iteratorNormalCompletion20 = true;
+  var _didIteratorError20 = false;
+  var _iteratorError20 = undefined;
+
+  try {
+    for (var _iterator20 = oldDirective.locations[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
+      var oldLocation = _step20.value;
+
+      if (!newLocationSet.has(oldLocation)) {
+        removedLocations.push(oldLocation);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError20 = true;
+    _iteratorError20 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion20 && _iterator20.return != null) {
+        _iterator20.return();
+      }
+    } finally {
+      if (_didIteratorError20) {
+        throw _iteratorError20;
+      }
+    }
+  }
+
   return removedLocations;
 }
 
 function findRemovedDirectiveLocations(oldSchema, newSchema) {
   var removedLocations = [];
   var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);
-  newSchema.getDirectives().forEach(function (newDirective) {
-    var oldDirective = oldSchemaDirectiveMap[newDirective.name];
+  var _iteratorNormalCompletion21 = true;
+  var _didIteratorError21 = false;
+  var _iteratorError21 = undefined;
 
-    if (!oldDirective) {
-      return;
+  try {
+    for (var _iterator21 = newSchema.getDirectives()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
+      var newDirective = _step21.value;
+      var oldDirective = oldSchemaDirectiveMap[newDirective.name];
+
+      if (!oldDirective) {
+        continue;
+      }
+
+      var _iteratorNormalCompletion22 = true;
+      var _didIteratorError22 = false;
+      var _iteratorError22 = undefined;
+
+      try {
+        for (var _iterator22 = findRemovedLocationsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
+          var location = _step22.value;
+          removedLocations.push({
+            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
+            description: "".concat(location, " was removed from ").concat(newDirective.name)
+          });
+        }
+      } catch (err) {
+        _didIteratorError22 = true;
+        _iteratorError22 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
+            _iterator22.return();
+          }
+        } finally {
+          if (_didIteratorError22) {
+            throw _iteratorError22;
+          }
+        }
+      }
+    }
+  } catch (err) {
+    _didIteratorError21 = true;
+    _iteratorError21 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion21 && _iterator21.return != null) {
+        _iterator21.return();
+      }
+    } finally {
+      if (_didIteratorError21) {
+        throw _iteratorError21;
+      }
     }
+  }
 
-    findRemovedLocationsForDirective(oldDirective, newDirective).forEach(function (location) {
-      removedLocations.push({
-        type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
-        description: "".concat(location, " was removed from ").concat(newDirective.name)
-      });
-    });
-  });
   return removedLocations;
 }
 
diff --git a/utilities/findBreakingChanges.js.flow b/utilities/findBreakingChanges.js.flow
index f4b65fd..e2d444d 100644
--- a/utilities/findBreakingChanges.js.flow
+++ b/utilities/findBreakingChanges.js.flow
@@ -26,8 +26,8 @@ import type {
   GraphQLArgument,
 } from '../type/definition';
 
-import { GraphQLDirective } from '../type/directives';
-import { GraphQLSchema } from '../type/schema';
+import type { GraphQLDirective } from '../type/directives';
+import type { GraphQLSchema } from '../type/schema';
 import keyMap from '../jsutils/keyMap';
 
 import type { ObjMap } from '../jsutils/ObjMap';
@@ -125,14 +125,14 @@ export function findRemovedTypes(
   const newTypeMap = newSchema.getTypeMap();
 
   const breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(oldTypeMap)) {
     if (!newTypeMap[typeName]) {
       breakingChanges.push({
         type: BreakingChangeType.TYPE_REMOVED,
         description: `${typeName} was removed.`,
       });
     }
-  });
+  }
   return breakingChanges;
 }
 
@@ -148,9 +148,9 @@ export function findTypesThatChangedKind(
   const newTypeMap = newSchema.getTypeMap();
 
   const breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(oldTypeMap)) {
     if (!newTypeMap[typeName]) {
-      return;
+      continue;
     }
     const oldType = oldTypeMap[typeName];
     const newType = newTypeMap[typeName];
@@ -162,7 +162,7 @@ export function findTypesThatChangedKind(
           `${typeKindName(oldType)} to ${typeKindName(newType)}.`,
       });
     }
-  });
+  }
   return breakingChanges;
 }
 
@@ -185,7 +185,7 @@ export function findArgChanges(
   const breakingChanges = [];
   const dangerousChanges = [];
 
-  Object.keys(oldTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(oldTypeMap)) {
     const oldType = oldTypeMap[typeName];
     const newType = newTypeMap[typeName];
     if (
@@ -193,18 +193,18 @@ export function findArgChanges(
       !(isObjectType(newType) || isInterfaceType(newType)) ||
       newType.constructor !== oldType.constructor
     ) {
-      return;
+      continue;
     }
 
     const oldTypeFields: GraphQLFieldMap<*, *> = oldType.getFields();
     const newTypeFields: GraphQLFieldMap<*, *> = newType.getFields();
 
-    Object.keys(oldTypeFields).forEach(fieldName => {
+    for (const fieldName of Object.keys(oldTypeFields)) {
       if (!newTypeFields[fieldName]) {
-        return;
+        continue;
       }
 
-      oldTypeFields[fieldName].args.forEach(oldArgDef => {
+      for (const oldArgDef of oldTypeFields[fieldName].args) {
         const newArgs = newTypeFields[fieldName].args;
         const newArgDef = newArgs.find(arg => arg.name === oldArgDef.name);
 
@@ -241,9 +241,9 @@ export function findArgChanges(
             });
           }
         }
-      });
+      }
       // Check if a non-null arg was added to the field
-      newTypeFields[fieldName].args.forEach(newArgDef => {
+      for (const newArgDef of newTypeFields[fieldName].args) {
         const oldArgs = oldTypeFields[fieldName].args;
         const oldArgDef = oldArgs.find(arg => arg.name === newArgDef.name);
         if (!oldArgDef) {
@@ -263,9 +263,9 @@ export function findArgChanges(
             });
           }
         }
-      });
-    });
-  });
+      }
+    }
+  }
 
   return {
     breakingChanges,
@@ -303,7 +303,7 @@ export function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(
   const newTypeMap = newSchema.getTypeMap();
 
   const breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(oldTypeMap)) {
     const oldType = oldTypeMap[typeName];
     const newType = newTypeMap[typeName];
     if (
@@ -311,12 +311,12 @@ export function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(
       !(isObjectType(newType) || isInterfaceType(newType)) ||
       newType.constructor !== oldType.constructor
     ) {
-      return;
+      continue;
     }
 
     const oldTypeFieldsDef = oldType.getFields();
     const newTypeFieldsDef = newType.getFields();
-    Object.keys(oldTypeFieldsDef).forEach(fieldName => {
+    for (const fieldName of Object.keys(oldTypeFieldsDef)) {
       // Check if the field is missing on the type in the new schema.
       if (!(fieldName in newTypeFieldsDef)) {
         breakingChanges.push({
@@ -345,8 +345,8 @@ export function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(
           });
         }
       }
-    });
-  });
+    }
+  }
   return breakingChanges;
 }
 
@@ -362,16 +362,16 @@ export function findFieldsThatChangedTypeOnInputObjectTypes(
 
   const breakingChanges = [];
   const dangerousChanges = [];
-  Object.keys(oldTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(oldTypeMap)) {
     const oldType = oldTypeMap[typeName];
     const newType = newTypeMap[typeName];
     if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {
-      return;
+      continue;
     }
 
     const oldTypeFieldsDef = oldType.getFields();
     const newTypeFieldsDef = newType.getFields();
-    Object.keys(oldTypeFieldsDef).forEach(fieldName => {
+    for (const fieldName of Object.keys(oldTypeFieldsDef)) {
       // Check if the field is missing on the type in the new schema.
       if (!(fieldName in newTypeFieldsDef)) {
         breakingChanges.push({
@@ -401,9 +401,9 @@ export function findFieldsThatChangedTypeOnInputObjectTypes(
           });
         }
       }
-    });
+    }
     // Check if a field was added to the input object type
-    Object.keys(newTypeFieldsDef).forEach(fieldName => {
+    for (const fieldName of Object.keys(newTypeFieldsDef)) {
       if (!(fieldName in oldTypeFieldsDef)) {
         if (isNonNullType(newTypeFieldsDef[fieldName].type)) {
           breakingChanges.push({
@@ -421,8 +421,8 @@ export function findFieldsThatChangedTypeOnInputObjectTypes(
           });
         }
       }
-    });
-  });
+    }
+  }
   return {
     breakingChanges,
     dangerousChanges,
@@ -505,25 +505,25 @@ export function findTypesRemovedFromUnions(
   const newTypeMap = newSchema.getTypeMap();
 
   const typesRemovedFromUnion = [];
-  Object.keys(oldTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(oldTypeMap)) {
     const oldType = oldTypeMap[typeName];
     const newType = newTypeMap[typeName];
     if (!isUnionType(oldType) || !isUnionType(newType)) {
-      return;
+      continue;
     }
     const typeNamesInNewUnion = Object.create(null);
-    newType.getTypes().forEach(type => {
+    for (const type of newType.getTypes()) {
       typeNamesInNewUnion[type.name] = true;
-    });
-    oldType.getTypes().forEach(type => {
+    }
+    for (const type of oldType.getTypes()) {
       if (!typeNamesInNewUnion[type.name]) {
         typesRemovedFromUnion.push({
           type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
           description: `${type.name} was removed from union type ${typeName}.`,
         });
       }
-    });
-  });
+    }
+  }
   return typesRemovedFromUnion;
 }
 
@@ -539,25 +539,25 @@ export function findTypesAddedToUnions(
   const newTypeMap = newSchema.getTypeMap();
 
   const typesAddedToUnion = [];
-  Object.keys(newTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(newTypeMap)) {
     const oldType = oldTypeMap[typeName];
     const newType = newTypeMap[typeName];
     if (!isUnionType(oldType) || !isUnionType(newType)) {
-      return;
+      continue;
     }
     const typeNamesInOldUnion = Object.create(null);
-    oldType.getTypes().forEach(type => {
+    for (const type of oldType.getTypes()) {
       typeNamesInOldUnion[type.name] = true;
-    });
-    newType.getTypes().forEach(type => {
+    }
+    for (const type of newType.getTypes()) {
       if (!typeNamesInOldUnion[type.name]) {
         typesAddedToUnion.push({
           type: DangerousChangeType.TYPE_ADDED_TO_UNION,
           description: `${type.name} was added to union type ${typeName}.`,
         });
       }
-    });
-  });
+    }
+  }
   return typesAddedToUnion;
 }
 /**
@@ -572,25 +572,25 @@ export function findValuesRemovedFromEnums(
   const newTypeMap = newSchema.getTypeMap();
 
   const valuesRemovedFromEnums = [];
-  Object.keys(oldTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(oldTypeMap)) {
     const oldType = oldTypeMap[typeName];
     const newType = newTypeMap[typeName];
     if (!isEnumType(oldType) || !isEnumType(newType)) {
-      return;
+      continue;
     }
     const valuesInNewEnum = Object.create(null);
-    newType.getValues().forEach(value => {
+    for (const value of newType.getValues()) {
       valuesInNewEnum[value.name] = true;
-    });
-    oldType.getValues().forEach(value => {
+    }
+    for (const value of oldType.getValues()) {
       if (!valuesInNewEnum[value.name]) {
         valuesRemovedFromEnums.push({
           type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
           description: `${value.name} was removed from enum type ${typeName}.`,
         });
       }
-    });
-  });
+    }
+  }
   return valuesRemovedFromEnums;
 }
 
@@ -606,26 +606,26 @@ export function findValuesAddedToEnums(
   const newTypeMap = newSchema.getTypeMap();
 
   const valuesAddedToEnums = [];
-  Object.keys(oldTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(oldTypeMap)) {
     const oldType = oldTypeMap[typeName];
     const newType = newTypeMap[typeName];
     if (!isEnumType(oldType) || !isEnumType(newType)) {
-      return;
+      continue;
     }
 
     const valuesInOldEnum = Object.create(null);
-    oldType.getValues().forEach(value => {
+    for (const value of oldType.getValues()) {
       valuesInOldEnum[value.name] = true;
-    });
-    newType.getValues().forEach(value => {
+    }
+    for (const value of newType.getValues()) {
       if (!valuesInOldEnum[value.name]) {
         valuesAddedToEnums.push({
           type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
           description: `${value.name} was added to enum type ${typeName}.`,
         });
       }
-    });
-  });
+    }
+  }
   return valuesAddedToEnums;
 }
 
@@ -637,16 +637,16 @@ export function findInterfacesRemovedFromObjectTypes(
   const newTypeMap = newSchema.getTypeMap();
   const breakingChanges = [];
 
-  Object.keys(oldTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(oldTypeMap)) {
     const oldType = oldTypeMap[typeName];
     const newType = newTypeMap[typeName];
     if (!isObjectType(oldType) || !isObjectType(newType)) {
-      return;
+      continue;
     }
 
     const oldInterfaces = oldType.getInterfaces();
     const newInterfaces = newType.getInterfaces();
-    oldInterfaces.forEach(oldInterface => {
+    for (const oldInterface of oldInterfaces) {
       if (!newInterfaces.some(int => int.name === oldInterface.name)) {
         breakingChanges.push({
           type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,
@@ -655,8 +655,8 @@ export function findInterfacesRemovedFromObjectTypes(
             `${oldInterface.name}.`,
         });
       }
-    });
-  });
+    }
+  }
   return breakingChanges;
 }
 
@@ -668,16 +668,16 @@ export function findInterfacesAddedToObjectTypes(
   const newTypeMap = newSchema.getTypeMap();
   const interfacesAddedToObjectTypes = [];
 
-  Object.keys(newTypeMap).forEach(typeName => {
+  for (const typeName of Object.keys(newTypeMap)) {
     const oldType = oldTypeMap[typeName];
     const newType = newTypeMap[typeName];
     if (!isObjectType(oldType) || !isObjectType(newType)) {
-      return;
+      continue;
     }
 
     const oldInterfaces = oldType.getInterfaces();
     const newInterfaces = newType.getInterfaces();
-    newInterfaces.forEach(newInterface => {
+    for (const newInterface of newInterfaces) {
       if (!oldInterfaces.some(int => int.name === newInterface.name)) {
         interfacesAddedToObjectTypes.push({
           type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,
@@ -686,8 +686,8 @@ export function findInterfacesAddedToObjectTypes(
             `by ${typeName}.`,
         });
       }
-    });
-  });
+    }
+  }
   return interfacesAddedToObjectTypes;
 }
 
@@ -698,14 +698,14 @@ export function findRemovedDirectives(
   const removedDirectives = [];
 
   const newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);
-  oldSchema.getDirectives().forEach(directive => {
+  for (const directive of oldSchema.getDirectives()) {
     if (!newSchemaDirectiveMap[directive.name]) {
       removedDirectives.push({
         type: BreakingChangeType.DIRECTIVE_REMOVED,
         description: `${directive.name} was removed`,
       });
     }
-  });
+  }
 
   return removedDirectives;
 }
@@ -717,11 +717,11 @@ function findRemovedArgsForDirective(
   const removedArgs = [];
   const newArgMap = getArgumentMapForDirective(newDirective);
 
-  oldDirective.args.forEach(arg => {
+  for (const arg of oldDirective.args) {
     if (!newArgMap[arg.name]) {
       removedArgs.push(arg);
     }
-  });
+  }
 
   return removedArgs;
 }
@@ -733,19 +733,19 @@ export function findRemovedDirectiveArgs(
   const removedDirectiveArgs = [];
   const oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);
 
-  newSchema.getDirectives().forEach(newDirective => {
+  for (const newDirective of newSchema.getDirectives()) {
     const oldDirective = oldSchemaDirectiveMap[newDirective.name];
     if (!oldDirective) {
-      return;
+      continue;
     }
 
-    findRemovedArgsForDirective(oldDirective, newDirective).forEach(arg => {
+    for (const arg of findRemovedArgsForDirective(oldDirective, newDirective)) {
       removedDirectiveArgs.push({
         type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
         description: `${arg.name} was removed from ${newDirective.name}`,
       });
-    });
-  });
+    }
+  }
 
   return removedDirectiveArgs;
 }
@@ -757,11 +757,11 @@ function findAddedArgsForDirective(
   const addedArgs = [];
   const oldArgMap = getArgumentMapForDirective(oldDirective);
 
-  newDirective.args.forEach(arg => {
+  for (const arg of newDirective.args) {
     if (!oldArgMap[arg.name]) {
       addedArgs.push(arg);
     }
-  });
+  }
 
   return addedArgs;
 }
@@ -773,15 +773,15 @@ export function findAddedNonNullDirectiveArgs(
   const addedNonNullableArgs = [];
   const oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);
 
-  newSchema.getDirectives().forEach(newDirective => {
+  for (const newDirective of newSchema.getDirectives()) {
     const oldDirective = oldSchemaDirectiveMap[newDirective.name];
     if (!oldDirective) {
-      return;
+      continue;
     }
 
-    findAddedArgsForDirective(oldDirective, newDirective).forEach(arg => {
+    for (const arg of findAddedArgsForDirective(oldDirective, newDirective)) {
       if (!isNonNullType(arg.type)) {
-        return;
+        continue;
       }
 
       addedNonNullableArgs.push({
@@ -790,8 +790,8 @@ export function findAddedNonNullDirectiveArgs(
           `A non-null arg ${arg.name} on directive ` +
           `${newDirective.name} was added`,
       });
-    });
-  });
+    }
+  }
 
   return addedNonNullableArgs;
 }
@@ -803,11 +803,11 @@ export function findRemovedLocationsForDirective(
   const removedLocations = [];
   const newLocationSet = new Set(newDirective.locations);
 
-  oldDirective.locations.forEach(oldLocation => {
+  for (const oldLocation of oldDirective.locations) {
     if (!newLocationSet.has(oldLocation)) {
       removedLocations.push(oldLocation);
     }
-  });
+  }
 
   return removedLocations;
 }
@@ -819,21 +819,22 @@ export function findRemovedDirectiveLocations(
   const removedLocations = [];
   const oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);
 
-  newSchema.getDirectives().forEach(newDirective => {
+  for (const newDirective of newSchema.getDirectives()) {
     const oldDirective = oldSchemaDirectiveMap[newDirective.name];
     if (!oldDirective) {
-      return;
+      continue;
     }
 
-    findRemovedLocationsForDirective(oldDirective, newDirective).forEach(
-      location => {
-        removedLocations.push({
-          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
-          description: `${location} was removed from ${newDirective.name}`,
-        });
-      },
-    );
-  });
+    for (const location of findRemovedLocationsForDirective(
+      oldDirective,
+      newDirective,
+    )) {
+      removedLocations.push({
+        type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
+        description: `${location} was removed from ${newDirective.name}`,
+      });
+    }
+  }
 
   return removedLocations;
 }
diff --git a/utilities/findBreakingChanges.mjs b/utilities/findBreakingChanges.mjs
index c37b690..6fa35b9 100644
--- a/utilities/findBreakingChanges.mjs
+++ b/utilities/findBreakingChanges.mjs
@@ -7,8 +7,6 @@
  *  strict
  */
 import { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType } from '../type/definition';
-import { GraphQLDirective } from '../type/directives';
-import { GraphQLSchema } from '../type/schema';
 import keyMap from '../jsutils/keyMap';
 export var BreakingChangeType = {
   FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',
@@ -60,14 +58,20 @@ export function findRemovedTypes(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr = Object.keys(oldTypeMap);
+
+  for (var _i = 0; _i < _arr.length; _i++) {
+    var typeName = _arr[_i];
+
     if (!newTypeMap[typeName]) {
       breakingChanges.push({
         type: BreakingChangeType.TYPE_REMOVED,
         description: "".concat(typeName, " was removed.")
       });
     }
-  });
+  }
+
   return breakingChanges;
 }
 /**
@@ -79,9 +83,14 @@ export function findTypesThatChangedKind(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr2 = Object.keys(oldTypeMap);
+
+  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
+    var typeName = _arr2[_i2];
+
     if (!newTypeMap[typeName]) {
-      return;
+      continue;
     }
 
     var oldType = oldTypeMap[typeName];
@@ -93,7 +102,8 @@ export function findTypesThatChangedKind(oldSchema, newSchema) {
         description: "".concat(typeName, " changed from ") + "".concat(typeKindName(oldType), " to ").concat(typeKindName(newType), ".")
       });
     }
-  });
+  }
+
   return breakingChanges;
 }
 /**
@@ -108,71 +118,130 @@ export function findArgChanges(oldSchema, newSchema) {
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
   var dangerousChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr3 = Object.keys(oldTypeMap);
+
+  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
+    var typeName = _arr3[_i3];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {
-      return;
+      continue;
     }
 
     var oldTypeFields = oldType.getFields();
     var newTypeFields = newType.getFields();
-    Object.keys(oldTypeFields).forEach(function (fieldName) {
+
+    var _arr4 = Object.keys(oldTypeFields);
+
+    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {
+      var fieldName = _arr4[_i4];
+
       if (!newTypeFields[fieldName]) {
-        return;
+        continue;
       }
 
-      oldTypeFields[fieldName].args.forEach(function (oldArgDef) {
-        var newArgs = newTypeFields[fieldName].args;
-        var newArgDef = newArgs.find(function (arg) {
-          return arg.name === oldArgDef.name;
-        }); // Arg not present
+      var _iteratorNormalCompletion = true;
+      var _didIteratorError = false;
+      var _iteratorError = undefined;
 
-        if (!newArgDef) {
-          breakingChanges.push({
-            type: BreakingChangeType.ARG_REMOVED,
-            description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " was removed")
-          });
-        } else {
-          var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);
+      try {
+        var _loop = function _loop() {
+          var oldArgDef = _step.value;
+          var newArgs = newTypeFields[fieldName].args;
+          var newArgDef = newArgs.find(function (arg) {
+            return arg.name === oldArgDef.name;
+          }); // Arg not present
 
-          if (!isSafe) {
+          if (!newArgDef) {
             breakingChanges.push({
-              type: BreakingChangeType.ARG_CHANGED_KIND,
-              description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " has changed type from ") + "".concat(oldArgDef.type.toString(), " to ").concat(newArgDef.type.toString())
-            });
-          } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {
-            dangerousChanges.push({
-              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
-              description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " has changed defaultValue")
+              type: BreakingChangeType.ARG_REMOVED,
+              description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " was removed")
             });
+          } else {
+            var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);
+
+            if (!isSafe) {
+              breakingChanges.push({
+                type: BreakingChangeType.ARG_CHANGED_KIND,
+                description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " has changed type from ") + "".concat(oldArgDef.type.toString(), " to ").concat(newArgDef.type.toString())
+              });
+            } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {
+              dangerousChanges.push({
+                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
+                description: "".concat(oldType.name, ".").concat(fieldName, " arg ") + "".concat(oldArgDef.name, " has changed defaultValue")
+              });
+            }
+          }
+        };
+
+        for (var _iterator = oldTypeFields[fieldName].args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+          _loop();
+        } // Check if a non-null arg was added to the field
+
+      } catch (err) {
+        _didIteratorError = true;
+        _iteratorError = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion && _iterator.return != null) {
+            _iterator.return();
+          }
+        } finally {
+          if (_didIteratorError) {
+            throw _iteratorError;
           }
         }
-      }); // Check if a non-null arg was added to the field
+      }
 
-      newTypeFields[fieldName].args.forEach(function (newArgDef) {
-        var oldArgs = oldTypeFields[fieldName].args;
-        var oldArgDef = oldArgs.find(function (arg) {
-          return arg.name === newArgDef.name;
-        });
+      var _iteratorNormalCompletion2 = true;
+      var _didIteratorError2 = false;
+      var _iteratorError2 = undefined;
 
-        if (!oldArgDef) {
-          if (isNonNullType(newArgDef.type)) {
-            breakingChanges.push({
-              type: BreakingChangeType.NON_NULL_ARG_ADDED,
-              description: "A non-null arg ".concat(newArgDef.name, " on ") + "".concat(newType.name, ".").concat(fieldName, " was added")
-            });
-          } else {
-            dangerousChanges.push({
-              type: DangerousChangeType.NULLABLE_ARG_ADDED,
-              description: "A nullable arg ".concat(newArgDef.name, " on ") + "".concat(newType.name, ".").concat(fieldName, " was added")
-            });
+      try {
+        var _loop2 = function _loop2() {
+          var newArgDef = _step2.value;
+          var oldArgs = oldTypeFields[fieldName].args;
+          var oldArgDef = oldArgs.find(function (arg) {
+            return arg.name === newArgDef.name;
+          });
+
+          if (!oldArgDef) {
+            if (isNonNullType(newArgDef.type)) {
+              breakingChanges.push({
+                type: BreakingChangeType.NON_NULL_ARG_ADDED,
+                description: "A non-null arg ".concat(newArgDef.name, " on ") + "".concat(newType.name, ".").concat(fieldName, " was added")
+              });
+            } else {
+              dangerousChanges.push({
+                type: DangerousChangeType.NULLABLE_ARG_ADDED,
+                description: "A nullable arg ".concat(newArgDef.name, " on ") + "".concat(newType.name, ".").concat(fieldName, " was added")
+              });
+            }
           }
+        };
+
+        for (var _iterator2 = newTypeFields[fieldName].args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+          _loop2();
         }
-      });
-    });
-  });
+      } catch (err) {
+        _didIteratorError2 = true;
+        _iteratorError2 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+            _iterator2.return();
+          }
+        } finally {
+          if (_didIteratorError2) {
+            throw _iteratorError2;
+          }
+        }
+      }
+    }
+  }
+
   return {
     breakingChanges: breakingChanges,
     dangerousChanges: dangerousChanges
@@ -211,17 +280,26 @@ export function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, new
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr5 = Object.keys(oldTypeMap);
+
+  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {
+    var typeName = _arr5[_i5];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!(isObjectType(oldType) || isInterfaceType(oldType)) || !(isObjectType(newType) || isInterfaceType(newType)) || newType.constructor !== oldType.constructor) {
-      return;
+      continue;
     }
 
     var oldTypeFieldsDef = oldType.getFields();
     var newTypeFieldsDef = newType.getFields();
-    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {
+
+    var _arr6 = Object.keys(oldTypeFieldsDef);
+
+    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {
+      var fieldName = _arr6[_i6];
+
       // Check if the field is missing on the type in the new schema.
       if (!(fieldName in newTypeFieldsDef)) {
         breakingChanges.push({
@@ -242,8 +320,9 @@ export function findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, new
           });
         }
       }
-    });
-  });
+    }
+  }
+
   return breakingChanges;
 }
 export function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {
@@ -251,17 +330,26 @@ export function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
   var dangerousChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr7 = Object.keys(oldTypeMap);
+
+  for (var _i7 = 0; _i7 < _arr7.length; _i7++) {
+    var typeName = _arr7[_i7];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!isInputObjectType(oldType) || !isInputObjectType(newType)) {
-      return;
+      continue;
     }
 
     var oldTypeFieldsDef = oldType.getFields();
     var newTypeFieldsDef = newType.getFields();
-    Object.keys(oldTypeFieldsDef).forEach(function (fieldName) {
+
+    var _arr8 = Object.keys(oldTypeFieldsDef);
+
+    for (var _i8 = 0; _i8 < _arr8.length; _i8++) {
+      var fieldName = _arr8[_i8];
+
       // Check if the field is missing on the type in the new schema.
       if (!(fieldName in newTypeFieldsDef)) {
         breakingChanges.push({
@@ -282,24 +370,30 @@ export function findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema
           });
         }
       }
-    }); // Check if a field was added to the input object type
+    } // Check if a field was added to the input object type
+
 
-    Object.keys(newTypeFieldsDef).forEach(function (fieldName) {
-      if (!(fieldName in oldTypeFieldsDef)) {
-        if (isNonNullType(newTypeFieldsDef[fieldName].type)) {
+    var _arr9 = Object.keys(newTypeFieldsDef);
+
+    for (var _i9 = 0; _i9 < _arr9.length; _i9++) {
+      var _fieldName = _arr9[_i9];
+
+      if (!(_fieldName in oldTypeFieldsDef)) {
+        if (isNonNullType(newTypeFieldsDef[_fieldName].type)) {
           breakingChanges.push({
             type: BreakingChangeType.NON_NULL_INPUT_FIELD_ADDED,
-            description: "A non-null field ".concat(fieldName, " on ") + "input type ".concat(newType.name, " was added.")
+            description: "A non-null field ".concat(_fieldName, " on ") + "input type ".concat(newType.name, " was added.")
           });
         } else {
           dangerousChanges.push({
             type: DangerousChangeType.NULLABLE_INPUT_FIELD_ADDED,
-            description: "A nullable field ".concat(fieldName, " on ") + "input type ".concat(newType.name, " was added.")
+            description: "A nullable field ".concat(_fieldName, " on ") + "input type ".concat(newType.name, " was added.")
           });
         }
       }
-    });
-  });
+    }
+  }
+
   return {
     breakingChanges: breakingChanges,
     dangerousChanges: dangerousChanges
@@ -352,27 +446,74 @@ export function findTypesRemovedFromUnions(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var typesRemovedFromUnion = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr10 = Object.keys(oldTypeMap);
+
+  for (var _i10 = 0; _i10 < _arr10.length; _i10++) {
+    var typeName = _arr10[_i10];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!isUnionType(oldType) || !isUnionType(newType)) {
-      return;
+      continue;
     }
 
     var typeNamesInNewUnion = Object.create(null);
-    newType.getTypes().forEach(function (type) {
-      typeNamesInNewUnion[type.name] = true;
-    });
-    oldType.getTypes().forEach(function (type) {
-      if (!typeNamesInNewUnion[type.name]) {
-        typesRemovedFromUnion.push({
-          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
-          description: "".concat(type.name, " was removed from union type ").concat(typeName, ".")
-        });
+    var _iteratorNormalCompletion3 = true;
+    var _didIteratorError3 = false;
+    var _iteratorError3 = undefined;
+
+    try {
+      for (var _iterator3 = newType.getTypes()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
+        var type = _step3.value;
+        typeNamesInNewUnion[type.name] = true;
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError3 = true;
+      _iteratorError3 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
+          _iterator3.return();
+        }
+      } finally {
+        if (_didIteratorError3) {
+          throw _iteratorError3;
+        }
+      }
+    }
+
+    var _iteratorNormalCompletion4 = true;
+    var _didIteratorError4 = false;
+    var _iteratorError4 = undefined;
+
+    try {
+      for (var _iterator4 = oldType.getTypes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
+        var _type = _step4.value;
+
+        if (!typeNamesInNewUnion[_type.name]) {
+          typesRemovedFromUnion.push({
+            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
+            description: "".concat(_type.name, " was removed from union type ").concat(typeName, ".")
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError4 = true;
+      _iteratorError4 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
+          _iterator4.return();
+        }
+      } finally {
+        if (_didIteratorError4) {
+          throw _iteratorError4;
+        }
+      }
+    }
+  }
+
   return typesRemovedFromUnion;
 }
 /**
@@ -384,27 +525,74 @@ export function findTypesAddedToUnions(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var typesAddedToUnion = [];
-  Object.keys(newTypeMap).forEach(function (typeName) {
+
+  var _arr11 = Object.keys(newTypeMap);
+
+  for (var _i11 = 0; _i11 < _arr11.length; _i11++) {
+    var typeName = _arr11[_i11];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!isUnionType(oldType) || !isUnionType(newType)) {
-      return;
+      continue;
     }
 
     var typeNamesInOldUnion = Object.create(null);
-    oldType.getTypes().forEach(function (type) {
-      typeNamesInOldUnion[type.name] = true;
-    });
-    newType.getTypes().forEach(function (type) {
-      if (!typeNamesInOldUnion[type.name]) {
-        typesAddedToUnion.push({
-          type: DangerousChangeType.TYPE_ADDED_TO_UNION,
-          description: "".concat(type.name, " was added to union type ").concat(typeName, ".")
-        });
+    var _iteratorNormalCompletion5 = true;
+    var _didIteratorError5 = false;
+    var _iteratorError5 = undefined;
+
+    try {
+      for (var _iterator5 = oldType.getTypes()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
+        var type = _step5.value;
+        typeNamesInOldUnion[type.name] = true;
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError5 = true;
+      _iteratorError5 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
+          _iterator5.return();
+        }
+      } finally {
+        if (_didIteratorError5) {
+          throw _iteratorError5;
+        }
+      }
+    }
+
+    var _iteratorNormalCompletion6 = true;
+    var _didIteratorError6 = false;
+    var _iteratorError6 = undefined;
+
+    try {
+      for (var _iterator6 = newType.getTypes()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
+        var _type2 = _step6.value;
+
+        if (!typeNamesInOldUnion[_type2.name]) {
+          typesAddedToUnion.push({
+            type: DangerousChangeType.TYPE_ADDED_TO_UNION,
+            description: "".concat(_type2.name, " was added to union type ").concat(typeName, ".")
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError6 = true;
+      _iteratorError6 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
+          _iterator6.return();
+        }
+      } finally {
+        if (_didIteratorError6) {
+          throw _iteratorError6;
+        }
+      }
+    }
+  }
+
   return typesAddedToUnion;
 }
 /**
@@ -416,27 +604,74 @@ export function findValuesRemovedFromEnums(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var valuesRemovedFromEnums = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr12 = Object.keys(oldTypeMap);
+
+  for (var _i12 = 0; _i12 < _arr12.length; _i12++) {
+    var typeName = _arr12[_i12];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!isEnumType(oldType) || !isEnumType(newType)) {
-      return;
+      continue;
     }
 
     var valuesInNewEnum = Object.create(null);
-    newType.getValues().forEach(function (value) {
-      valuesInNewEnum[value.name] = true;
-    });
-    oldType.getValues().forEach(function (value) {
-      if (!valuesInNewEnum[value.name]) {
-        valuesRemovedFromEnums.push({
-          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
-          description: "".concat(value.name, " was removed from enum type ").concat(typeName, ".")
-        });
+    var _iteratorNormalCompletion7 = true;
+    var _didIteratorError7 = false;
+    var _iteratorError7 = undefined;
+
+    try {
+      for (var _iterator7 = newType.getValues()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
+        var value = _step7.value;
+        valuesInNewEnum[value.name] = true;
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError7 = true;
+      _iteratorError7 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
+          _iterator7.return();
+        }
+      } finally {
+        if (_didIteratorError7) {
+          throw _iteratorError7;
+        }
+      }
+    }
+
+    var _iteratorNormalCompletion8 = true;
+    var _didIteratorError8 = false;
+    var _iteratorError8 = undefined;
+
+    try {
+      for (var _iterator8 = oldType.getValues()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
+        var _value = _step8.value;
+
+        if (!valuesInNewEnum[_value.name]) {
+          valuesRemovedFromEnums.push({
+            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
+            description: "".concat(_value.name, " was removed from enum type ").concat(typeName, ".")
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError8 = true;
+      _iteratorError8 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
+          _iterator8.return();
+        }
+      } finally {
+        if (_didIteratorError8) {
+          throw _iteratorError8;
+        }
+      }
+    }
+  }
+
   return valuesRemovedFromEnums;
 }
 /**
@@ -448,189 +683,508 @@ export function findValuesAddedToEnums(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var valuesAddedToEnums = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr13 = Object.keys(oldTypeMap);
+
+  for (var _i13 = 0; _i13 < _arr13.length; _i13++) {
+    var typeName = _arr13[_i13];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!isEnumType(oldType) || !isEnumType(newType)) {
-      return;
+      continue;
     }
 
     var valuesInOldEnum = Object.create(null);
-    oldType.getValues().forEach(function (value) {
-      valuesInOldEnum[value.name] = true;
-    });
-    newType.getValues().forEach(function (value) {
-      if (!valuesInOldEnum[value.name]) {
-        valuesAddedToEnums.push({
-          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
-          description: "".concat(value.name, " was added to enum type ").concat(typeName, ".")
-        });
+    var _iteratorNormalCompletion9 = true;
+    var _didIteratorError9 = false;
+    var _iteratorError9 = undefined;
+
+    try {
+      for (var _iterator9 = oldType.getValues()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
+        var value = _step9.value;
+        valuesInOldEnum[value.name] = true;
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError9 = true;
+      _iteratorError9 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
+          _iterator9.return();
+        }
+      } finally {
+        if (_didIteratorError9) {
+          throw _iteratorError9;
+        }
+      }
+    }
+
+    var _iteratorNormalCompletion10 = true;
+    var _didIteratorError10 = false;
+    var _iteratorError10 = undefined;
+
+    try {
+      for (var _iterator10 = newType.getValues()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
+        var _value2 = _step10.value;
+
+        if (!valuesInOldEnum[_value2.name]) {
+          valuesAddedToEnums.push({
+            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
+            description: "".concat(_value2.name, " was added to enum type ").concat(typeName, ".")
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError10 = true;
+      _iteratorError10 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
+          _iterator10.return();
+        }
+      } finally {
+        if (_didIteratorError10) {
+          throw _iteratorError10;
+        }
+      }
+    }
+  }
+
   return valuesAddedToEnums;
 }
 export function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var breakingChanges = [];
-  Object.keys(oldTypeMap).forEach(function (typeName) {
+
+  var _arr14 = Object.keys(oldTypeMap);
+
+  for (var _i14 = 0; _i14 < _arr14.length; _i14++) {
+    var typeName = _arr14[_i14];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!isObjectType(oldType) || !isObjectType(newType)) {
-      return;
+      continue;
     }
 
     var oldInterfaces = oldType.getInterfaces();
     var newInterfaces = newType.getInterfaces();
-    oldInterfaces.forEach(function (oldInterface) {
-      if (!newInterfaces.some(function (int) {
-        return int.name === oldInterface.name;
-      })) {
-        breakingChanges.push({
-          type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,
-          description: "".concat(typeName, " no longer implements interface ") + "".concat(oldInterface.name, ".")
-        });
+    var _iteratorNormalCompletion11 = true;
+    var _didIteratorError11 = false;
+    var _iteratorError11 = undefined;
+
+    try {
+      var _loop3 = function _loop3() {
+        var oldInterface = _step11.value;
+
+        if (!newInterfaces.some(function (int) {
+          return int.name === oldInterface.name;
+        })) {
+          breakingChanges.push({
+            type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,
+            description: "".concat(typeName, " no longer implements interface ") + "".concat(oldInterface.name, ".")
+          });
+        }
+      };
+
+      for (var _iterator11 = oldInterfaces[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
+        _loop3();
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError11 = true;
+      _iteratorError11 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
+          _iterator11.return();
+        }
+      } finally {
+        if (_didIteratorError11) {
+          throw _iteratorError11;
+        }
+      }
+    }
+  }
+
   return breakingChanges;
 }
 export function findInterfacesAddedToObjectTypes(oldSchema, newSchema) {
   var oldTypeMap = oldSchema.getTypeMap();
   var newTypeMap = newSchema.getTypeMap();
   var interfacesAddedToObjectTypes = [];
-  Object.keys(newTypeMap).forEach(function (typeName) {
+
+  var _arr15 = Object.keys(newTypeMap);
+
+  for (var _i15 = 0; _i15 < _arr15.length; _i15++) {
+    var typeName = _arr15[_i15];
     var oldType = oldTypeMap[typeName];
     var newType = newTypeMap[typeName];
 
     if (!isObjectType(oldType) || !isObjectType(newType)) {
-      return;
+      continue;
     }
 
     var oldInterfaces = oldType.getInterfaces();
     var newInterfaces = newType.getInterfaces();
-    newInterfaces.forEach(function (newInterface) {
-      if (!oldInterfaces.some(function (int) {
-        return int.name === newInterface.name;
-      })) {
-        interfacesAddedToObjectTypes.push({
-          type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,
-          description: "".concat(newInterface.name, " added to interfaces implemented ") + "by ".concat(typeName, ".")
-        });
+    var _iteratorNormalCompletion12 = true;
+    var _didIteratorError12 = false;
+    var _iteratorError12 = undefined;
+
+    try {
+      var _loop4 = function _loop4() {
+        var newInterface = _step12.value;
+
+        if (!oldInterfaces.some(function (int) {
+          return int.name === newInterface.name;
+        })) {
+          interfacesAddedToObjectTypes.push({
+            type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,
+            description: "".concat(newInterface.name, " added to interfaces implemented ") + "by ".concat(typeName, ".")
+          });
+        }
+      };
+
+      for (var _iterator12 = newInterfaces[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
+        _loop4();
       }
-    });
-  });
+    } catch (err) {
+      _didIteratorError12 = true;
+      _iteratorError12 = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
+          _iterator12.return();
+        }
+      } finally {
+        if (_didIteratorError12) {
+          throw _iteratorError12;
+        }
+      }
+    }
+  }
+
   return interfacesAddedToObjectTypes;
 }
 export function findRemovedDirectives(oldSchema, newSchema) {
   var removedDirectives = [];
   var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);
-  oldSchema.getDirectives().forEach(function (directive) {
-    if (!newSchemaDirectiveMap[directive.name]) {
-      removedDirectives.push({
-        type: BreakingChangeType.DIRECTIVE_REMOVED,
-        description: "".concat(directive.name, " was removed")
-      });
+  var _iteratorNormalCompletion13 = true;
+  var _didIteratorError13 = false;
+  var _iteratorError13 = undefined;
+
+  try {
+    for (var _iterator13 = oldSchema.getDirectives()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
+      var directive = _step13.value;
+
+      if (!newSchemaDirectiveMap[directive.name]) {
+        removedDirectives.push({
+          type: BreakingChangeType.DIRECTIVE_REMOVED,
+          description: "".concat(directive.name, " was removed")
+        });
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError13 = true;
+    _iteratorError13 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
+        _iterator13.return();
+      }
+    } finally {
+      if (_didIteratorError13) {
+        throw _iteratorError13;
+      }
+    }
+  }
+
   return removedDirectives;
 }
 
 function findRemovedArgsForDirective(oldDirective, newDirective) {
   var removedArgs = [];
   var newArgMap = getArgumentMapForDirective(newDirective);
-  oldDirective.args.forEach(function (arg) {
-    if (!newArgMap[arg.name]) {
-      removedArgs.push(arg);
+  var _iteratorNormalCompletion14 = true;
+  var _didIteratorError14 = false;
+  var _iteratorError14 = undefined;
+
+  try {
+    for (var _iterator14 = oldDirective.args[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
+      var arg = _step14.value;
+
+      if (!newArgMap[arg.name]) {
+        removedArgs.push(arg);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError14 = true;
+    _iteratorError14 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
+        _iterator14.return();
+      }
+    } finally {
+      if (_didIteratorError14) {
+        throw _iteratorError14;
+      }
+    }
+  }
+
   return removedArgs;
 }
 
 export function findRemovedDirectiveArgs(oldSchema, newSchema) {
   var removedDirectiveArgs = [];
   var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);
-  newSchema.getDirectives().forEach(function (newDirective) {
-    var oldDirective = oldSchemaDirectiveMap[newDirective.name];
+  var _iteratorNormalCompletion15 = true;
+  var _didIteratorError15 = false;
+  var _iteratorError15 = undefined;
 
-    if (!oldDirective) {
-      return;
+  try {
+    for (var _iterator15 = newSchema.getDirectives()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
+      var newDirective = _step15.value;
+      var oldDirective = oldSchemaDirectiveMap[newDirective.name];
+
+      if (!oldDirective) {
+        continue;
+      }
+
+      var _iteratorNormalCompletion16 = true;
+      var _didIteratorError16 = false;
+      var _iteratorError16 = undefined;
+
+      try {
+        for (var _iterator16 = findRemovedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
+          var arg = _step16.value;
+          removedDirectiveArgs.push({
+            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
+            description: "".concat(arg.name, " was removed from ").concat(newDirective.name)
+          });
+        }
+      } catch (err) {
+        _didIteratorError16 = true;
+        _iteratorError16 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
+            _iterator16.return();
+          }
+        } finally {
+          if (_didIteratorError16) {
+            throw _iteratorError16;
+          }
+        }
+      }
     }
+  } catch (err) {
+    _didIteratorError15 = true;
+    _iteratorError15 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
+        _iterator15.return();
+      }
+    } finally {
+      if (_didIteratorError15) {
+        throw _iteratorError15;
+      }
+    }
+  }
 
-    findRemovedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {
-      removedDirectiveArgs.push({
-        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
-        description: "".concat(arg.name, " was removed from ").concat(newDirective.name)
-      });
-    });
-  });
   return removedDirectiveArgs;
 }
 
 function findAddedArgsForDirective(oldDirective, newDirective) {
   var addedArgs = [];
   var oldArgMap = getArgumentMapForDirective(oldDirective);
-  newDirective.args.forEach(function (arg) {
-    if (!oldArgMap[arg.name]) {
-      addedArgs.push(arg);
+  var _iteratorNormalCompletion17 = true;
+  var _didIteratorError17 = false;
+  var _iteratorError17 = undefined;
+
+  try {
+    for (var _iterator17 = newDirective.args[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
+      var arg = _step17.value;
+
+      if (!oldArgMap[arg.name]) {
+        addedArgs.push(arg);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError17 = true;
+    _iteratorError17 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
+        _iterator17.return();
+      }
+    } finally {
+      if (_didIteratorError17) {
+        throw _iteratorError17;
+      }
+    }
+  }
+
   return addedArgs;
 }
 
 export function findAddedNonNullDirectiveArgs(oldSchema, newSchema) {
   var addedNonNullableArgs = [];
   var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);
-  newSchema.getDirectives().forEach(function (newDirective) {
-    var oldDirective = oldSchemaDirectiveMap[newDirective.name];
+  var _iteratorNormalCompletion18 = true;
+  var _didIteratorError18 = false;
+  var _iteratorError18 = undefined;
 
-    if (!oldDirective) {
-      return;
-    }
+  try {
+    for (var _iterator18 = newSchema.getDirectives()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
+      var newDirective = _step18.value;
+      var oldDirective = oldSchemaDirectiveMap[newDirective.name];
 
-    findAddedArgsForDirective(oldDirective, newDirective).forEach(function (arg) {
-      if (!isNonNullType(arg.type)) {
-        return;
+      if (!oldDirective) {
+        continue;
       }
 
-      addedNonNullableArgs.push({
-        type: BreakingChangeType.NON_NULL_DIRECTIVE_ARG_ADDED,
-        description: "A non-null arg ".concat(arg.name, " on directive ") + "".concat(newDirective.name, " was added")
-      });
-    });
-  });
+      var _iteratorNormalCompletion19 = true;
+      var _didIteratorError19 = false;
+      var _iteratorError19 = undefined;
+
+      try {
+        for (var _iterator19 = findAddedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
+          var arg = _step19.value;
+
+          if (!isNonNullType(arg.type)) {
+            continue;
+          }
+
+          addedNonNullableArgs.push({
+            type: BreakingChangeType.NON_NULL_DIRECTIVE_ARG_ADDED,
+            description: "A non-null arg ".concat(arg.name, " on directive ") + "".concat(newDirective.name, " was added")
+          });
+        }
+      } catch (err) {
+        _didIteratorError19 = true;
+        _iteratorError19 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
+            _iterator19.return();
+          }
+        } finally {
+          if (_didIteratorError19) {
+            throw _iteratorError19;
+          }
+        }
+      }
+    }
+  } catch (err) {
+    _didIteratorError18 = true;
+    _iteratorError18 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
+        _iterator18.return();
+      }
+    } finally {
+      if (_didIteratorError18) {
+        throw _iteratorError18;
+      }
+    }
+  }
+
   return addedNonNullableArgs;
 }
 export function findRemovedLocationsForDirective(oldDirective, newDirective) {
   var removedLocations = [];
   var newLocationSet = new Set(newDirective.locations);
-  oldDirective.locations.forEach(function (oldLocation) {
-    if (!newLocationSet.has(oldLocation)) {
-      removedLocations.push(oldLocation);
+  var _iteratorNormalCompletion20 = true;
+  var _didIteratorError20 = false;
+  var _iteratorError20 = undefined;
+
+  try {
+    for (var _iterator20 = oldDirective.locations[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
+      var oldLocation = _step20.value;
+
+      if (!newLocationSet.has(oldLocation)) {
+        removedLocations.push(oldLocation);
+      }
     }
-  });
+  } catch (err) {
+    _didIteratorError20 = true;
+    _iteratorError20 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion20 && _iterator20.return != null) {
+        _iterator20.return();
+      }
+    } finally {
+      if (_didIteratorError20) {
+        throw _iteratorError20;
+      }
+    }
+  }
+
   return removedLocations;
 }
 export function findRemovedDirectiveLocations(oldSchema, newSchema) {
   var removedLocations = [];
   var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);
-  newSchema.getDirectives().forEach(function (newDirective) {
-    var oldDirective = oldSchemaDirectiveMap[newDirective.name];
+  var _iteratorNormalCompletion21 = true;
+  var _didIteratorError21 = false;
+  var _iteratorError21 = undefined;
 
-    if (!oldDirective) {
-      return;
+  try {
+    for (var _iterator21 = newSchema.getDirectives()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
+      var newDirective = _step21.value;
+      var oldDirective = oldSchemaDirectiveMap[newDirective.name];
+
+      if (!oldDirective) {
+        continue;
+      }
+
+      var _iteratorNormalCompletion22 = true;
+      var _didIteratorError22 = false;
+      var _iteratorError22 = undefined;
+
+      try {
+        for (var _iterator22 = findRemovedLocationsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
+          var location = _step22.value;
+          removedLocations.push({
+            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
+            description: "".concat(location, " was removed from ").concat(newDirective.name)
+          });
+        }
+      } catch (err) {
+        _didIteratorError22 = true;
+        _iteratorError22 = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {
+            _iterator22.return();
+          }
+        } finally {
+          if (_didIteratorError22) {
+            throw _iteratorError22;
+          }
+        }
+      }
+    }
+  } catch (err) {
+    _didIteratorError21 = true;
+    _iteratorError21 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion21 && _iterator21.return != null) {
+        _iterator21.return();
+      }
+    } finally {
+      if (_didIteratorError21) {
+        throw _iteratorError21;
+      }
     }
+  }
 
-    findRemovedLocationsForDirective(oldDirective, newDirective).forEach(function (location) {
-      removedLocations.push({
-        type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
-        description: "".concat(location, " was removed from ").concat(newDirective.name)
-      });
-    });
-  });
   return removedLocations;
 }
 
diff --git a/utilities/findDeprecatedUsages.js b/utilities/findDeprecatedUsages.js
index 28ff7be..4906b58 100644
--- a/utilities/findDeprecatedUsages.js
+++ b/utilities/findDeprecatedUsages.js
@@ -11,8 +11,6 @@ var _visitor = require("../language/visitor");
 
 var _definition = require("../type/definition");
 
-var _schema = require("../type/schema");
-
 var _TypeInfo = require("./TypeInfo");
 
 /**
diff --git a/utilities/findDeprecatedUsages.js.flow b/utilities/findDeprecatedUsages.js.flow
index ae4c1de..d2ad48e 100644
--- a/utilities/findDeprecatedUsages.js.flow
+++ b/utilities/findDeprecatedUsages.js.flow
@@ -11,7 +11,7 @@ import { GraphQLError } from '../error/GraphQLError';
 import { visit, visitWithTypeInfo } from '../language/visitor';
 import type { DocumentNode } from '../language/ast';
 import { getNamedType } from '../type/definition';
-import { GraphQLSchema } from '../type/schema';
+import type { GraphQLSchema } from '../type/schema';
 import { TypeInfo } from './TypeInfo';
 
 /**
diff --git a/utilities/findDeprecatedUsages.mjs b/utilities/findDeprecatedUsages.mjs
index 0ea134f..9330d0d 100644
--- a/utilities/findDeprecatedUsages.mjs
+++ b/utilities/findDeprecatedUsages.mjs
@@ -9,7 +9,6 @@
 import { GraphQLError } from '../error/GraphQLError';
 import { visit, visitWithTypeInfo } from '../language/visitor';
 import { getNamedType } from '../type/definition';
-import { GraphQLSchema } from '../type/schema';
 import { TypeInfo } from './TypeInfo';
 /**
  * A validation rule which reports deprecated usages.
diff --git a/utilities/getOperationRootType.js b/utilities/getOperationRootType.js
index 53e366e..dc37be7 100644
--- a/utilities/getOperationRootType.js
+++ b/utilities/getOperationRootType.js
@@ -7,8 +7,6 @@ exports.getOperationRootType = getOperationRootType;
 
 var _GraphQLError = require("../error/GraphQLError");
 
-var _schema = require("../type/schema");
-
 /**
  * Copyright (c) 2015-present, Facebook, Inc.
  *
diff --git a/utilities/getOperationRootType.js.flow b/utilities/getOperationRootType.js.flow
index 72f7b3d..ddc6e99 100644
--- a/utilities/getOperationRootType.js.flow
+++ b/utilities/getOperationRootType.js.flow
@@ -12,7 +12,7 @@ import type {
   OperationDefinitionNode,
   OperationTypeDefinitionNode,
 } from '../language/ast';
-import { GraphQLSchema } from '../type/schema';
+import type { GraphQLSchema } from '../type/schema';
 import type { GraphQLObjectType } from '../type/definition';
 
 /**
diff --git a/utilities/getOperationRootType.mjs b/utilities/getOperationRootType.mjs
index e8c214c..69a9fe3 100644
--- a/utilities/getOperationRootType.mjs
+++ b/utilities/getOperationRootType.mjs
@@ -7,7 +7,6 @@
  *  strict
  */
 import { GraphQLError } from '../error/GraphQLError';
-import { GraphQLSchema } from '../type/schema';
 
 /**
  * Extracts the root type of the operation from the schema.
diff --git a/utilities/index.js.flow b/utilities/index.js.flow
index 3fa3529..cf14c71 100644
--- a/utilities/index.js.flow
+++ b/utilities/index.js.flow
@@ -10,7 +10,7 @@
 // The GraphQL query recommended for a full schema introspection.
 export {
   getIntrospectionQuery,
-  // Deprecated, use getIntrospectionQuery()
+  // @deprecated, use getIntrospectionQuery() - will be removed in v15
   introspectionQuery,
 } from './introspectionQuery';
 export type {
@@ -51,7 +51,13 @@ export { introspectionFromSchema } from './introspectionFromSchema';
 export { buildClientSchema } from './buildClientSchema';
 
 // Build a GraphQLSchema from GraphQL Schema language.
-export { buildASTSchema, buildSchema, getDescription } from './buildASTSchema';
+export {
+  buildASTSchema,
+  buildSchema,
+  // @deprecated: Get the description from a schema AST node and supports legacy
+  // syntax for specifying descriptions - will be removed in v16
+  getDescription,
+} from './buildASTSchema';
 export type { BuildSchemaOptions } from './buildASTSchema';
 
 // Extends an existing GraphQLSchema from a parsed GraphQL Schema language AST.
@@ -86,10 +92,10 @@ export { TypeInfo } from './TypeInfo';
 // Coerces a JavaScript value to a GraphQL type, or produces errors.
 export { coerceValue } from './coerceValue';
 
-// @deprecated use coerceValue
+// @deprecated use coerceValue - will be removed in v15
 export { isValidJSValue } from './isValidJSValue';
 
-// Determine if AST values adhere to a GraphQL type.
+// @deprecated use validation - will be removed in v15
 export { isValidLiteralValue } from './isValidLiteralValue';
 
 // Concatenates multiple AST together.
diff --git a/utilities/index.mjs b/utilities/index.mjs
index d5aae3e..4ba9733 100644
--- a/utilities/index.mjs
+++ b/utilities/index.mjs
@@ -7,7 +7,7 @@
  *  strict
  */
 // The GraphQL query recommended for a full schema introspection.
-export { getIntrospectionQuery, // Deprecated, use getIntrospectionQuery()
+export { getIntrospectionQuery, // @deprecated, use getIntrospectionQuery() - will be removed in v15
 introspectionQuery } from './introspectionQuery';
 // Gets the target Operation from a Document
 export { getOperationAST } from './getOperationAST'; // Gets the Type for the target Operation AST.
@@ -18,7 +18,9 @@ export { introspectionFromSchema } from './introspectionFromSchema'; // Build a
 
 export { buildClientSchema } from './buildClientSchema'; // Build a GraphQLSchema from GraphQL Schema language.
 
-export { buildASTSchema, buildSchema, getDescription } from './buildASTSchema';
+export { buildASTSchema, buildSchema, // @deprecated: Get the description from a schema AST node and supports legacy
+// syntax for specifying descriptions - will be removed in v16
+getDescription } from './buildASTSchema';
 // Extends an existing GraphQLSchema from a parsed GraphQL Schema language AST.
 export { extendSchema } from './extendSchema'; // Sort a GraphQLSchema.
 
@@ -37,9 +39,9 @@ export { astFromValue } from './astFromValue'; // A helper to use within recursi
 
 export { TypeInfo } from './TypeInfo'; // Coerces a JavaScript value to a GraphQL type, or produces errors.
 
-export { coerceValue } from './coerceValue'; // @deprecated use coerceValue
+export { coerceValue } from './coerceValue'; // @deprecated use coerceValue - will be removed in v15
 
-export { isValidJSValue } from './isValidJSValue'; // Determine if AST values adhere to a GraphQL type.
+export { isValidJSValue } from './isValidJSValue'; // @deprecated use validation - will be removed in v15
 
 export { isValidLiteralValue } from './isValidLiteralValue'; // Concatenates multiple AST together.
 
diff --git a/utilities/introspectionFromSchema.js b/utilities/introspectionFromSchema.js
index b92fba2..5d8fd69 100644
--- a/utilities/introspectionFromSchema.js
+++ b/utilities/introspectionFromSchema.js
@@ -9,8 +9,6 @@ var _invariant = _interopRequireDefault(require("../jsutils/invariant"));
 
 var _introspectionQuery = require("./introspectionQuery");
 
-var _schema = require("../type/schema");
-
 var _execute = require("../execution/execute");
 
 var _parser = require("../language/parser");
diff --git a/utilities/introspectionFromSchema.js.flow b/utilities/introspectionFromSchema.js.flow
index fa81609..c2690b6 100644
--- a/utilities/introspectionFromSchema.js.flow
+++ b/utilities/introspectionFromSchema.js.flow
@@ -9,7 +9,7 @@
 
 import invariant from '../jsutils/invariant';
 import { getIntrospectionQuery } from './introspectionQuery';
-import { GraphQLSchema } from '../type/schema';
+import type { GraphQLSchema } from '../type/schema';
 import { execute } from '../execution/execute';
 import { parse } from '../language/parser';
 import type {
@@ -28,7 +28,7 @@ import type {
  */
 export function introspectionFromSchema(
   schema: GraphQLSchema,
-  options: IntrospectionOptions,
+  options?: IntrospectionOptions,
 ): IntrospectionQuery {
   const queryAST = parse(getIntrospectionQuery(options));
   const result = execute(schema, queryAST);
diff --git a/utilities/introspectionFromSchema.mjs b/utilities/introspectionFromSchema.mjs
index 27bc89e..88a0bff 100644
--- a/utilities/introspectionFromSchema.mjs
+++ b/utilities/introspectionFromSchema.mjs
@@ -8,7 +8,6 @@
  */
 import invariant from '../jsutils/invariant';
 import { getIntrospectionQuery } from './introspectionQuery';
-import { GraphQLSchema } from '../type/schema';
 import { execute } from '../execution/execute';
 import { parse } from '../language/parser';
 
diff --git a/utilities/introspectionQuery.js b/utilities/introspectionQuery.js
index 7dadb90..b0179d3 100644
--- a/utilities/introspectionQuery.js
+++ b/utilities/introspectionQuery.js
@@ -18,6 +18,12 @@ function getIntrospectionQuery(options) {
   var descriptions = !(options && options.descriptions === false);
   return "\n    query IntrospectionQuery {\n      __schema {\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ".concat(descriptions ? 'description' : '', "\n          locations\n          args {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ").concat(descriptions ? 'description' : '', "\n      fields(includeDeprecated: true) {\n        name\n        ").concat(descriptions ? 'description' : '', "\n        args {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ").concat(descriptions ? 'description' : '', "\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ").concat(descriptions ? 'description' : '', "\n      type { ...TypeRef }\n      defaultValue\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ");
 }
+/**
+ * Deprecated, call getIntrospectionQuery directly.
+ *
+ * This function will be removed in v15
+ */
+
 
 var introspectionQuery = getIntrospectionQuery();
 exports.introspectionQuery = introspectionQuery;
\ No newline at end of file
diff --git a/utilities/introspectionQuery.js.flow b/utilities/introspectionQuery.js.flow
index 9c67dbd..b6ebe58 100644
--- a/utilities/introspectionQuery.js.flow
+++ b/utilities/introspectionQuery.js.flow
@@ -112,6 +112,11 @@ export function getIntrospectionQuery(options?: IntrospectionOptions): string {
   `;
 }
 
+/**
+ * Deprecated, call getIntrospectionQuery directly.
+ *
+ * This function will be removed in v15
+ */
 export const introspectionQuery = getIntrospectionQuery();
 
 export type IntrospectionQuery = {|
diff --git a/utilities/introspectionQuery.mjs b/utilities/introspectionQuery.mjs
index e6dbb91..8eec21d 100644
--- a/utilities/introspectionQuery.mjs
+++ b/utilities/introspectionQuery.mjs
@@ -10,4 +10,10 @@ export function getIntrospectionQuery(options) {
   var descriptions = !(options && options.descriptions === false);
   return "\n    query IntrospectionQuery {\n      __schema {\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ".concat(descriptions ? 'description' : '', "\n          locations\n          args {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ").concat(descriptions ? 'description' : '', "\n      fields(includeDeprecated: true) {\n        name\n        ").concat(descriptions ? 'description' : '', "\n        args {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ").concat(descriptions ? 'description' : '', "\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ").concat(descriptions ? 'description' : '', "\n      type { ...TypeRef }\n      defaultValue\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ");
 }
+/**
+ * Deprecated, call getIntrospectionQuery directly.
+ *
+ * This function will be removed in v15
+ */
+
 export var introspectionQuery = getIntrospectionQuery();
\ No newline at end of file
diff --git a/utilities/isValidJSValue.js b/utilities/isValidJSValue.js
index d94fb51..d1fa12f 100644
--- a/utilities/isValidJSValue.js
+++ b/utilities/isValidJSValue.js
@@ -18,6 +18,8 @@ var _coerceValue = require("./coerceValue");
 
 /**
  * Deprecated. Use coerceValue() directly for richer information.
+ *
+ * This function will be removed in v15
  */
 function isValidJSValue(value, type) {
   var errors = (0, _coerceValue.coerceValue)(value, type).errors;
diff --git a/utilities/isValidJSValue.js.flow b/utilities/isValidJSValue.js.flow
index c68eeb0..815476b 100644
--- a/utilities/isValidJSValue.js.flow
+++ b/utilities/isValidJSValue.js.flow
@@ -12,6 +12,8 @@ import type { GraphQLInputType } from '../type/definition';
 
 /**
  * Deprecated. Use coerceValue() directly for richer information.
+ *
+ * This function will be removed in v15
  */
 export function isValidJSValue(
   value: mixed,
diff --git a/utilities/isValidJSValue.mjs b/utilities/isValidJSValue.mjs
index 3300951..59c38fa 100644
--- a/utilities/isValidJSValue.mjs
+++ b/utilities/isValidJSValue.mjs
@@ -10,6 +10,8 @@ import { coerceValue } from './coerceValue';
 
 /**
  * Deprecated. Use coerceValue() directly for richer information.
+ *
+ * This function will be removed in v15
  */
 export function isValidJSValue(value, type) {
   var errors = coerceValue(value, type).errors;
diff --git a/utilities/isValidLiteralValue.js b/utilities/isValidLiteralValue.js
index 9d99abe..c518c0e 100644
--- a/utilities/isValidLiteralValue.js
+++ b/utilities/isValidLiteralValue.js
@@ -15,9 +15,7 @@ var _schema = require("../type/schema");
 
 var _ValuesOfCorrectType = require("../validation/rules/ValuesOfCorrectType");
 
-var _ValidationContext = _interopRequireDefault(require("../validation/ValidationContext"));
-
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+var _ValidationContext = require("../validation/ValidationContext");
 
 /**
  * Copyright (c) 2015-present, Facebook, Inc.
@@ -32,6 +30,8 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
  * Utility which determines if a value literal node is valid for an input type.
  *
  * Deprecated. Rely on validation for documents containing literal values.
+ *
+ * This function will be removed in v15
  */
 function isValidLiteralValue(type, valueNode) {
   var emptySchema = new _schema.GraphQLSchema({});
@@ -40,7 +40,7 @@ function isValidLiteralValue(type, valueNode) {
     definitions: []
   };
   var typeInfo = new _TypeInfo.TypeInfo(emptySchema, undefined, type);
-  var context = new _ValidationContext.default(emptySchema, emptyDoc, typeInfo);
+  var context = new _ValidationContext.ValidationContext(emptySchema, emptyDoc, typeInfo);
   var visitor = (0, _ValuesOfCorrectType.ValuesOfCorrectType)(context);
   (0, _visitor.visit)(valueNode, (0, _visitor.visitWithTypeInfo)(typeInfo, visitor));
   return context.getErrors();
diff --git a/utilities/isValidLiteralValue.js.flow b/utilities/isValidLiteralValue.js.flow
index 719a2c2..1b7806c 100644
--- a/utilities/isValidLiteralValue.js.flow
+++ b/utilities/isValidLiteralValue.js.flow
@@ -15,12 +15,14 @@ import { visit, visitWithTypeInfo } from '../language/visitor';
 import type { GraphQLInputType } from '../type/definition';
 import { GraphQLSchema } from '../type/schema';
 import { ValuesOfCorrectType } from '../validation/rules/ValuesOfCorrectType';
-import ValidationContext from '../validation/ValidationContext';
+import { ValidationContext } from '../validation/ValidationContext';
 
 /**
  * Utility which determines if a value literal node is valid for an input type.
  *
  * Deprecated. Rely on validation for documents containing literal values.
+ *
+ * This function will be removed in v15
  */
 export function isValidLiteralValue(
   type: GraphQLInputType,
diff --git a/utilities/isValidLiteralValue.mjs b/utilities/isValidLiteralValue.mjs
index 2623a70..103c20c 100644
--- a/utilities/isValidLiteralValue.mjs
+++ b/utilities/isValidLiteralValue.mjs
@@ -11,11 +11,13 @@ import { Kind } from '../language/kinds';
 import { visit, visitWithTypeInfo } from '../language/visitor';
 import { GraphQLSchema } from '../type/schema';
 import { ValuesOfCorrectType } from '../validation/rules/ValuesOfCorrectType';
-import ValidationContext from '../validation/ValidationContext';
+import { ValidationContext } from '../validation/ValidationContext';
 /**
  * Utility which determines if a value literal node is valid for an input type.
  *
  * Deprecated. Rely on validation for documents containing literal values.
+ *
+ * This function will be removed in v15
  */
 
 export function isValidLiteralValue(type, valueNode) {
diff --git a/utilities/separateOperations.js b/utilities/separateOperations.js
index 54d4053..6e129c8 100644
--- a/utilities/separateOperations.js
+++ b/utilities/separateOperations.js
@@ -49,16 +49,23 @@ function separateOperations(documentAST) {
   // is necessary for completing that operation.
 
   var separatedDocumentASTs = Object.create(null);
-  operations.forEach(function (operation) {
+
+  for (var _i = 0; _i < operations.length; _i++) {
+    var operation = operations[_i];
     var operationName = opName(operation);
     var dependencies = Object.create(null);
     collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted
     // to retain the same order as the original document.
 
     var definitions = [operation];
-    Object.keys(dependencies).forEach(function (name) {
+
+    var _arr = Object.keys(dependencies);
+
+    for (var _i2 = 0; _i2 < _arr.length; _i2++) {
+      var name = _arr[_i2];
       definitions.push(fragments[name]);
-    });
+    }
+
     definitions.sort(function (n1, n2) {
       return (positions.get(n1) || 0) - (positions.get(n2) || 0);
     });
@@ -66,7 +73,8 @@ function separateOperations(documentAST) {
       kind: 'Document',
       definitions: definitions
     };
-  });
+  }
+
   return separatedDocumentASTs;
 }
 
@@ -81,11 +89,15 @@ function collectTransitiveDependencies(collected, depGraph, fromName) {
   var immediateDeps = depGraph[fromName];
 
   if (immediateDeps) {
-    Object.keys(immediateDeps).forEach(function (toName) {
+    var _arr2 = Object.keys(immediateDeps);
+
+    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {
+      var toName = _arr2[_i3];
+
       if (!collected[toName]) {
         collected[toName] = true;
         collectTransitiveDependencies(collected, depGraph, toName);
       }
-    });
+    }
   }
 }
\ No newline at end of file
diff --git a/utilities/separateOperations.js.flow b/utilities/separateOperations.js.flow
index 4087fc1..0fe8f5b 100644
--- a/utilities/separateOperations.js.flow
+++ b/utilities/separateOperations.js.flow
@@ -50,7 +50,7 @@ export function separateOperations(
   // For each operation, produce a new synthesized AST which includes only what
   // is necessary for completing that operation.
   const separatedDocumentASTs = Object.create(null);
-  operations.forEach(operation => {
+  for (const operation of operations) {
     const operationName = opName(operation);
     const dependencies = Object.create(null);
     collectTransitiveDependencies(dependencies, depGraph, operationName);
@@ -58,9 +58,9 @@ export function separateOperations(
     // The list of definition nodes to be included for this operation, sorted
     // to retain the same order as the original document.
     const definitions = [operation];
-    Object.keys(dependencies).forEach(name => {
+    for (const name of Object.keys(dependencies)) {
       definitions.push(fragments[name]);
-    });
+    }
     definitions.sort(
       (n1, n2) => (positions.get(n1) || 0) - (positions.get(n2) || 0),
     );
@@ -69,7 +69,7 @@ export function separateOperations(
       kind: 'Document',
       definitions,
     };
-  });
+  }
 
   return separatedDocumentASTs;
 }
@@ -90,11 +90,11 @@ function collectTransitiveDependencies(
 ): void {
   const immediateDeps = depGraph[fromName];
   if (immediateDeps) {
-    Object.keys(immediateDeps).forEach(toName => {
+    for (const toName of Object.keys(immediateDeps)) {
       if (!collected[toName]) {
         collected[toName] = true;
         collectTransitiveDependencies(collected, depGraph, toName);
       }
-    });
+    }
   }
 }
diff --git a/utilities/separateOperations.mjs b/utilities/separateOperations.mjs
index 4d9b6e0..0de6835 100644
--- a/utilities/separateOperations.mjs
+++ b/utilities/separateOperations.mjs
@@ -41,16 +41,23 @@ export function separateOperations(documentAST) {
   // is necessary for completing that operation.
 
   var separatedDocumentASTs = Object.create(null);
-  operations.forEach(function (operation) {
+
+  for (var _i = 0; _i < operations.length; _i++) {
+    var operation = operations[_i];
     var operationName = opName(operation);
     var dependencies = Object.create(null);
     collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted
     // to retain the same order as the original document.
 
     var definitions = [operation];
-    Object.keys(dependencies).forEach(function (name) {
+
+    var _arr = Object.keys(dependencies);
+
+    for (var _i2 = 0; _i2 < _arr.length; _i2++) {
+      var name = _arr[_i2];
       definitions.push(fragments[name]);
-    });
+    }
+
     definitions.sort(function (n1, n2) {
       return (positions.get(n1) || 0) - (positions.get(n2) || 0);
     });
@@ -58,7 +65,8 @@ export function separateOperations(documentAST) {
       kind: 'Document',
       definitions: definitions
     };
-  });
+  }
+
   return separatedDocumentASTs;
 }
 
@@ -73,11 +81,15 @@ function collectTransitiveDependencies(collected, depGraph, fromName) {
   var immediateDeps = depGraph[fromName];
 
   if (immediateDeps) {
-    Object.keys(immediateDeps).forEach(function (toName) {
+    var _arr2 = Object.keys(immediateDeps);
+
+    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {
+      var toName = _arr2[_i3];
+
       if (!collected[toName]) {
         collected[toName] = true;
         collectTransitiveDependencies(collected, depGraph, toName);
       }
-    });
+    }
   }
 }
\ No newline at end of file
diff --git a/validation/ValidationContext.js b/validation/ValidationContext.js
index deda38b..d69974f 100644
--- a/validation/ValidationContext.js
+++ b/validation/ValidationContext.js
@@ -3,18 +3,18 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.default = void 0;
-
-var _error = require("../error");
+exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;
 
 var _visitor = require("../language/visitor");
 
 var _kinds = require("../language/kinds");
 
-var _schema = require("../type/schema");
-
 var _TypeInfo = require("../utilities/TypeInfo");
 
+function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
 function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
 
 /**
@@ -22,39 +22,19 @@ function _defineProperty(obj, key, value) { if (key in obj) { Object.definePrope
  * allowing access to commonly useful contextual information from within a
  * validation rule.
  */
-var ValidationContext =
+var ASTValidationContext =
 /*#__PURE__*/
 function () {
-  function ValidationContext(schema, ast, typeInfo) {
-    _defineProperty(this, "_schema", void 0);
-
+  function ASTValidationContext(ast) {
     _defineProperty(this, "_ast", void 0);
 
-    _defineProperty(this, "_typeInfo", void 0);
-
     _defineProperty(this, "_errors", void 0);
 
-    _defineProperty(this, "_fragments", void 0);
-
-    _defineProperty(this, "_fragmentSpreads", void 0);
-
-    _defineProperty(this, "_recursivelyReferencedFragments", void 0);
-
-    _defineProperty(this, "_variableUsages", void 0);
-
-    _defineProperty(this, "_recursiveVariableUsages", void 0);
-
-    this._schema = schema;
     this._ast = ast;
-    this._typeInfo = typeInfo;
     this._errors = [];
-    this._fragmentSpreads = new Map();
-    this._recursivelyReferencedFragments = new Map();
-    this._variableUsages = new Map();
-    this._recursiveVariableUsages = new Map();
   }
 
-  var _proto = ValidationContext.prototype;
+  var _proto = ASTValidationContext.prototype;
 
   _proto.reportError = function reportError(error) {
     this._errors.push(error);
@@ -64,15 +44,82 @@ function () {
     return this._errors;
   };
 
-  _proto.getSchema = function getSchema() {
+  _proto.getDocument = function getDocument() {
+    return this._ast;
+  };
+
+  return ASTValidationContext;
+}();
+
+exports.ASTValidationContext = ASTValidationContext;
+
+var SDLValidationContext =
+/*#__PURE__*/
+function (_ASTValidationContext) {
+  _inheritsLoose(SDLValidationContext, _ASTValidationContext);
+
+  function SDLValidationContext(ast, schema) {
+    var _this;
+
+    _this = _ASTValidationContext.call(this, ast) || this;
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_schema", void 0);
+
+    _this._schema = schema;
+    return _this;
+  }
+
+  var _proto2 = SDLValidationContext.prototype;
+
+  _proto2.getSchema = function getSchema() {
     return this._schema;
   };
 
-  _proto.getDocument = function getDocument() {
-    return this._ast;
+  return SDLValidationContext;
+}(ASTValidationContext);
+
+exports.SDLValidationContext = SDLValidationContext;
+
+var ValidationContext =
+/*#__PURE__*/
+function (_ASTValidationContext2) {
+  _inheritsLoose(ValidationContext, _ASTValidationContext2);
+
+  function ValidationContext(schema, ast, typeInfo) {
+    var _this2;
+
+    _this2 = _ASTValidationContext2.call(this, ast) || this;
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_schema", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_typeInfo", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_fragments", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_fragmentSpreads", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_recursivelyReferencedFragments", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_variableUsages", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_recursiveVariableUsages", void 0);
+
+    _this2._schema = schema;
+    _this2._typeInfo = typeInfo;
+    _this2._fragmentSpreads = new Map();
+    _this2._recursivelyReferencedFragments = new Map();
+    _this2._variableUsages = new Map();
+    _this2._recursiveVariableUsages = new Map();
+    return _this2;
+  }
+
+  var _proto3 = ValidationContext.prototype;
+
+  _proto3.getSchema = function getSchema() {
+    return this._schema;
   };
 
-  _proto.getFragment = function getFragment(name) {
+  _proto3.getFragment = function getFragment(name) {
     var fragments = this._fragments;
 
     if (!fragments) {
@@ -88,7 +135,7 @@ function () {
     return fragments[name];
   };
 
-  _proto.getFragmentSpreads = function getFragmentSpreads(node) {
+  _proto3.getFragmentSpreads = function getFragmentSpreads(node) {
     var spreads = this._fragmentSpreads.get(node);
 
     if (!spreads) {
@@ -115,7 +162,7 @@ function () {
     return spreads;
   };
 
-  _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
+  _proto3.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
     var fragments = this._recursivelyReferencedFragments.get(operation);
 
     if (!fragments) {
@@ -124,9 +171,8 @@ function () {
       var nodesToVisit = [operation.selectionSet];
 
       while (nodesToVisit.length !== 0) {
-        var _node = nodesToVisit.pop();
-
-        var spreads = this.getFragmentSpreads(_node);
+        var node = nodesToVisit.pop();
+        var spreads = this.getFragmentSpreads(node);
 
         for (var i = 0; i < spreads.length; i++) {
           var fragName = spreads[i].name.value;
@@ -149,7 +195,7 @@ function () {
     return fragments;
   };
 
-  _proto.getVariableUsages = function getVariableUsages(node) {
+  _proto3.getVariableUsages = function getVariableUsages(node) {
     var usages = this._variableUsages.get(node);
 
     if (!usages) {
@@ -175,7 +221,7 @@ function () {
     return usages;
   };
 
-  _proto.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
+  _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
     var usages = this._recursiveVariableUsages.get(operation);
 
     if (!usages) {
@@ -192,35 +238,35 @@ function () {
     return usages;
   };
 
-  _proto.getType = function getType() {
+  _proto3.getType = function getType() {
     return this._typeInfo.getType();
   };
 
-  _proto.getParentType = function getParentType() {
+  _proto3.getParentType = function getParentType() {
     return this._typeInfo.getParentType();
   };
 
-  _proto.getInputType = function getInputType() {
+  _proto3.getInputType = function getInputType() {
     return this._typeInfo.getInputType();
   };
 
-  _proto.getParentInputType = function getParentInputType() {
+  _proto3.getParentInputType = function getParentInputType() {
     return this._typeInfo.getParentInputType();
   };
 
-  _proto.getFieldDef = function getFieldDef() {
+  _proto3.getFieldDef = function getFieldDef() {
     return this._typeInfo.getFieldDef();
   };
 
-  _proto.getDirective = function getDirective() {
+  _proto3.getDirective = function getDirective() {
     return this._typeInfo.getDirective();
   };
 
-  _proto.getArgument = function getArgument() {
+  _proto3.getArgument = function getArgument() {
     return this._typeInfo.getArgument();
   };
 
   return ValidationContext;
-}();
+}(ASTValidationContext);
 
-exports.default = ValidationContext;
\ No newline at end of file
+exports.ValidationContext = ValidationContext;
\ No newline at end of file
diff --git a/validation/ValidationContext.js.flow b/validation/ValidationContext.js.flow
index 1d6ef75..27b5243 100644
--- a/validation/ValidationContext.js.flow
+++ b/validation/ValidationContext.js.flow
@@ -8,7 +8,7 @@
  */
 
 import type { ObjMap } from '../jsutils/ObjMap';
-import { GraphQLError } from '../error';
+import type { GraphQLError } from '../error';
 import { visit, visitWithTypeInfo } from '../language/visitor';
 import { Kind } from '../language/kinds';
 import type {
@@ -19,7 +19,8 @@ import type {
   FragmentSpreadNode,
   FragmentDefinitionNode,
 } from '../language/ast';
-import { GraphQLSchema } from '../type/schema';
+import type { ASTVisitor } from '../language/visitor';
+import type { GraphQLSchema } from '../type/schema';
 import type {
   GraphQLInputType,
   GraphQLOutputType,
@@ -42,11 +43,46 @@ type VariableUsage = {|
  * allowing access to commonly useful contextual information from within a
  * validation rule.
  */
-export default class ValidationContext {
-  _schema: GraphQLSchema;
+export class ASTValidationContext {
   _ast: DocumentNode;
-  _typeInfo: TypeInfo;
   _errors: Array<GraphQLError>;
+
+  constructor(ast: DocumentNode): void {
+    this._ast = ast;
+    this._errors = [];
+  }
+
+  reportError(error: GraphQLError): void {
+    this._errors.push(error);
+  }
+
+  getErrors(): $ReadOnlyArray<GraphQLError> {
+    return this._errors;
+  }
+
+  getDocument(): DocumentNode {
+    return this._ast;
+  }
+}
+
+export class SDLValidationContext extends ASTValidationContext {
+  _schema: ?GraphQLSchema;
+
+  constructor(ast: DocumentNode, schema?: ?GraphQLSchema): void {
+    super(ast);
+    this._schema = schema;
+  }
+
+  getSchema(): ?GraphQLSchema {
+    return this._schema;
+  }
+}
+
+export type SDLValidationRule = SDLValidationContext => ASTVisitor;
+
+export class ValidationContext extends ASTValidationContext {
+  _schema: GraphQLSchema;
+  _typeInfo: TypeInfo;
   _fragments: ObjMap<FragmentDefinitionNode>;
   _fragmentSpreads: Map<SelectionSetNode, $ReadOnlyArray<FragmentSpreadNode>>;
   _recursivelyReferencedFragments: Map<
@@ -64,32 +100,19 @@ export default class ValidationContext {
     ast: DocumentNode,
     typeInfo: TypeInfo,
   ): void {
+    super(ast);
     this._schema = schema;
-    this._ast = ast;
     this._typeInfo = typeInfo;
-    this._errors = [];
     this._fragmentSpreads = new Map();
     this._recursivelyReferencedFragments = new Map();
     this._variableUsages = new Map();
     this._recursiveVariableUsages = new Map();
   }
 
-  reportError(error: GraphQLError): void {
-    this._errors.push(error);
-  }
-
-  getErrors(): $ReadOnlyArray<GraphQLError> {
-    return this._errors;
-  }
-
   getSchema(): GraphQLSchema {
     return this._schema;
   }
 
-  getDocument(): DocumentNode {
-    return this._ast;
-  }
-
   getFragment(name: string): ?FragmentDefinitionNode {
     let fragments = this._fragments;
     if (!fragments) {
@@ -227,3 +250,5 @@ export default class ValidationContext {
     return this._typeInfo.getArgument();
   }
 }
+
+export type ValidationRule = ValidationContext => ASTVisitor;
diff --git a/validation/ValidationContext.mjs b/validation/ValidationContext.mjs
index 33d9757..f415073 100644
--- a/validation/ValidationContext.mjs
+++ b/validation/ValidationContext.mjs
@@ -1,3 +1,7 @@
+function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
 function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
 
 /**
@@ -8,10 +12,8 @@ function _defineProperty(obj, key, value) { if (key in obj) { Object.definePrope
  *
  *  strict
  */
-import { GraphQLError } from '../error';
 import { visit, visitWithTypeInfo } from '../language/visitor';
 import { Kind } from '../language/kinds';
-import { GraphQLSchema } from '../type/schema';
 import { TypeInfo } from '../utilities/TypeInfo';
 
 /**
@@ -19,39 +21,19 @@ import { TypeInfo } from '../utilities/TypeInfo';
  * allowing access to commonly useful contextual information from within a
  * validation rule.
  */
-var ValidationContext =
+export var ASTValidationContext =
 /*#__PURE__*/
 function () {
-  function ValidationContext(schema, ast, typeInfo) {
-    _defineProperty(this, "_schema", void 0);
-
+  function ASTValidationContext(ast) {
     _defineProperty(this, "_ast", void 0);
 
-    _defineProperty(this, "_typeInfo", void 0);
-
     _defineProperty(this, "_errors", void 0);
 
-    _defineProperty(this, "_fragments", void 0);
-
-    _defineProperty(this, "_fragmentSpreads", void 0);
-
-    _defineProperty(this, "_recursivelyReferencedFragments", void 0);
-
-    _defineProperty(this, "_variableUsages", void 0);
-
-    _defineProperty(this, "_recursiveVariableUsages", void 0);
-
-    this._schema = schema;
     this._ast = ast;
-    this._typeInfo = typeInfo;
     this._errors = [];
-    this._fragmentSpreads = new Map();
-    this._recursivelyReferencedFragments = new Map();
-    this._variableUsages = new Map();
-    this._recursiveVariableUsages = new Map();
   }
 
-  var _proto = ValidationContext.prototype;
+  var _proto = ASTValidationContext.prototype;
 
   _proto.reportError = function reportError(error) {
     this._errors.push(error);
@@ -61,15 +43,76 @@ function () {
     return this._errors;
   };
 
-  _proto.getSchema = function getSchema() {
+  _proto.getDocument = function getDocument() {
+    return this._ast;
+  };
+
+  return ASTValidationContext;
+}();
+export var SDLValidationContext =
+/*#__PURE__*/
+function (_ASTValidationContext) {
+  _inheritsLoose(SDLValidationContext, _ASTValidationContext);
+
+  function SDLValidationContext(ast, schema) {
+    var _this;
+
+    _this = _ASTValidationContext.call(this, ast) || this;
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_schema", void 0);
+
+    _this._schema = schema;
+    return _this;
+  }
+
+  var _proto2 = SDLValidationContext.prototype;
+
+  _proto2.getSchema = function getSchema() {
     return this._schema;
   };
 
-  _proto.getDocument = function getDocument() {
-    return this._ast;
+  return SDLValidationContext;
+}(ASTValidationContext);
+export var ValidationContext =
+/*#__PURE__*/
+function (_ASTValidationContext2) {
+  _inheritsLoose(ValidationContext, _ASTValidationContext2);
+
+  function ValidationContext(schema, ast, typeInfo) {
+    var _this2;
+
+    _this2 = _ASTValidationContext2.call(this, ast) || this;
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_schema", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_typeInfo", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_fragments", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_fragmentSpreads", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_recursivelyReferencedFragments", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_variableUsages", void 0);
+
+    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_recursiveVariableUsages", void 0);
+
+    _this2._schema = schema;
+    _this2._typeInfo = typeInfo;
+    _this2._fragmentSpreads = new Map();
+    _this2._recursivelyReferencedFragments = new Map();
+    _this2._variableUsages = new Map();
+    _this2._recursiveVariableUsages = new Map();
+    return _this2;
+  }
+
+  var _proto3 = ValidationContext.prototype;
+
+  _proto3.getSchema = function getSchema() {
+    return this._schema;
   };
 
-  _proto.getFragment = function getFragment(name) {
+  _proto3.getFragment = function getFragment(name) {
     var fragments = this._fragments;
 
     if (!fragments) {
@@ -85,7 +128,7 @@ function () {
     return fragments[name];
   };
 
-  _proto.getFragmentSpreads = function getFragmentSpreads(node) {
+  _proto3.getFragmentSpreads = function getFragmentSpreads(node) {
     var spreads = this._fragmentSpreads.get(node);
 
     if (!spreads) {
@@ -112,7 +155,7 @@ function () {
     return spreads;
   };
 
-  _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
+  _proto3.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
     var fragments = this._recursivelyReferencedFragments.get(operation);
 
     if (!fragments) {
@@ -121,9 +164,8 @@ function () {
       var nodesToVisit = [operation.selectionSet];
 
       while (nodesToVisit.length !== 0) {
-        var _node = nodesToVisit.pop();
-
-        var spreads = this.getFragmentSpreads(_node);
+        var node = nodesToVisit.pop();
+        var spreads = this.getFragmentSpreads(node);
 
         for (var i = 0; i < spreads.length; i++) {
           var fragName = spreads[i].name.value;
@@ -146,7 +188,7 @@ function () {
     return fragments;
   };
 
-  _proto.getVariableUsages = function getVariableUsages(node) {
+  _proto3.getVariableUsages = function getVariableUsages(node) {
     var usages = this._variableUsages.get(node);
 
     if (!usages) {
@@ -172,7 +214,7 @@ function () {
     return usages;
   };
 
-  _proto.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
+  _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
     var usages = this._recursiveVariableUsages.get(operation);
 
     if (!usages) {
@@ -189,35 +231,33 @@ function () {
     return usages;
   };
 
-  _proto.getType = function getType() {
+  _proto3.getType = function getType() {
     return this._typeInfo.getType();
   };
 
-  _proto.getParentType = function getParentType() {
+  _proto3.getParentType = function getParentType() {
     return this._typeInfo.getParentType();
   };
 
-  _proto.getInputType = function getInputType() {
+  _proto3.getInputType = function getInputType() {
     return this._typeInfo.getInputType();
   };
 
-  _proto.getParentInputType = function getParentInputType() {
+  _proto3.getParentInputType = function getParentInputType() {
     return this._typeInfo.getParentInputType();
   };
 
-  _proto.getFieldDef = function getFieldDef() {
+  _proto3.getFieldDef = function getFieldDef() {
     return this._typeInfo.getFieldDef();
   };
 
-  _proto.getDirective = function getDirective() {
+  _proto3.getDirective = function getDirective() {
     return this._typeInfo.getDirective();
   };
 
-  _proto.getArgument = function getArgument() {
+  _proto3.getArgument = function getArgument() {
     return this._typeInfo.getArgument();
   };
 
   return ValidationContext;
-}();
-
-export { ValidationContext as default };
\ No newline at end of file
+}(ASTValidationContext);
\ No newline at end of file
diff --git a/validation/index.js b/validation/index.js
index 96de5f8..f981d60 100644
--- a/validation/index.js
+++ b/validation/index.js
@@ -12,7 +12,7 @@ Object.defineProperty(exports, "validate", {
 Object.defineProperty(exports, "ValidationContext", {
   enumerable: true,
   get: function get() {
-    return _ValidationContext.default;
+    return _ValidationContext.ValidationContext;
   }
 });
 Object.defineProperty(exports, "specifiedRules", {
@@ -174,7 +174,7 @@ Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
 
 var _validate = require("./validate");
 
-var _ValidationContext = _interopRequireDefault(require("./ValidationContext"));
+var _ValidationContext = require("./ValidationContext");
 
 var _specifiedRules = require("./specifiedRules");
 
@@ -226,6 +226,4 @@ var _ValuesOfCorrectType = require("./rules/ValuesOfCorrectType");
 
 var _VariablesAreInputTypes = require("./rules/VariablesAreInputTypes");
 
-var _VariablesInAllowedPosition = require("./rules/VariablesInAllowedPosition");
-
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
\ No newline at end of file
+var _VariablesInAllowedPosition = require("./rules/VariablesInAllowedPosition");
\ No newline at end of file
diff --git a/validation/index.js.flow b/validation/index.js.flow
index afcff69..5bd9497 100644
--- a/validation/index.js.flow
+++ b/validation/index.js.flow
@@ -9,9 +9,7 @@
 
 export { validate } from './validate';
 
-// https://github.com/tc39/proposal-export-default-from
-import ValidationContext from './ValidationContext';
-export { ValidationContext };
+export { ValidationContext } from './ValidationContext';
 
 export { specifiedRules } from './specifiedRules';
 
diff --git a/validation/index.mjs b/validation/index.mjs
index a987962..8ec3579 100644
--- a/validation/index.mjs
+++ b/validation/index.mjs
@@ -6,10 +6,8 @@
  *
  *  strict
  */
-export { validate } from './validate'; // https://github.com/tc39/proposal-export-default-from
-
-import ValidationContext from './ValidationContext';
-export { ValidationContext };
+export { validate } from './validate';
+export { ValidationContext } from './ValidationContext';
 export { specifiedRules } from './specifiedRules'; // Spec Section: "Field Selections on Objects, Interfaces, and Unions Types"
 
 export { FieldsOnCorrectType as FieldsOnCorrectTypeRule } from './rules/FieldsOnCorrectType'; // Spec Section: "Fragments on Composite Types"
diff --git a/validation/rules/ExecutableDefinitions.js b/validation/rules/ExecutableDefinitions.js
index 277267c..30e91e4 100644
--- a/validation/rules/ExecutableDefinitions.js
+++ b/validation/rules/ExecutableDefinitions.js
@@ -32,11 +32,33 @@ function nonExecutableDefinitionMessage(defName) {
 function ExecutableDefinitions(context) {
   return {
     Document: function Document(node) {
-      node.definitions.forEach(function (definition) {
-        if (definition.kind !== _kinds.Kind.OPERATION_DEFINITION && definition.kind !== _kinds.Kind.FRAGMENT_DEFINITION) {
-          context.reportError(new _error.GraphQLError(nonExecutableDefinitionMessage(definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? 'schema' : definition.name.value), [definition]));
+      var _iteratorNormalCompletion = true;
+      var _didIteratorError = false;
+      var _iteratorError = undefined;
+
+      try {
+        for (var _iterator = node.definitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+          var definition = _step.value;
+
+          if (definition.kind !== _kinds.Kind.OPERATION_DEFINITION && definition.kind !== _kinds.Kind.FRAGMENT_DEFINITION) {
+            context.reportError(new _error.GraphQLError(nonExecutableDefinitionMessage(definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? 'schema' : definition.name.value), [definition]));
+          }
         }
-      });
+      } catch (err) {
+        _didIteratorError = true;
+        _iteratorError = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion && _iterator.return != null) {
+            _iterator.return();
+          }
+        } finally {
+          if (_didIteratorError) {
+            throw _iteratorError;
+          }
+        }
+      }
+
       return false;
     }
   };
diff --git a/validation/rules/ExecutableDefinitions.js.flow b/validation/rules/ExecutableDefinitions.js.flow
index ac6a5a4..188bbbc 100644
--- a/validation/rules/ExecutableDefinitions.js.flow
+++ b/validation/rules/ExecutableDefinitions.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ASTValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import { Kind } from '../../language/kinds';
 import type { ASTVisitor } from '../../language/visitor';
@@ -22,10 +22,12 @@ export function nonExecutableDefinitionMessage(defName: string): string {
  * A GraphQL document is only valid for execution if all definitions are either
  * operation or fragment definitions.
  */
-export function ExecutableDefinitions(context: ValidationContext): ASTVisitor {
+export function ExecutableDefinitions(
+  context: ASTValidationContext,
+): ASTVisitor {
   return {
     Document(node) {
-      node.definitions.forEach(definition => {
+      for (const definition of node.definitions) {
         if (
           definition.kind !== Kind.OPERATION_DEFINITION &&
           definition.kind !== Kind.FRAGMENT_DEFINITION
@@ -42,7 +44,7 @@ export function ExecutableDefinitions(context: ValidationContext): ASTVisitor {
             ),
           );
         }
-      });
+      }
       return false;
     },
   };
diff --git a/validation/rules/ExecutableDefinitions.mjs b/validation/rules/ExecutableDefinitions.mjs
index 0204c00..68ce975 100644
--- a/validation/rules/ExecutableDefinitions.mjs
+++ b/validation/rules/ExecutableDefinitions.mjs
@@ -21,11 +21,33 @@ export function nonExecutableDefinitionMessage(defName) {
 export function ExecutableDefinitions(context) {
   return {
     Document: function Document(node) {
-      node.definitions.forEach(function (definition) {
-        if (definition.kind !== Kind.OPERATION_DEFINITION && definition.kind !== Kind.FRAGMENT_DEFINITION) {
-          context.reportError(new GraphQLError(nonExecutableDefinitionMessage(definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? 'schema' : definition.name.value), [definition]));
+      var _iteratorNormalCompletion = true;
+      var _didIteratorError = false;
+      var _iteratorError = undefined;
+
+      try {
+        for (var _iterator = node.definitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+          var definition = _step.value;
+
+          if (definition.kind !== Kind.OPERATION_DEFINITION && definition.kind !== Kind.FRAGMENT_DEFINITION) {
+            context.reportError(new GraphQLError(nonExecutableDefinitionMessage(definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? 'schema' : definition.name.value), [definition]));
+          }
         }
-      });
+      } catch (err) {
+        _didIteratorError = true;
+        _iteratorError = err;
+      } finally {
+        try {
+          if (!_iteratorNormalCompletion && _iterator.return != null) {
+            _iterator.return();
+          }
+        } finally {
+          if (_didIteratorError) {
+            throw _iteratorError;
+          }
+        }
+      }
+
       return false;
     }
   };
diff --git a/validation/rules/FieldsOnCorrectType.js b/validation/rules/FieldsOnCorrectType.js
index 42836b8..6844b67 100644
--- a/validation/rules/FieldsOnCorrectType.js
+++ b/validation/rules/FieldsOnCorrectType.js
@@ -79,22 +79,65 @@ function getSuggestedTypeNames(schema, type, fieldName) {
   if ((0, _definition.isAbstractType)(type)) {
     var suggestedObjectTypes = [];
     var interfaceUsageCount = Object.create(null);
-    schema.getPossibleTypes(type).forEach(function (possibleType) {
-      if (!possibleType.getFields()[fieldName]) {
-        return;
-      } // This object type defines this field.
-
-
-      suggestedObjectTypes.push(possibleType.name);
-      possibleType.getInterfaces().forEach(function (possibleInterface) {
-        if (!possibleInterface.getFields()[fieldName]) {
-          return;
-        } // This interface type defines this field.
-
-
-        interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;
-      });
-    }); // Suggest interface types based on how common they are.
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
+    try {
+      for (var _iterator = schema.getPossibleTypes(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+        var possibleType = _step.value;
+
+        if (!possibleType.getFields()[fieldName]) {
+          continue;
+        } // This object type defines this field.
+
+
+        suggestedObjectTypes.push(possibleType.name);
+        var _iteratorNormalCompletion2 = true;
+        var _didIteratorError2 = false;
+        var _iteratorError2 = undefined;
+
+        try {
+          for (var _iterator2 = possibleType.getInterfaces()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+            var possibleInterface = _step2.value;
+
+            if (!possibleInterface.getFields()[fieldName]) {
+              continue;
+            } // This interface type defines this field.
+
+
+            interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;
+          }
+        } catch (err) {
+          _didIteratorError2 = true;
+          _iteratorError2 = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+              _iterator2.return();
+            }
+          } finally {
+            if (_didIteratorError2) {
+              throw _iteratorError2;
+            }
+          }
+        }
+      } // Suggest interface types based on how common they are.
+
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return != null) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
+    }
 
     var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {
       return interfaceUsageCount[b] - interfaceUsageCount[a];
diff --git a/validation/rules/FieldsOnCorrectType.js.flow b/validation/rules/FieldsOnCorrectType.js.flow
index 168fc1b..a67c394 100644
--- a/validation/rules/FieldsOnCorrectType.js.flow
+++ b/validation/rules/FieldsOnCorrectType.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import suggestionList from '../../jsutils/suggestionList';
 import quotedOrList from '../../jsutils/quotedOrList';
@@ -97,21 +97,21 @@ function getSuggestedTypeNames(
   if (isAbstractType(type)) {
     const suggestedObjectTypes = [];
     const interfaceUsageCount = Object.create(null);
-    schema.getPossibleTypes(type).forEach(possibleType => {
+    for (const possibleType of schema.getPossibleTypes(type)) {
       if (!possibleType.getFields()[fieldName]) {
-        return;
+        continue;
       }
       // This object type defines this field.
       suggestedObjectTypes.push(possibleType.name);
-      possibleType.getInterfaces().forEach(possibleInterface => {
+      for (const possibleInterface of possibleType.getInterfaces()) {
         if (!possibleInterface.getFields()[fieldName]) {
-          return;
+          continue;
         }
         // This interface type defines this field.
         interfaceUsageCount[possibleInterface.name] =
           (interfaceUsageCount[possibleInterface.name] || 0) + 1;
-      });
-    });
+      }
+    }
 
     // Suggest interface types based on how common they are.
     const suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(
diff --git a/validation/rules/FieldsOnCorrectType.mjs b/validation/rules/FieldsOnCorrectType.mjs
index ce6ab28..a7c2ee5 100644
--- a/validation/rules/FieldsOnCorrectType.mjs
+++ b/validation/rules/FieldsOnCorrectType.mjs
@@ -63,22 +63,65 @@ function getSuggestedTypeNames(schema, type, fieldName) {
   if (isAbstractType(type)) {
     var suggestedObjectTypes = [];
     var interfaceUsageCount = Object.create(null);
-    schema.getPossibleTypes(type).forEach(function (possibleType) {
-      if (!possibleType.getFields()[fieldName]) {
-        return;
-      } // This object type defines this field.
-
-
-      suggestedObjectTypes.push(possibleType.name);
-      possibleType.getInterfaces().forEach(function (possibleInterface) {
-        if (!possibleInterface.getFields()[fieldName]) {
-          return;
-        } // This interface type defines this field.
-
-
-        interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;
-      });
-    }); // Suggest interface types based on how common they are.
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
+    try {
+      for (var _iterator = schema.getPossibleTypes(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+        var possibleType = _step.value;
+
+        if (!possibleType.getFields()[fieldName]) {
+          continue;
+        } // This object type defines this field.
+
+
+        suggestedObjectTypes.push(possibleType.name);
+        var _iteratorNormalCompletion2 = true;
+        var _didIteratorError2 = false;
+        var _iteratorError2 = undefined;
+
+        try {
+          for (var _iterator2 = possibleType.getInterfaces()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+            var possibleInterface = _step2.value;
+
+            if (!possibleInterface.getFields()[fieldName]) {
+              continue;
+            } // This interface type defines this field.
+
+
+            interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;
+          }
+        } catch (err) {
+          _didIteratorError2 = true;
+          _iteratorError2 = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+              _iterator2.return();
+            }
+          } finally {
+            if (_didIteratorError2) {
+              throw _iteratorError2;
+            }
+          }
+        }
+      } // Suggest interface types based on how common they are.
+
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return != null) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
+    }
 
     var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {
       return interfaceUsageCount[b] - interfaceUsageCount[a];
diff --git a/validation/rules/FragmentsOnCompositeTypes.js b/validation/rules/FragmentsOnCompositeTypes.js
index 06814ad..deceb96 100644
--- a/validation/rules/FragmentsOnCompositeTypes.js
+++ b/validation/rules/FragmentsOnCompositeTypes.js
@@ -7,8 +7,6 @@ exports.inlineFragmentOnNonCompositeErrorMessage = inlineFragmentOnNonCompositeE
 exports.fragmentOnNonCompositeErrorMessage = fragmentOnNonCompositeErrorMessage;
 exports.FragmentsOnCompositeTypes = FragmentsOnCompositeTypes;
 
-var _inspect = _interopRequireDefault(require("../../jsutils/inspect"));
-
 var _error = require("../../error");
 
 var _printer = require("../../language/printer");
@@ -17,8 +15,6 @@ var _definition = require("../../type/definition");
 
 var _typeFromAST = require("../../utilities/typeFromAST");
 
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
-
 /**
  * Copyright (c) 2015-present, Facebook, Inc.
  *
@@ -28,11 +24,11 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
  *  strict
  */
 function inlineFragmentOnNonCompositeErrorMessage(type) {
-  return "Fragment cannot condition on non composite type \"".concat((0, _inspect.default)(type), "\".");
+  return "Fragment cannot condition on non composite type \"".concat(type, "\".");
 }
 
 function fragmentOnNonCompositeErrorMessage(fragName, type) {
-  return "Fragment \"".concat(fragName, "\" cannot condition on non composite ") + "type \"".concat((0, _inspect.default)(type), "\".");
+  return "Fragment \"".concat(fragName, "\" cannot condition on non composite ") + "type \"".concat(type, "\".");
 }
 /**
  * Fragments on composite type
diff --git a/validation/rules/FragmentsOnCompositeTypes.js.flow b/validation/rules/FragmentsOnCompositeTypes.js.flow
index 9d28534..36d2eac 100644
--- a/validation/rules/FragmentsOnCompositeTypes.js.flow
+++ b/validation/rules/FragmentsOnCompositeTypes.js.flow
@@ -7,28 +7,24 @@
  * @flow strict
  */
 
-import inspect from '../../jsutils/inspect';
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import { print } from '../../language/printer';
 import type { ASTVisitor } from '../../language/visitor';
 import { isCompositeType } from '../../type/definition';
-import type { GraphQLType } from '../../type/definition';
 import { typeFromAST } from '../../utilities/typeFromAST';
 
-export function inlineFragmentOnNonCompositeErrorMessage(
-  type: GraphQLType,
-): string {
-  return `Fragment cannot condition on non composite type "${inspect(type)}".`;
+export function inlineFragmentOnNonCompositeErrorMessage(type: string): string {
+  return `Fragment cannot condition on non composite type "${type}".`;
 }
 
 export function fragmentOnNonCompositeErrorMessage(
   fragName: string,
-  type: GraphQLType,
+  type: string,
 ): string {
   return (
     `Fragment "${fragName}" cannot condition on non composite ` +
-    `type "${inspect(type)}".`
+    `type "${type}".`
   );
 }
 
diff --git a/validation/rules/FragmentsOnCompositeTypes.mjs b/validation/rules/FragmentsOnCompositeTypes.mjs
index 6a1978c..c6414fd 100644
--- a/validation/rules/FragmentsOnCompositeTypes.mjs
+++ b/validation/rules/FragmentsOnCompositeTypes.mjs
@@ -6,16 +6,15 @@
  *
  *  strict
  */
-import inspect from '../../jsutils/inspect';
 import { GraphQLError } from '../../error';
 import { print } from '../../language/printer';
 import { isCompositeType } from '../../type/definition';
 import { typeFromAST } from '../../utilities/typeFromAST';
 export function inlineFragmentOnNonCompositeErrorMessage(type) {
-  return "Fragment cannot condition on non composite type \"".concat(inspect(type), "\".");
+  return "Fragment cannot condition on non composite type \"".concat(type, "\".");
 }
 export function fragmentOnNonCompositeErrorMessage(fragName, type) {
-  return "Fragment \"".concat(fragName, "\" cannot condition on non composite ") + "type \"".concat(inspect(type), "\".");
+  return "Fragment \"".concat(fragName, "\" cannot condition on non composite ") + "type \"".concat(type, "\".");
 }
 /**
  * Fragments on composite type
diff --git a/validation/rules/KnownArgumentNames.js.flow b/validation/rules/KnownArgumentNames.js.flow
index a775880..36a5e82 100644
--- a/validation/rules/KnownArgumentNames.js.flow
+++ b/validation/rules/KnownArgumentNames.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
 import suggestionList from '../../jsutils/suggestionList';
diff --git a/validation/rules/KnownDirectives.js b/validation/rules/KnownDirectives.js
index 6f9bd69..db91f61 100644
--- a/validation/rules/KnownDirectives.js
+++ b/validation/rules/KnownDirectives.js
@@ -9,13 +9,11 @@ exports.KnownDirectives = KnownDirectives;
 
 var _error = require("../../error");
 
-var _find = _interopRequireDefault(require("../../jsutils/find"));
-
 var _kinds = require("../../language/kinds");
 
 var _directiveLocation = require("../../language/directiveLocation");
 
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+var _directives = require("../../type/directives");
 
 /**
  * Copyright (c) 2015-present, Facebook, Inc.
@@ -41,21 +39,77 @@ function misplacedDirectiveMessage(directiveName, location) {
 
 
 function KnownDirectives(context) {
+  var locationsMap = Object.create(null);
+  var schema = context.getSchema();
+  var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
+  var _iteratorNormalCompletion = true;
+  var _didIteratorError = false;
+  var _iteratorError = undefined;
+
+  try {
+    for (var _iterator = definedDirectives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+      var directive = _step.value;
+      locationsMap[directive.name] = directive.locations;
+    }
+  } catch (err) {
+    _didIteratorError = true;
+    _iteratorError = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion && _iterator.return != null) {
+        _iterator.return();
+      }
+    } finally {
+      if (_didIteratorError) {
+        throw _iteratorError;
+      }
+    }
+  }
+
+  var astDefinitions = context.getDocument().definitions;
+  var _iteratorNormalCompletion2 = true;
+  var _didIteratorError2 = false;
+  var _iteratorError2 = undefined;
+
+  try {
+    for (var _iterator2 = astDefinitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+      var def = _step2.value;
+
+      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
+        locationsMap[def.name.value] = def.locations.map(function (name) {
+          return name.value;
+        });
+      }
+    }
+  } catch (err) {
+    _didIteratorError2 = true;
+    _iteratorError2 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+        _iterator2.return();
+      }
+    } finally {
+      if (_didIteratorError2) {
+        throw _iteratorError2;
+      }
+    }
+  }
+
   return {
     Directive: function Directive(node, key, parent, path, ancestors) {
-      var directiveDef = (0, _find.default)(context.getSchema().getDirectives(), function (def) {
-        return def.name === node.name.value;
-      });
+      var name = node.name.value;
+      var locations = locationsMap[name];
 
-      if (!directiveDef) {
-        context.reportError(new _error.GraphQLError(unknownDirectiveMessage(node.name.value), [node]));
+      if (!locations) {
+        context.reportError(new _error.GraphQLError(unknownDirectiveMessage(name), [node]));
         return;
       }
 
       var candidateLocation = getDirectiveLocationForASTPath(ancestors);
 
-      if (candidateLocation && directiveDef.locations.indexOf(candidateLocation) === -1) {
-        context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, candidateLocation), [node]));
+      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
+        context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(name, candidateLocation), [node]));
       }
     }
   };
diff --git a/validation/rules/KnownDirectives.js.flow b/validation/rules/KnownDirectives.js.flow
index 05c12f3..37f273f 100644
--- a/validation/rules/KnownDirectives.js.flow
+++ b/validation/rules/KnownDirectives.js.flow
@@ -7,12 +7,15 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type {
+  ValidationContext,
+  SDLValidationContext,
+} from '../ValidationContext';
 import { GraphQLError } from '../../error';
-import find from '../../jsutils/find';
 import { Kind } from '../../language/kinds';
 import { DirectiveLocation } from '../../language/directiveLocation';
 import type { ASTVisitor } from '../../language/visitor';
+import { specifiedDirectives } from '../../type/directives';
 
 export function unknownDirectiveMessage(directiveName: string): string {
   return `Unknown directive "${directiveName}".`;
@@ -31,29 +34,42 @@ export function misplacedDirectiveMessage(
  * A GraphQL document is only valid if all `@directives` are known by the
  * schema and legally positioned.
  */
-export function KnownDirectives(context: ValidationContext): ASTVisitor {
+export function KnownDirectives(
+  context: ValidationContext | SDLValidationContext,
+): ASTVisitor {
+  const locationsMap = Object.create(null);
+  const schema = context.getSchema();
+  const definedDirectives = schema
+    ? schema.getDirectives()
+    : specifiedDirectives;
+  for (const directive of definedDirectives) {
+    locationsMap[directive.name] = directive.locations;
+  }
+
+  const astDefinitions = context.getDocument().definitions;
+  for (const def of astDefinitions) {
+    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
+      locationsMap[def.name.value] = def.locations.map(name => name.value);
+    }
+  }
+
   return {
     Directive(node, key, parent, path, ancestors) {
-      const directiveDef = find(
-        context.getSchema().getDirectives(),
-        def => def.name === node.name.value,
-      );
-      if (!directiveDef) {
+      const name = node.name.value;
+      const locations = locationsMap[name];
+
+      if (!locations) {
         context.reportError(
-          new GraphQLError(unknownDirectiveMessage(node.name.value), [node]),
+          new GraphQLError(unknownDirectiveMessage(name), [node]),
         );
         return;
       }
       const candidateLocation = getDirectiveLocationForASTPath(ancestors);
-      if (
-        candidateLocation &&
-        directiveDef.locations.indexOf(candidateLocation) === -1
-      ) {
+      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
         context.reportError(
-          new GraphQLError(
-            misplacedDirectiveMessage(node.name.value, candidateLocation),
-            [node],
-          ),
+          new GraphQLError(misplacedDirectiveMessage(name, candidateLocation), [
+            node,
+          ]),
         );
       }
     },
diff --git a/validation/rules/KnownDirectives.mjs b/validation/rules/KnownDirectives.mjs
index e3b6d85..5f68a7e 100644
--- a/validation/rules/KnownDirectives.mjs
+++ b/validation/rules/KnownDirectives.mjs
@@ -7,9 +7,9 @@
  *  strict
  */
 import { GraphQLError } from '../../error';
-import find from '../../jsutils/find';
 import { Kind } from '../../language/kinds';
 import { DirectiveLocation } from '../../language/directiveLocation';
+import { specifiedDirectives } from '../../type/directives';
 export function unknownDirectiveMessage(directiveName) {
   return "Unknown directive \"".concat(directiveName, "\".");
 }
@@ -24,21 +24,77 @@ export function misplacedDirectiveMessage(directiveName, location) {
  */
 
 export function KnownDirectives(context) {
+  var locationsMap = Object.create(null);
+  var schema = context.getSchema();
+  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
+  var _iteratorNormalCompletion = true;
+  var _didIteratorError = false;
+  var _iteratorError = undefined;
+
+  try {
+    for (var _iterator = definedDirectives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+      var directive = _step.value;
+      locationsMap[directive.name] = directive.locations;
+    }
+  } catch (err) {
+    _didIteratorError = true;
+    _iteratorError = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion && _iterator.return != null) {
+        _iterator.return();
+      }
+    } finally {
+      if (_didIteratorError) {
+        throw _iteratorError;
+      }
+    }
+  }
+
+  var astDefinitions = context.getDocument().definitions;
+  var _iteratorNormalCompletion2 = true;
+  var _didIteratorError2 = false;
+  var _iteratorError2 = undefined;
+
+  try {
+    for (var _iterator2 = astDefinitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+      var def = _step2.value;
+
+      if (def.kind === Kind.DIRECTIVE_DEFINITION) {
+        locationsMap[def.name.value] = def.locations.map(function (name) {
+          return name.value;
+        });
+      }
+    }
+  } catch (err) {
+    _didIteratorError2 = true;
+    _iteratorError2 = err;
+  } finally {
+    try {
+      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+        _iterator2.return();
+      }
+    } finally {
+      if (_didIteratorError2) {
+        throw _iteratorError2;
+      }
+    }
+  }
+
   return {
     Directive: function Directive(node, key, parent, path, ancestors) {
-      var directiveDef = find(context.getSchema().getDirectives(), function (def) {
-        return def.name === node.name.value;
-      });
+      var name = node.name.value;
+      var locations = locationsMap[name];
 
-      if (!directiveDef) {
-        context.reportError(new GraphQLError(unknownDirectiveMessage(node.name.value), [node]));
+      if (!locations) {
+        context.reportError(new GraphQLError(unknownDirectiveMessage(name), [node]));
         return;
       }
 
       var candidateLocation = getDirectiveLocationForASTPath(ancestors);
 
-      if (candidateLocation && directiveDef.locations.indexOf(candidateLocation) === -1) {
-        context.reportError(new GraphQLError(misplacedDirectiveMessage(node.name.value, candidateLocation), [node]));
+      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
+        context.reportError(new GraphQLError(misplacedDirectiveMessage(name, candidateLocation), [node]));
       }
     }
   };
diff --git a/validation/rules/KnownFragmentNames.js.flow b/validation/rules/KnownFragmentNames.js.flow
index c389341..7135801 100644
--- a/validation/rules/KnownFragmentNames.js.flow
+++ b/validation/rules/KnownFragmentNames.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
 
diff --git a/validation/rules/KnownTypeNames.js.flow b/validation/rules/KnownTypeNames.js.flow
index 8ad1b77..04daa41 100644
--- a/validation/rules/KnownTypeNames.js.flow
+++ b/validation/rules/KnownTypeNames.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import suggestionList from '../../jsutils/suggestionList';
 import quotedOrList from '../../jsutils/quotedOrList';
diff --git a/validation/rules/LoneAnonymousOperation.js.flow b/validation/rules/LoneAnonymousOperation.js.flow
index 745de20..e3ef981 100644
--- a/validation/rules/LoneAnonymousOperation.js.flow
+++ b/validation/rules/LoneAnonymousOperation.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ASTValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import { Kind } from '../../language/kinds';
 import type { ASTVisitor } from '../../language/visitor';
@@ -22,7 +22,9 @@ export function anonOperationNotAloneMessage(): string {
  * A GraphQL document is only valid if when it contains an anonymous operation
  * (the query short-hand) that it contains only that one operation definition.
  */
-export function LoneAnonymousOperation(context: ValidationContext): ASTVisitor {
+export function LoneAnonymousOperation(
+  context: ASTValidationContext,
+): ASTVisitor {
   let operationCount = 0;
   return {
     Document(node) {
diff --git a/validation/rules/LoneSchemaDefinition.js b/validation/rules/LoneSchemaDefinition.js
new file mode 100644
index 0000000..7c9b2e6
--- /dev/null
+++ b/validation/rules/LoneSchemaDefinition.js
@@ -0,0 +1,55 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.schemaDefinitionNotAloneMessage = schemaDefinitionNotAloneMessage;
+exports.canNotDefineSchemaWithinExtension = canNotDefineSchemaWithinExtension;
+exports.LoneSchemaDefinition = LoneSchemaDefinition;
+
+var _error = require("../../error");
+
+/**
+ * Copyright (c) 2018-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *  strict
+ */
+function schemaDefinitionNotAloneMessage() {
+  return 'Must provide only one schema definition.';
+}
+
+function canNotDefineSchemaWithinExtension() {
+  return 'Cannot define a new schema within a schema extension.';
+}
+/**
+ * Lone Schema definition
+ *
+ * A GraphQL document is only valid if it contains only one schema definition.
+ */
+
+
+function LoneSchemaDefinition(context) {
+  var oldSchema = context.getSchema();
+  var alreadyDefined = oldSchema && (oldSchema.astNode || oldSchema.getQueryType() || oldSchema.getMutationType() || oldSchema.getSubscriptionType());
+  var schemaNodes = [];
+  return {
+    SchemaDefinition: function SchemaDefinition(node) {
+      if (alreadyDefined) {
+        context.reportError(new _error.GraphQLError(canNotDefineSchemaWithinExtension(), [node]));
+        return;
+      }
+
+      schemaNodes.push(node);
+    },
+    Document: {
+      leave: function leave() {
+        if (schemaNodes.length > 1) {
+          context.reportError(new _error.GraphQLError(schemaDefinitionNotAloneMessage(), schemaNodes));
+        }
+      }
+    }
+  };
+}
\ No newline at end of file
diff --git a/validation/rules/LoneSchemaDefinition.js.flow b/validation/rules/LoneSchemaDefinition.js.flow
new file mode 100644
index 0000000..e76f2d9
--- /dev/null
+++ b/validation/rules/LoneSchemaDefinition.js.flow
@@ -0,0 +1,59 @@
+/**
+ * Copyright (c) 2018-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow strict
+ */
+
+import type { SDLValidationContext } from '../ValidationContext';
+import { GraphQLError } from '../../error';
+import type { ASTVisitor } from '../../language/visitor';
+
+export function schemaDefinitionNotAloneMessage(): string {
+  return 'Must provide only one schema definition.';
+}
+
+export function canNotDefineSchemaWithinExtension(): string {
+  return 'Cannot define a new schema within a schema extension.';
+}
+
+/**
+ * Lone Schema definition
+ *
+ * A GraphQL document is only valid if it contains only one schema definition.
+ */
+export function LoneSchemaDefinition(
+  context: SDLValidationContext,
+): ASTVisitor {
+  const oldSchema = context.getSchema();
+  const alreadyDefined =
+    oldSchema &&
+    (oldSchema.astNode ||
+      oldSchema.getQueryType() ||
+      oldSchema.getMutationType() ||
+      oldSchema.getSubscriptionType());
+
+  const schemaNodes = [];
+  return {
+    SchemaDefinition(node) {
+      if (alreadyDefined) {
+        context.reportError(
+          new GraphQLError(canNotDefineSchemaWithinExtension(), [node]),
+        );
+        return;
+      }
+      schemaNodes.push(node);
+    },
+    Document: {
+      leave() {
+        if (schemaNodes.length > 1) {
+          context.reportError(
+            new GraphQLError(schemaDefinitionNotAloneMessage(), schemaNodes),
+          );
+        }
+      },
+    },
+  };
+}
diff --git a/validation/rules/LoneSchemaDefinition.mjs b/validation/rules/LoneSchemaDefinition.mjs
new file mode 100644
index 0000000..0fd6f5e
--- /dev/null
+++ b/validation/rules/LoneSchemaDefinition.mjs
@@ -0,0 +1,43 @@
+/**
+ * Copyright (c) 2018-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *  strict
+ */
+import { GraphQLError } from '../../error';
+export function schemaDefinitionNotAloneMessage() {
+  return 'Must provide only one schema definition.';
+}
+export function canNotDefineSchemaWithinExtension() {
+  return 'Cannot define a new schema within a schema extension.';
+}
+/**
+ * Lone Schema definition
+ *
+ * A GraphQL document is only valid if it contains only one schema definition.
+ */
+
+export function LoneSchemaDefinition(context) {
+  var oldSchema = context.getSchema();
+  var alreadyDefined = oldSchema && (oldSchema.astNode || oldSchema.getQueryType() || oldSchema.getMutationType() || oldSchema.getSubscriptionType());
+  var schemaNodes = [];
+  return {
+    SchemaDefinition: function SchemaDefinition(node) {
+      if (alreadyDefined) {
+        context.reportError(new GraphQLError(canNotDefineSchemaWithinExtension(), [node]));
+        return;
+      }
+
+      schemaNodes.push(node);
+    },
+    Document: {
+      leave: function leave() {
+        if (schemaNodes.length > 1) {
+          context.reportError(new GraphQLError(schemaDefinitionNotAloneMessage(), schemaNodes));
+        }
+      }
+    }
+  };
+}
\ No newline at end of file
diff --git a/validation/rules/NoFragmentCycles.js b/validation/rules/NoFragmentCycles.js
index 022ca76..9ad6ad8 100644
--- a/validation/rules/NoFragmentCycles.js
+++ b/validation/rules/NoFragmentCycles.js
@@ -34,10 +34,7 @@ function NoFragmentCycles(context) {
       return false;
     },
     FragmentDefinition: function FragmentDefinition(node) {
-      if (!visitedFrags[node.name.value]) {
-        detectCycleRecursive(node);
-      }
-
+      detectCycleRecursive(node);
       return false;
     }
   }; // This does a straight-forward DFS to find cycles.
@@ -45,6 +42,10 @@ function NoFragmentCycles(context) {
   // the graph to find all possible cycles.
 
   function detectCycleRecursive(fragment) {
+    if (visitedFrags[fragment.name.value]) {
+      return;
+    }
+
     var fragmentName = fragment.name.value;
     visitedFrags[fragmentName] = true;
     var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
@@ -59,25 +60,23 @@ function NoFragmentCycles(context) {
       var spreadNode = spreadNodes[i];
       var spreadName = spreadNode.name.value;
       var cycleIndex = spreadPathIndexByName[spreadName];
+      spreadPath.push(spreadNode);
 
       if (cycleIndex === undefined) {
-        spreadPath.push(spreadNode);
-
-        if (!visitedFrags[spreadName]) {
-          var spreadFragment = context.getFragment(spreadName);
+        var spreadFragment = context.getFragment(spreadName);
 
-          if (spreadFragment) {
-            detectCycleRecursive(spreadFragment);
-          }
+        if (spreadFragment) {
+          detectCycleRecursive(spreadFragment);
         }
-
-        spreadPath.pop();
       } else {
         var cyclePath = spreadPath.slice(cycleIndex);
-        context.reportError(new _error.GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {
+        var fragmentNames = cyclePath.slice(0, -1).map(function (s) {
           return s.name.value;
-        })), cyclePath.concat(spreadNode)));
+        });
+        context.reportError(new _error.GraphQLError(cycleErrorMessage(spreadName, fragmentNames), cyclePath));
       }
+
+      spreadPath.pop();
     }
 
     spreadPathIndexByName[fragmentName] = undefined;
diff --git a/validation/rules/NoFragmentCycles.js.flow b/validation/rules/NoFragmentCycles.js.flow
index 0a51122..6321902 100644
--- a/validation/rules/NoFragmentCycles.js.flow
+++ b/validation/rules/NoFragmentCycles.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { FragmentDefinitionNode } from '../../language/ast';
 import type { ASTVisitor } from '../../language/visitor';
@@ -34,9 +34,7 @@ export function NoFragmentCycles(context: ValidationContext): ASTVisitor {
   return {
     OperationDefinition: () => false,
     FragmentDefinition(node) {
-      if (!visitedFrags[node.name.value]) {
-        detectCycleRecursive(node);
-      }
+      detectCycleRecursive(node);
       return false;
     },
   };
@@ -45,6 +43,10 @@ export function NoFragmentCycles(context: ValidationContext): ASTVisitor {
   // It does not terminate when a cycle was found but continues to explore
   // the graph to find all possible cycles.
   function detectCycleRecursive(fragment: FragmentDefinitionNode) {
+    if (visitedFrags[fragment.name.value]) {
+      return;
+    }
+
     const fragmentName = fragment.name.value;
     visitedFrags[fragmentName] = true;
 
@@ -60,24 +62,23 @@ export function NoFragmentCycles(context: ValidationContext): ASTVisitor {
       const spreadName = spreadNode.name.value;
       const cycleIndex = spreadPathIndexByName[spreadName];
 
+      spreadPath.push(spreadNode);
       if (cycleIndex === undefined) {
-        spreadPath.push(spreadNode);
-        if (!visitedFrags[spreadName]) {
-          const spreadFragment = context.getFragment(spreadName);
-          if (spreadFragment) {
-            detectCycleRecursive(spreadFragment);
-          }
+        const spreadFragment = context.getFragment(spreadName);
+        if (spreadFragment) {
+          detectCycleRecursive(spreadFragment);
         }
-        spreadPath.pop();
       } else {
         const cyclePath = spreadPath.slice(cycleIndex);
+        const fragmentNames = cyclePath.slice(0, -1).map(s => s.name.value);
         context.reportError(
           new GraphQLError(
-            cycleErrorMessage(spreadName, cyclePath.map(s => s.name.value)),
-            cyclePath.concat(spreadNode),
+            cycleErrorMessage(spreadName, fragmentNames),
+            cyclePath,
           ),
         );
       }
+      spreadPath.pop();
     }
 
     spreadPathIndexByName[fragmentName] = undefined;
diff --git a/validation/rules/NoFragmentCycles.mjs b/validation/rules/NoFragmentCycles.mjs
index 5d18024..e251245 100644
--- a/validation/rules/NoFragmentCycles.mjs
+++ b/validation/rules/NoFragmentCycles.mjs
@@ -24,10 +24,7 @@ export function NoFragmentCycles(context) {
       return false;
     },
     FragmentDefinition: function FragmentDefinition(node) {
-      if (!visitedFrags[node.name.value]) {
-        detectCycleRecursive(node);
-      }
-
+      detectCycleRecursive(node);
       return false;
     }
   }; // This does a straight-forward DFS to find cycles.
@@ -35,6 +32,10 @@ export function NoFragmentCycles(context) {
   // the graph to find all possible cycles.
 
   function detectCycleRecursive(fragment) {
+    if (visitedFrags[fragment.name.value]) {
+      return;
+    }
+
     var fragmentName = fragment.name.value;
     visitedFrags[fragmentName] = true;
     var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
@@ -49,25 +50,23 @@ export function NoFragmentCycles(context) {
       var spreadNode = spreadNodes[i];
       var spreadName = spreadNode.name.value;
       var cycleIndex = spreadPathIndexByName[spreadName];
+      spreadPath.push(spreadNode);
 
       if (cycleIndex === undefined) {
-        spreadPath.push(spreadNode);
-
-        if (!visitedFrags[spreadName]) {
-          var spreadFragment = context.getFragment(spreadName);
+        var spreadFragment = context.getFragment(spreadName);
 
-          if (spreadFragment) {
-            detectCycleRecursive(spreadFragment);
-          }
+        if (spreadFragment) {
+          detectCycleRecursive(spreadFragment);
         }
-
-        spreadPath.pop();
       } else {
         var cyclePath = spreadPath.slice(cycleIndex);
-        context.reportError(new GraphQLError(cycleErrorMessage(spreadName, cyclePath.map(function (s) {
+        var fragmentNames = cyclePath.slice(0, -1).map(function (s) {
           return s.name.value;
-        })), cyclePath.concat(spreadNode)));
+        });
+        context.reportError(new GraphQLError(cycleErrorMessage(spreadName, fragmentNames), cyclePath));
       }
+
+      spreadPath.pop();
     }
 
     spreadPathIndexByName[fragmentName] = undefined;
diff --git a/validation/rules/NoUndefinedVariables.js b/validation/rules/NoUndefinedVariables.js
index 0400cfc..99f807f 100644
--- a/validation/rules/NoUndefinedVariables.js
+++ b/validation/rules/NoUndefinedVariables.js
@@ -36,14 +36,34 @@ function NoUndefinedVariables(context) {
       },
       leave: function leave(operation) {
         var usages = context.getRecursiveVariableUsages(operation);
-        usages.forEach(function (_ref) {
-          var node = _ref.node;
-          var varName = node.name.value;
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
 
-          if (variableNameDefined[varName] !== true) {
-            context.reportError(new _error.GraphQLError(undefinedVarMessage(varName, operation.name && operation.name.value), [node, operation]));
+        try {
+          for (var _iterator = usages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var _ref2 = _step.value;
+            var node = _ref2.node;
+            var varName = node.name.value;
+
+            if (variableNameDefined[varName] !== true) {
+              context.reportError(new _error.GraphQLError(undefinedVarMessage(varName, operation.name && operation.name.value), [node, operation]));
+            }
+          }
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
+            }
           }
-        });
+        }
       }
     },
     VariableDefinition: function VariableDefinition(node) {
diff --git a/validation/rules/NoUndefinedVariables.js.flow b/validation/rules/NoUndefinedVariables.js.flow
index d74a492..0fcfe50 100644
--- a/validation/rules/NoUndefinedVariables.js.flow
+++ b/validation/rules/NoUndefinedVariables.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
 
@@ -34,7 +34,7 @@ export function NoUndefinedVariables(context: ValidationContext): ASTVisitor {
       leave(operation) {
         const usages = context.getRecursiveVariableUsages(operation);
 
-        usages.forEach(({ node }) => {
+        for (const { node } of usages) {
           const varName = node.name.value;
           if (variableNameDefined[varName] !== true) {
             context.reportError(
@@ -47,7 +47,7 @@ export function NoUndefinedVariables(context: ValidationContext): ASTVisitor {
               ),
             );
           }
-        });
+        }
       },
     },
     VariableDefinition(node) {
diff --git a/validation/rules/NoUndefinedVariables.mjs b/validation/rules/NoUndefinedVariables.mjs
index 14011d3..6551026 100644
--- a/validation/rules/NoUndefinedVariables.mjs
+++ b/validation/rules/NoUndefinedVariables.mjs
@@ -26,14 +26,34 @@ export function NoUndefinedVariables(context) {
       },
       leave: function leave(operation) {
         var usages = context.getRecursiveVariableUsages(operation);
-        usages.forEach(function (_ref) {
-          var node = _ref.node;
-          var varName = node.name.value;
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
 
-          if (variableNameDefined[varName] !== true) {
-            context.reportError(new GraphQLError(undefinedVarMessage(varName, operation.name && operation.name.value), [node, operation]));
+        try {
+          for (var _iterator = usages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var _ref2 = _step.value;
+            var node = _ref2.node;
+            var varName = node.name.value;
+
+            if (variableNameDefined[varName] !== true) {
+              context.reportError(new GraphQLError(undefinedVarMessage(varName, operation.name && operation.name.value), [node, operation]));
+            }
+          }
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
+            }
           }
-        });
+        }
       }
     },
     VariableDefinition: function VariableDefinition(node) {
diff --git a/validation/rules/NoUnusedFragments.js b/validation/rules/NoUnusedFragments.js
index db193c0..8fe0a57 100644
--- a/validation/rules/NoUnusedFragments.js
+++ b/validation/rules/NoUnusedFragments.js
@@ -42,18 +42,42 @@ function NoUnusedFragments(context) {
     Document: {
       leave: function leave() {
         var fragmentNameUsed = Object.create(null);
-        operationDefs.forEach(function (operation) {
-          context.getRecursivelyReferencedFragments(operation).forEach(function (fragment) {
-            fragmentNameUsed[fragment.name.value] = true;
-          });
-        });
-        fragmentDefs.forEach(function (fragmentDef) {
+
+        for (var _i = 0; _i < operationDefs.length; _i++) {
+          var operation = operationDefs[_i];
+          var _iteratorNormalCompletion = true;
+          var _didIteratorError = false;
+          var _iteratorError = undefined;
+
+          try {
+            for (var _iterator = context.getRecursivelyReferencedFragments(operation)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+              var fragment = _step.value;
+              fragmentNameUsed[fragment.name.value] = true;
+            }
+          } catch (err) {
+            _didIteratorError = true;
+            _iteratorError = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion && _iterator.return != null) {
+                _iterator.return();
+              }
+            } finally {
+              if (_didIteratorError) {
+                throw _iteratorError;
+              }
+            }
+          }
+        }
+
+        for (var _i2 = 0; _i2 < fragmentDefs.length; _i2++) {
+          var fragmentDef = fragmentDefs[_i2];
           var fragName = fragmentDef.name.value;
 
           if (fragmentNameUsed[fragName] !== true) {
             context.reportError(new _error.GraphQLError(unusedFragMessage(fragName), [fragmentDef]));
           }
-        });
+        }
       }
     }
   };
diff --git a/validation/rules/NoUnusedFragments.js.flow b/validation/rules/NoUnusedFragments.js.flow
index 4e2b6e2..a3ff407 100644
--- a/validation/rules/NoUnusedFragments.js.flow
+++ b/validation/rules/NoUnusedFragments.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
 
@@ -37,22 +37,22 @@ export function NoUnusedFragments(context: ValidationContext): ASTVisitor {
     Document: {
       leave() {
         const fragmentNameUsed = Object.create(null);
-        operationDefs.forEach(operation => {
-          context
-            .getRecursivelyReferencedFragments(operation)
-            .forEach(fragment => {
-              fragmentNameUsed[fragment.name.value] = true;
-            });
-        });
+        for (const operation of operationDefs) {
+          for (const fragment of context.getRecursivelyReferencedFragments(
+            operation,
+          )) {
+            fragmentNameUsed[fragment.name.value] = true;
+          }
+        }
 
-        fragmentDefs.forEach(fragmentDef => {
+        for (const fragmentDef of fragmentDefs) {
           const fragName = fragmentDef.name.value;
           if (fragmentNameUsed[fragName] !== true) {
             context.reportError(
               new GraphQLError(unusedFragMessage(fragName), [fragmentDef]),
             );
           }
-        });
+        }
       },
     },
   };
diff --git a/validation/rules/NoUnusedFragments.mjs b/validation/rules/NoUnusedFragments.mjs
index 2585f5a..4b11543 100644
--- a/validation/rules/NoUnusedFragments.mjs
+++ b/validation/rules/NoUnusedFragments.mjs
@@ -32,18 +32,42 @@ export function NoUnusedFragments(context) {
     Document: {
       leave: function leave() {
         var fragmentNameUsed = Object.create(null);
-        operationDefs.forEach(function (operation) {
-          context.getRecursivelyReferencedFragments(operation).forEach(function (fragment) {
-            fragmentNameUsed[fragment.name.value] = true;
-          });
-        });
-        fragmentDefs.forEach(function (fragmentDef) {
+
+        for (var _i = 0; _i < operationDefs.length; _i++) {
+          var operation = operationDefs[_i];
+          var _iteratorNormalCompletion = true;
+          var _didIteratorError = false;
+          var _iteratorError = undefined;
+
+          try {
+            for (var _iterator = context.getRecursivelyReferencedFragments(operation)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+              var fragment = _step.value;
+              fragmentNameUsed[fragment.name.value] = true;
+            }
+          } catch (err) {
+            _didIteratorError = true;
+            _iteratorError = err;
+          } finally {
+            try {
+              if (!_iteratorNormalCompletion && _iterator.return != null) {
+                _iterator.return();
+              }
+            } finally {
+              if (_didIteratorError) {
+                throw _iteratorError;
+              }
+            }
+          }
+        }
+
+        for (var _i2 = 0; _i2 < fragmentDefs.length; _i2++) {
+          var fragmentDef = fragmentDefs[_i2];
           var fragName = fragmentDef.name.value;
 
           if (fragmentNameUsed[fragName] !== true) {
             context.reportError(new GraphQLError(unusedFragMessage(fragName), [fragmentDef]));
           }
-        });
+        }
       }
     }
   };
diff --git a/validation/rules/NoUnusedVariables.js b/validation/rules/NoUnusedVariables.js
index a7baa1f..2a7e1d7 100644
--- a/validation/rules/NoUnusedVariables.js
+++ b/validation/rules/NoUnusedVariables.js
@@ -38,17 +38,39 @@ function NoUnusedVariables(context) {
         var variableNameUsed = Object.create(null);
         var usages = context.getRecursiveVariableUsages(operation);
         var opName = operation.name ? operation.name.value : null;
-        usages.forEach(function (_ref) {
-          var node = _ref.node;
-          variableNameUsed[node.name.value] = true;
-        });
-        variableDefs.forEach(function (variableDef) {
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
+
+        try {
+          for (var _iterator = usages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var _ref2 = _step.value;
+            var node = _ref2.node;
+            variableNameUsed[node.name.value] = true;
+          }
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
+            }
+          }
+        }
+
+        for (var _i = 0; _i < variableDefs.length; _i++) {
+          var variableDef = variableDefs[_i];
           var variableName = variableDef.variable.name.value;
 
           if (variableNameUsed[variableName] !== true) {
             context.reportError(new _error.GraphQLError(unusedVariableMessage(variableName, opName), [variableDef]));
           }
-        });
+        }
       }
     },
     VariableDefinition: function VariableDefinition(def) {
diff --git a/validation/rules/NoUnusedVariables.js.flow b/validation/rules/NoUnusedVariables.js.flow
index c5637e2..378616f 100644
--- a/validation/rules/NoUnusedVariables.js.flow
+++ b/validation/rules/NoUnusedVariables.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
 
@@ -39,11 +39,11 @@ export function NoUnusedVariables(context: ValidationContext): ASTVisitor {
         const usages = context.getRecursiveVariableUsages(operation);
         const opName = operation.name ? operation.name.value : null;
 
-        usages.forEach(({ node }) => {
+        for (const { node } of usages) {
           variableNameUsed[node.name.value] = true;
-        });
+        }
 
-        variableDefs.forEach(variableDef => {
+        for (const variableDef of variableDefs) {
           const variableName = variableDef.variable.name.value;
           if (variableNameUsed[variableName] !== true) {
             context.reportError(
@@ -52,7 +52,7 @@ export function NoUnusedVariables(context: ValidationContext): ASTVisitor {
               ]),
             );
           }
-        });
+        }
       },
     },
     VariableDefinition(def) {
diff --git a/validation/rules/NoUnusedVariables.mjs b/validation/rules/NoUnusedVariables.mjs
index bfbbf5b..67cfcd8 100644
--- a/validation/rules/NoUnusedVariables.mjs
+++ b/validation/rules/NoUnusedVariables.mjs
@@ -28,17 +28,39 @@ export function NoUnusedVariables(context) {
         var variableNameUsed = Object.create(null);
         var usages = context.getRecursiveVariableUsages(operation);
         var opName = operation.name ? operation.name.value : null;
-        usages.forEach(function (_ref) {
-          var node = _ref.node;
-          variableNameUsed[node.name.value] = true;
-        });
-        variableDefs.forEach(function (variableDef) {
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
+
+        try {
+          for (var _iterator = usages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var _ref2 = _step.value;
+            var node = _ref2.node;
+            variableNameUsed[node.name.value] = true;
+          }
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
+            }
+          }
+        }
+
+        for (var _i = 0; _i < variableDefs.length; _i++) {
+          var variableDef = variableDefs[_i];
           var variableName = variableDef.variable.name.value;
 
           if (variableNameUsed[variableName] !== true) {
             context.reportError(new GraphQLError(unusedVariableMessage(variableName, opName), [variableDef]));
           }
-        });
+        }
       }
     },
     VariableDefinition: function VariableDefinition(def) {
diff --git a/validation/rules/OverlappingFieldsCanBeMerged.js b/validation/rules/OverlappingFieldsCanBeMerged.js
index 043a74f..707d7d9 100644
--- a/validation/rules/OverlappingFieldsCanBeMerged.js
+++ b/validation/rules/OverlappingFieldsCanBeMerged.js
@@ -60,14 +60,16 @@ function OverlappingFieldsCanBeMerged(context) {
   return {
     SelectionSet: function SelectionSet(selectionSet) {
       var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
-      conflicts.forEach(function (_ref2) {
-        var _ref2$ = _ref2[0],
-            responseName = _ref2$[0],
-            reason = _ref2$[1],
-            fields1 = _ref2[1],
-            fields2 = _ref2[2];
-        return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));
-      });
+
+      for (var _i = 0; _i < conflicts.length; _i++) {
+        var _ref3 = conflicts[_i];
+        var _ref2$ = _ref3[0];
+        var responseName = _ref2$[0];
+        var reason = _ref2$[1];
+        var fields1 = _ref3[1];
+        var fields2 = _ref3[2];
+        context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));
+      }
     }
   };
 }
@@ -278,9 +280,9 @@ function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNa
   // names to each item in the second set of names.
 
 
-  for (var _i = 0; _i < fragmentNames1.length; _i++) {
+  for (var _i2 = 0; _i2 < fragmentNames1.length; _i2++) {
     for (var _j = 0; _j < fragmentNames2.length; _j++) {
-      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);
+      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i2], fragmentNames2[_j]);
     }
   }
 
@@ -293,7 +295,10 @@ function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames
   // name and the value at that key is a list of all fields which provide that
   // response name. For every response name, if there are multiple fields, they
   // must be compared to find a potential conflict.
-  Object.keys(fieldMap).forEach(function (responseName) {
+  var _arr = Object.keys(fieldMap);
+
+  for (var _i3 = 0; _i3 < _arr.length; _i3++) {
+    var responseName = _arr[_i3];
     var fields = fieldMap[responseName]; // This compares every field in the list to every other field in this list
     // (except to itself). If the list only has one item, nothing needs to
     // be compared.
@@ -310,7 +315,7 @@ function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames
         }
       }
     }
-  });
+  }
 } // Collect all Conflicts between two collections of fields. This is similar to,
 // but different from the `collectConflictsWithin` function above. This check
 // assumes that `collectConflictsWithin` has already been called on each
@@ -324,7 +329,10 @@ function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentName
   // response name. For any response name which appears in both provided field
   // maps, each field from the first field map must be compared to every field
   // in the second field map to find potential conflicts.
-  Object.keys(fieldMap1).forEach(function (responseName) {
+  var _arr2 = Object.keys(fieldMap1);
+
+  for (var _i4 = 0; _i4 < _arr2.length; _i4++) {
+    var responseName = _arr2[_i4];
     var fields2 = fieldMap2[responseName];
 
     if (fields2) {
@@ -340,7 +348,7 @@ function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentName
         }
       }
     }
-  });
+  }
 } // Determines if there is a conflict between two particular fields, including
 // comparing their sub-fields.
 
@@ -519,14 +527,14 @@ function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeA
 
 function subfieldConflicts(conflicts, responseName, node1, node2) {
   if (conflicts.length > 0) {
-    return [[responseName, conflicts.map(function (_ref3) {
-      var reason = _ref3[0];
+    return [[responseName, conflicts.map(function (_ref4) {
+      var reason = _ref4[0];
       return reason;
-    })], conflicts.reduce(function (allFields, _ref4) {
-      var fields1 = _ref4[1];
+    })], conflicts.reduce(function (allFields, _ref5) {
+      var fields1 = _ref5[1];
       return allFields.concat(fields1);
-    }, [node1]), conflicts.reduce(function (allFields, _ref5) {
-      var fields2 = _ref5[2];
+    }, [node1]), conflicts.reduce(function (allFields, _ref6) {
+      var fields2 = _ref6[2];
       return allFields.concat(fields2);
     }, [node2])];
   }
diff --git a/validation/rules/OverlappingFieldsCanBeMerged.js.flow b/validation/rules/OverlappingFieldsCanBeMerged.js.flow
index e3b5ca3..aa54697 100644
--- a/validation/rules/OverlappingFieldsCanBeMerged.js.flow
+++ b/validation/rules/OverlappingFieldsCanBeMerged.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import inspect from '../../jsutils/inspect';
 import find from '../../jsutils/find';
@@ -91,14 +91,14 @@ export function OverlappingFieldsCanBeMerged(
         context.getParentType(),
         selectionSet,
       );
-      conflicts.forEach(([[responseName, reason], fields1, fields2]) =>
+      for (const [[responseName, reason], fields1, fields2] of conflicts) {
         context.reportError(
           new GraphQLError(
             fieldsConflictMessage(responseName, reason),
             fields1.concat(fields2),
           ),
-        ),
-      );
+        );
+      }
     },
   };
 }
@@ -486,7 +486,7 @@ function collectConflictsWithin(
   // name and the value at that key is a list of all fields which provide that
   // response name. For every response name, if there are multiple fields, they
   // must be compared to find a potential conflict.
-  Object.keys(fieldMap).forEach(responseName => {
+  for (const responseName of Object.keys(fieldMap)) {
     const fields = fieldMap[responseName];
     // This compares every field in the list to every other field in this list
     // (except to itself). If the list only has one item, nothing needs to
@@ -509,7 +509,7 @@ function collectConflictsWithin(
         }
       }
     }
-  });
+  }
 }
 
 // Collect all Conflicts between two collections of fields. This is similar to,
@@ -531,7 +531,7 @@ function collectConflictsBetween(
   // response name. For any response name which appears in both provided field
   // maps, each field from the first field map must be compared to every field
   // in the second field map to find potential conflicts.
-  Object.keys(fieldMap1).forEach(responseName => {
+  for (const responseName of Object.keys(fieldMap1)) {
     const fields2 = fieldMap2[responseName];
     if (fields2) {
       const fields1 = fieldMap1[responseName];
@@ -552,7 +552,7 @@ function collectConflictsBetween(
         }
       }
     }
-  });
+  }
 }
 
 // Determines if there is a conflict between two particular fields, including
diff --git a/validation/rules/OverlappingFieldsCanBeMerged.mjs b/validation/rules/OverlappingFieldsCanBeMerged.mjs
index f14759e..7e7c182 100644
--- a/validation/rules/OverlappingFieldsCanBeMerged.mjs
+++ b/validation/rules/OverlappingFieldsCanBeMerged.mjs
@@ -51,14 +51,16 @@ export function OverlappingFieldsCanBeMerged(context) {
   return {
     SelectionSet: function SelectionSet(selectionSet) {
       var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
-      conflicts.forEach(function (_ref2) {
-        var _ref2$ = _ref2[0],
-            responseName = _ref2$[0],
-            reason = _ref2$[1],
-            fields1 = _ref2[1],
-            fields2 = _ref2[2];
-        return context.reportError(new GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));
-      });
+
+      for (var _i = 0; _i < conflicts.length; _i++) {
+        var _ref3 = conflicts[_i];
+        var _ref2$ = _ref3[0];
+        var responseName = _ref2$[0];
+        var reason = _ref2$[1];
+        var fields1 = _ref3[1];
+        var fields2 = _ref3[2];
+        context.reportError(new GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));
+      }
     }
   };
 }
@@ -269,9 +271,9 @@ function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNa
   // names to each item in the second set of names.
 
 
-  for (var _i = 0; _i < fragmentNames1.length; _i++) {
+  for (var _i2 = 0; _i2 < fragmentNames1.length; _i2++) {
     for (var _j = 0; _j < fragmentNames2.length; _j++) {
-      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);
+      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i2], fragmentNames2[_j]);
     }
   }
 
@@ -284,7 +286,10 @@ function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames
   // name and the value at that key is a list of all fields which provide that
   // response name. For every response name, if there are multiple fields, they
   // must be compared to find a potential conflict.
-  Object.keys(fieldMap).forEach(function (responseName) {
+  var _arr = Object.keys(fieldMap);
+
+  for (var _i3 = 0; _i3 < _arr.length; _i3++) {
+    var responseName = _arr[_i3];
     var fields = fieldMap[responseName]; // This compares every field in the list to every other field in this list
     // (except to itself). If the list only has one item, nothing needs to
     // be compared.
@@ -301,7 +306,7 @@ function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames
         }
       }
     }
-  });
+  }
 } // Collect all Conflicts between two collections of fields. This is similar to,
 // but different from the `collectConflictsWithin` function above. This check
 // assumes that `collectConflictsWithin` has already been called on each
@@ -315,7 +320,10 @@ function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentName
   // response name. For any response name which appears in both provided field
   // maps, each field from the first field map must be compared to every field
   // in the second field map to find potential conflicts.
-  Object.keys(fieldMap1).forEach(function (responseName) {
+  var _arr2 = Object.keys(fieldMap1);
+
+  for (var _i4 = 0; _i4 < _arr2.length; _i4++) {
+    var responseName = _arr2[_i4];
     var fields2 = fieldMap2[responseName];
 
     if (fields2) {
@@ -331,7 +339,7 @@ function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentName
         }
       }
     }
-  });
+  }
 } // Determines if there is a conflict between two particular fields, including
 // comparing their sub-fields.
 
@@ -510,14 +518,14 @@ function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeA
 
 function subfieldConflicts(conflicts, responseName, node1, node2) {
   if (conflicts.length > 0) {
-    return [[responseName, conflicts.map(function (_ref3) {
-      var reason = _ref3[0];
+    return [[responseName, conflicts.map(function (_ref4) {
+      var reason = _ref4[0];
       return reason;
-    })], conflicts.reduce(function (allFields, _ref4) {
-      var fields1 = _ref4[1];
+    })], conflicts.reduce(function (allFields, _ref5) {
+      var fields1 = _ref5[1];
       return allFields.concat(fields1);
-    }, [node1]), conflicts.reduce(function (allFields, _ref5) {
-      var fields2 = _ref5[2];
+    }, [node1]), conflicts.reduce(function (allFields, _ref6) {
+      var fields2 = _ref6[2];
       return allFields.concat(fields2);
     }, [node2])];
   }
diff --git a/validation/rules/PossibleFragmentSpreads.js b/validation/rules/PossibleFragmentSpreads.js
index ac374ce..fb7667c 100644
--- a/validation/rules/PossibleFragmentSpreads.js
+++ b/validation/rules/PossibleFragmentSpreads.js
@@ -28,11 +28,11 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
  *  strict
  */
 function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {
-  return "Fragment \"".concat(fragName, "\" cannot be spread here as objects of ") + "type \"".concat((0, _inspect.default)(parentType), "\" can never be of type \"").concat((0, _inspect.default)(fragType), "\".");
+  return "Fragment \"".concat(fragName, "\" cannot be spread here as objects of ") + "type \"".concat(parentType, "\" can never be of type \"").concat(fragType, "\".");
 }
 
 function typeIncompatibleAnonSpreadMessage(parentType, fragType) {
-  return 'Fragment cannot be spread here as objects of ' + "type \"".concat((0, _inspect.default)(parentType), "\" can never be of type \"").concat((0, _inspect.default)(fragType), "\".");
+  return 'Fragment cannot be spread here as objects of ' + "type \"".concat(parentType, "\" can never be of type \"").concat(fragType, "\".");
 }
 /**
  * Possible fragment spread
@@ -50,7 +50,7 @@ function PossibleFragmentSpreads(context) {
       var parentType = context.getParentType();
 
       if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
-        context.reportError(new _error.GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));
+        context.reportError(new _error.GraphQLError(typeIncompatibleAnonSpreadMessage((0, _inspect.default)(parentType), (0, _inspect.default)(fragType)), [node]));
       }
     },
     FragmentSpread: function FragmentSpread(node) {
@@ -59,7 +59,7 @@ function PossibleFragmentSpreads(context) {
       var parentType = context.getParentType();
 
       if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
-        context.reportError(new _error.GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));
+        context.reportError(new _error.GraphQLError(typeIncompatibleSpreadMessage(fragName, (0, _inspect.default)(parentType), (0, _inspect.default)(fragType)), [node]));
       }
     }
   };
diff --git a/validation/rules/PossibleFragmentSpreads.js.flow b/validation/rules/PossibleFragmentSpreads.js.flow
index 95ee321..465efa1 100644
--- a/validation/rules/PossibleFragmentSpreads.js.flow
+++ b/validation/rules/PossibleFragmentSpreads.js.flow
@@ -8,32 +8,31 @@
  */
 
 import inspect from '../../jsutils/inspect';
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
 import { doTypesOverlap } from '../../utilities/typeComparators';
 import { typeFromAST } from '../../utilities/typeFromAST';
 import { isCompositeType } from '../../type/definition';
-import type { GraphQLType } from '../../type/definition';
 
 export function typeIncompatibleSpreadMessage(
   fragName: string,
-  parentType: GraphQLType,
-  fragType: GraphQLType,
+  parentType: string,
+  fragType: string,
 ): string {
   return (
     `Fragment "${fragName}" cannot be spread here as objects of ` +
-    `type "${inspect(parentType)}" can never be of type "${inspect(fragType)}".`
+    `type "${parentType}" can never be of type "${fragType}".`
   );
 }
 
 export function typeIncompatibleAnonSpreadMessage(
-  parentType: GraphQLType,
-  fragType: GraphQLType,
+  parentType: string,
+  fragType: string,
 ): string {
   return (
     'Fragment cannot be spread here as objects of ' +
-    `type "${inspect(parentType)}" can never be of type "${inspect(fragType)}".`
+    `type "${parentType}" can never be of type "${fragType}".`
   );
 }
 
@@ -58,7 +57,10 @@ export function PossibleFragmentSpreads(
       ) {
         context.reportError(
           new GraphQLError(
-            typeIncompatibleAnonSpreadMessage(parentType, fragType),
+            typeIncompatibleAnonSpreadMessage(
+              inspect(parentType),
+              inspect(fragType),
+            ),
             [node],
           ),
         );
@@ -75,7 +77,11 @@ export function PossibleFragmentSpreads(
       ) {
         context.reportError(
           new GraphQLError(
-            typeIncompatibleSpreadMessage(fragName, parentType, fragType),
+            typeIncompatibleSpreadMessage(
+              fragName,
+              inspect(parentType),
+              inspect(fragType),
+            ),
             [node],
           ),
         );
diff --git a/validation/rules/PossibleFragmentSpreads.mjs b/validation/rules/PossibleFragmentSpreads.mjs
index 1f6186e..dd33e7c 100644
--- a/validation/rules/PossibleFragmentSpreads.mjs
+++ b/validation/rules/PossibleFragmentSpreads.mjs
@@ -12,10 +12,10 @@ import { doTypesOverlap } from '../../utilities/typeComparators';
 import { typeFromAST } from '../../utilities/typeFromAST';
 import { isCompositeType } from '../../type/definition';
 export function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {
-  return "Fragment \"".concat(fragName, "\" cannot be spread here as objects of ") + "type \"".concat(inspect(parentType), "\" can never be of type \"").concat(inspect(fragType), "\".");
+  return "Fragment \"".concat(fragName, "\" cannot be spread here as objects of ") + "type \"".concat(parentType, "\" can never be of type \"").concat(fragType, "\".");
 }
 export function typeIncompatibleAnonSpreadMessage(parentType, fragType) {
-  return 'Fragment cannot be spread here as objects of ' + "type \"".concat(inspect(parentType), "\" can never be of type \"").concat(inspect(fragType), "\".");
+  return 'Fragment cannot be spread here as objects of ' + "type \"".concat(parentType, "\" can never be of type \"").concat(fragType, "\".");
 }
 /**
  * Possible fragment spread
@@ -32,7 +32,7 @@ export function PossibleFragmentSpreads(context) {
       var parentType = context.getParentType();
 
       if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
-        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(parentType, fragType), [node]));
+        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), [node]));
       }
     },
     FragmentSpread: function FragmentSpread(node) {
@@ -41,7 +41,7 @@ export function PossibleFragmentSpreads(context) {
       var parentType = context.getParentType();
 
       if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
-        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, parentType, fragType), [node]));
+        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), [node]));
       }
     }
   };
diff --git a/validation/rules/ProvidedRequiredArguments.js b/validation/rules/ProvidedRequiredArguments.js
index 010180d..ce3736d 100644
--- a/validation/rules/ProvidedRequiredArguments.js
+++ b/validation/rules/ProvidedRequiredArguments.js
@@ -26,11 +26,11 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
  *  strict
  */
 function missingFieldArgMessage(fieldName, argName, type) {
-  return "Field \"".concat(fieldName, "\" argument \"").concat(argName, "\" of type ") + "\"".concat((0, _inspect.default)(type), "\" is required but not provided.");
+  return "Field \"".concat(fieldName, "\" argument \"").concat(argName, "\" of type ") + "\"".concat(type, "\" is required but not provided.");
 }
 
 function missingDirectiveArgMessage(directiveName, argName, type) {
-  return "Directive \"@".concat(directiveName, "\" argument \"").concat(argName, "\" of type ") + "\"".concat((0, _inspect.default)(type), "\" is required but not provided.");
+  return "Directive \"@".concat(directiveName, "\" argument \"").concat(argName, "\" of type ") + "\"".concat(type, "\" is required but not provided.");
 }
 /**
  * Provided required arguments
@@ -55,13 +55,33 @@ function ProvidedRequiredArguments(context) {
         var argNodeMap = (0, _keyMap.default)(argNodes, function (arg) {
           return arg.name.value;
         });
-        fieldDef.args.forEach(function (argDef) {
-          var argNode = argNodeMap[argDef.name];
-
-          if (!argNode && (0, _definition.isNonNullType)(argDef.type) && argDef.defaultValue === undefined) {
-            context.reportError(new _error.GraphQLError(missingFieldArgMessage(node.name.value, argDef.name, argDef.type), [node]));
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
+
+        try {
+          for (var _iterator = fieldDef.args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var argDef = _step.value;
+            var argNode = argNodeMap[argDef.name];
+
+            if (!argNode && (0, _definition.isNonNullType)(argDef.type) && argDef.defaultValue === undefined) {
+              context.reportError(new _error.GraphQLError(missingFieldArgMessage(node.name.value, argDef.name, (0, _inspect.default)(argDef.type)), [node]));
+            }
           }
-        });
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
+            }
+          }
+        }
       }
     },
     Directive: {
@@ -77,13 +97,33 @@ function ProvidedRequiredArguments(context) {
         var argNodeMap = (0, _keyMap.default)(argNodes, function (arg) {
           return arg.name.value;
         });
-        directiveDef.args.forEach(function (argDef) {
-          var argNode = argNodeMap[argDef.name];
-
-          if (!argNode && (0, _definition.isNonNullType)(argDef.type) && argDef.defaultValue === undefined) {
-            context.reportError(new _error.GraphQLError(missingDirectiveArgMessage(node.name.value, argDef.name, argDef.type), [node]));
+        var _iteratorNormalCompletion2 = true;
+        var _didIteratorError2 = false;
+        var _iteratorError2 = undefined;
+
+        try {
+          for (var _iterator2 = directiveDef.args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+            var argDef = _step2.value;
+            var argNode = argNodeMap[argDef.name];
+
+            if (!argNode && (0, _definition.isNonNullType)(argDef.type) && argDef.defaultValue === undefined) {
+              context.reportError(new _error.GraphQLError(missingDirectiveArgMessage(node.name.value, argDef.name, (0, _inspect.default)(argDef.type)), [node]));
+            }
           }
-        });
+        } catch (err) {
+          _didIteratorError2 = true;
+          _iteratorError2 = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+              _iterator2.return();
+            }
+          } finally {
+            if (_didIteratorError2) {
+              throw _iteratorError2;
+            }
+          }
+        }
       }
     }
   };
diff --git a/validation/rules/ProvidedRequiredArguments.js.flow b/validation/rules/ProvidedRequiredArguments.js.flow
index b6b60a0..38a911b 100644
--- a/validation/rules/ProvidedRequiredArguments.js.flow
+++ b/validation/rules/ProvidedRequiredArguments.js.flow
@@ -7,33 +7,32 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import inspect from '../../jsutils/inspect';
 import keyMap from '../../jsutils/keyMap';
 import { isNonNullType } from '../../type/definition';
-import type { GraphQLType } from '../../type/definition';
 import type { ASTVisitor } from '../../language/visitor';
 
 export function missingFieldArgMessage(
   fieldName: string,
   argName: string,
-  type: GraphQLType,
+  type: string,
 ): string {
   return (
     `Field "${fieldName}" argument "${argName}" of type ` +
-    `"${inspect(type)}" is required but not provided.`
+    `"${type}" is required but not provided.`
   );
 }
 
 export function missingDirectiveArgMessage(
   directiveName: string,
   argName: string,
-  type: GraphQLType,
+  type: string,
 ): string {
   return (
     `Directive "@${directiveName}" argument "${argName}" of type ` +
-    `"${inspect(type)}" is required but not provided.`
+    `"${type}" is required but not provided.`
   );
 }
 
@@ -57,7 +56,7 @@ export function ProvidedRequiredArguments(
         const argNodes = node.arguments || [];
 
         const argNodeMap = keyMap(argNodes, arg => arg.name.value);
-        fieldDef.args.forEach(argDef => {
+        for (const argDef of fieldDef.args) {
           const argNode = argNodeMap[argDef.name];
           if (
             !argNode &&
@@ -69,13 +68,13 @@ export function ProvidedRequiredArguments(
                 missingFieldArgMessage(
                   node.name.value,
                   argDef.name,
-                  argDef.type,
+                  inspect(argDef.type),
                 ),
                 [node],
               ),
             );
           }
-        });
+        }
       },
     },
 
@@ -89,7 +88,7 @@ export function ProvidedRequiredArguments(
         const argNodes = node.arguments || [];
 
         const argNodeMap = keyMap(argNodes, arg => arg.name.value);
-        directiveDef.args.forEach(argDef => {
+        for (const argDef of directiveDef.args) {
           const argNode = argNodeMap[argDef.name];
           if (
             !argNode &&
@@ -101,13 +100,13 @@ export function ProvidedRequiredArguments(
                 missingDirectiveArgMessage(
                   node.name.value,
                   argDef.name,
-                  argDef.type,
+                  inspect(argDef.type),
                 ),
                 [node],
               ),
             );
           }
-        });
+        }
       },
     },
   };
diff --git a/validation/rules/ProvidedRequiredArguments.mjs b/validation/rules/ProvidedRequiredArguments.mjs
index 68fde9b..eeb262e 100644
--- a/validation/rules/ProvidedRequiredArguments.mjs
+++ b/validation/rules/ProvidedRequiredArguments.mjs
@@ -11,10 +11,10 @@ import inspect from '../../jsutils/inspect';
 import keyMap from '../../jsutils/keyMap';
 import { isNonNullType } from '../../type/definition';
 export function missingFieldArgMessage(fieldName, argName, type) {
-  return "Field \"".concat(fieldName, "\" argument \"").concat(argName, "\" of type ") + "\"".concat(inspect(type), "\" is required but not provided.");
+  return "Field \"".concat(fieldName, "\" argument \"").concat(argName, "\" of type ") + "\"".concat(type, "\" is required but not provided.");
 }
 export function missingDirectiveArgMessage(directiveName, argName, type) {
-  return "Directive \"@".concat(directiveName, "\" argument \"").concat(argName, "\" of type ") + "\"".concat(inspect(type), "\" is required but not provided.");
+  return "Directive \"@".concat(directiveName, "\" argument \"").concat(argName, "\" of type ") + "\"".concat(type, "\" is required but not provided.");
 }
 /**
  * Provided required arguments
@@ -38,13 +38,33 @@ export function ProvidedRequiredArguments(context) {
         var argNodeMap = keyMap(argNodes, function (arg) {
           return arg.name.value;
         });
-        fieldDef.args.forEach(function (argDef) {
-          var argNode = argNodeMap[argDef.name];
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
 
-          if (!argNode && isNonNullType(argDef.type) && argDef.defaultValue === undefined) {
-            context.reportError(new GraphQLError(missingFieldArgMessage(node.name.value, argDef.name, argDef.type), [node]));
+        try {
+          for (var _iterator = fieldDef.args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var argDef = _step.value;
+            var argNode = argNodeMap[argDef.name];
+
+            if (!argNode && isNonNullType(argDef.type) && argDef.defaultValue === undefined) {
+              context.reportError(new GraphQLError(missingFieldArgMessage(node.name.value, argDef.name, inspect(argDef.type)), [node]));
+            }
           }
-        });
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
+            }
+          }
+        }
       }
     },
     Directive: {
@@ -60,13 +80,33 @@ export function ProvidedRequiredArguments(context) {
         var argNodeMap = keyMap(argNodes, function (arg) {
           return arg.name.value;
         });
-        directiveDef.args.forEach(function (argDef) {
-          var argNode = argNodeMap[argDef.name];
+        var _iteratorNormalCompletion2 = true;
+        var _didIteratorError2 = false;
+        var _iteratorError2 = undefined;
 
-          if (!argNode && isNonNullType(argDef.type) && argDef.defaultValue === undefined) {
-            context.reportError(new GraphQLError(missingDirectiveArgMessage(node.name.value, argDef.name, argDef.type), [node]));
+        try {
+          for (var _iterator2 = directiveDef.args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+            var argDef = _step2.value;
+            var argNode = argNodeMap[argDef.name];
+
+            if (!argNode && isNonNullType(argDef.type) && argDef.defaultValue === undefined) {
+              context.reportError(new GraphQLError(missingDirectiveArgMessage(node.name.value, argDef.name, inspect(argDef.type)), [node]));
+            }
           }
-        });
+        } catch (err) {
+          _didIteratorError2 = true;
+          _iteratorError2 = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
+              _iterator2.return();
+            }
+          } finally {
+            if (_didIteratorError2) {
+              throw _iteratorError2;
+            }
+          }
+        }
       }
     }
   };
diff --git a/validation/rules/ScalarLeafs.js b/validation/rules/ScalarLeafs.js
index de64dbe..062d792 100644
--- a/validation/rules/ScalarLeafs.js
+++ b/validation/rules/ScalarLeafs.js
@@ -24,11 +24,11 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
  *  strict
  */
 function noSubselectionAllowedMessage(fieldName, type) {
-  return "Field \"".concat(fieldName, "\" must not have a selection since ") + "type \"".concat((0, _inspect.default)(type), "\" has no subfields.");
+  return "Field \"".concat(fieldName, "\" must not have a selection since ") + "type \"".concat(type, "\" has no subfields.");
 }
 
 function requiredSubselectionMessage(fieldName, type) {
-  return "Field \"".concat(fieldName, "\" of type \"").concat((0, _inspect.default)(type), "\" must have a ") + "selection of subfields. Did you mean \"".concat(fieldName, " { ... }\"?");
+  return "Field \"".concat(fieldName, "\" of type \"").concat(type, "\" must have a ") + "selection of subfields. Did you mean \"".concat(fieldName, " { ... }\"?");
 }
 /**
  * Scalar leafs
@@ -47,10 +47,10 @@ function ScalarLeafs(context) {
       if (type) {
         if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
           if (selectionSet) {
-            context.reportError(new _error.GraphQLError(noSubselectionAllowedMessage(node.name.value, type), [selectionSet]));
+            context.reportError(new _error.GraphQLError(noSubselectionAllowedMessage(node.name.value, (0, _inspect.default)(type)), [selectionSet]));
           }
         } else if (!selectionSet) {
-          context.reportError(new _error.GraphQLError(requiredSubselectionMessage(node.name.value, type), [node]));
+          context.reportError(new _error.GraphQLError(requiredSubselectionMessage(node.name.value, (0, _inspect.default)(type)), [node]));
         }
       }
     }
diff --git a/validation/rules/ScalarLeafs.js.flow b/validation/rules/ScalarLeafs.js.flow
index 85f8f38..28b82da 100644
--- a/validation/rules/ScalarLeafs.js.flow
+++ b/validation/rules/ScalarLeafs.js.flow
@@ -8,29 +8,28 @@
  */
 
 import inspect from '../../jsutils/inspect';
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { FieldNode } from '../../language/ast';
 import { getNamedType, isLeafType } from '../../type/definition';
-import type { GraphQLType } from '../../type/definition';
 import type { ASTVisitor } from '../../language/visitor';
 
 export function noSubselectionAllowedMessage(
   fieldName: string,
-  type: GraphQLType,
+  type: string,
 ): string {
   return (
     `Field "${fieldName}" must not have a selection since ` +
-    `type "${inspect(type)}" has no subfields.`
+    `type "${type}" has no subfields.`
   );
 }
 
 export function requiredSubselectionMessage(
   fieldName: string,
-  type: GraphQLType,
+  type: string,
 ): string {
   return (
-    `Field "${fieldName}" of type "${inspect(type)}" must have a ` +
+    `Field "${fieldName}" of type "${type}" must have a ` +
     `selection of subfields. Did you mean "${fieldName} { ... }"?`
   );
 }
@@ -51,7 +50,7 @@ export function ScalarLeafs(context: ValidationContext): ASTVisitor {
           if (selectionSet) {
             context.reportError(
               new GraphQLError(
-                noSubselectionAllowedMessage(node.name.value, type),
+                noSubselectionAllowedMessage(node.name.value, inspect(type)),
                 [selectionSet],
               ),
             );
@@ -59,7 +58,7 @@ export function ScalarLeafs(context: ValidationContext): ASTVisitor {
         } else if (!selectionSet) {
           context.reportError(
             new GraphQLError(
-              requiredSubselectionMessage(node.name.value, type),
+              requiredSubselectionMessage(node.name.value, inspect(type)),
               [node],
             ),
           );
diff --git a/validation/rules/ScalarLeafs.mjs b/validation/rules/ScalarLeafs.mjs
index 013d97b..7ceae12 100644
--- a/validation/rules/ScalarLeafs.mjs
+++ b/validation/rules/ScalarLeafs.mjs
@@ -10,10 +10,10 @@ import inspect from '../../jsutils/inspect';
 import { GraphQLError } from '../../error';
 import { getNamedType, isLeafType } from '../../type/definition';
 export function noSubselectionAllowedMessage(fieldName, type) {
-  return "Field \"".concat(fieldName, "\" must not have a selection since ") + "type \"".concat(inspect(type), "\" has no subfields.");
+  return "Field \"".concat(fieldName, "\" must not have a selection since ") + "type \"".concat(type, "\" has no subfields.");
 }
 export function requiredSubselectionMessage(fieldName, type) {
-  return "Field \"".concat(fieldName, "\" of type \"").concat(inspect(type), "\" must have a ") + "selection of subfields. Did you mean \"".concat(fieldName, " { ... }\"?");
+  return "Field \"".concat(fieldName, "\" of type \"").concat(type, "\" must have a ") + "selection of subfields. Did you mean \"".concat(fieldName, " { ... }\"?");
 }
 /**
  * Scalar leafs
@@ -31,10 +31,10 @@ export function ScalarLeafs(context) {
       if (type) {
         if (isLeafType(getNamedType(type))) {
           if (selectionSet) {
-            context.reportError(new GraphQLError(noSubselectionAllowedMessage(node.name.value, type), [selectionSet]));
+            context.reportError(new GraphQLError(noSubselectionAllowedMessage(node.name.value, inspect(type)), [selectionSet]));
           }
         } else if (!selectionSet) {
-          context.reportError(new GraphQLError(requiredSubselectionMessage(node.name.value, type), [node]));
+          context.reportError(new GraphQLError(requiredSubselectionMessage(node.name.value, inspect(type)), [node]));
         }
       }
     }
diff --git a/validation/rules/SingleFieldSubscriptions.js.flow b/validation/rules/SingleFieldSubscriptions.js.flow
index 622e6fc..9002956 100644
--- a/validation/rules/SingleFieldSubscriptions.js.flow
+++ b/validation/rules/SingleFieldSubscriptions.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ASTValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { OperationDefinitionNode } from '../../language/ast';
 import type { ASTVisitor } from '../../language/visitor';
@@ -25,7 +25,7 @@ export function singleFieldOnlyMessage(name: ?string): string {
  * A GraphQL subscription is valid only if it contains a single root field.
  */
 export function SingleFieldSubscriptions(
-  context: ValidationContext,
+  context: ASTValidationContext,
 ): ASTVisitor {
   return {
     OperationDefinition(node: OperationDefinitionNode) {
diff --git a/validation/rules/UniqueArgumentNames.js.flow b/validation/rules/UniqueArgumentNames.js.flow
index 0516401..474072b 100644
--- a/validation/rules/UniqueArgumentNames.js.flow
+++ b/validation/rules/UniqueArgumentNames.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ASTValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
 
@@ -21,7 +21,7 @@ export function duplicateArgMessage(argName: string): string {
  * A GraphQL field or directive is only valid if all supplied arguments are
  * uniquely named.
  */
-export function UniqueArgumentNames(context: ValidationContext): ASTVisitor {
+export function UniqueArgumentNames(context: ASTValidationContext): ASTVisitor {
   let knownArgNames = Object.create(null);
   return {
     Field() {
diff --git a/validation/rules/UniqueDirectivesPerLocation.js b/validation/rules/UniqueDirectivesPerLocation.js
index 8647b4a..1158d45 100644
--- a/validation/rules/UniqueDirectivesPerLocation.js
+++ b/validation/rules/UniqueDirectivesPerLocation.js
@@ -38,15 +38,35 @@ function UniqueDirectivesPerLocation(context) {
 
       if (directives) {
         var knownDirectives = Object.create(null);
-        directives.forEach(function (directive) {
-          var directiveName = directive.name.value;
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
 
-          if (knownDirectives[directiveName]) {
-            context.reportError(new _error.GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], directive]));
-          } else {
-            knownDirectives[directiveName] = directive;
+        try {
+          for (var _iterator = directives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var directive = _step.value;
+            var directiveName = directive.name.value;
+
+            if (knownDirectives[directiveName]) {
+              context.reportError(new _error.GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], directive]));
+            } else {
+              knownDirectives[directiveName] = directive;
+            }
+          }
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
+            }
           }
-        });
+        }
       }
     }
   };
diff --git a/validation/rules/UniqueDirectivesPerLocation.js.flow b/validation/rules/UniqueDirectivesPerLocation.js.flow
index fb143d2..393ca0c 100644
--- a/validation/rules/UniqueDirectivesPerLocation.js.flow
+++ b/validation/rules/UniqueDirectivesPerLocation.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ASTValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { DirectiveNode } from '../../language/ast';
 import type { ASTVisitor } from '../../language/visitor';
@@ -26,7 +26,7 @@ export function duplicateDirectiveMessage(directiveName: string): string {
  * are uniquely named.
  */
 export function UniqueDirectivesPerLocation(
-  context: ValidationContext,
+  context: ASTValidationContext,
 ): ASTVisitor {
   return {
     // Many different AST nodes may contain directives. Rather than listing
@@ -38,7 +38,7 @@ export function UniqueDirectivesPerLocation(
       const directives: ?$ReadOnlyArray<DirectiveNode> = (node: any).directives;
       if (directives) {
         const knownDirectives = Object.create(null);
-        directives.forEach(directive => {
+        for (const directive of directives) {
           const directiveName = directive.name.value;
           if (knownDirectives[directiveName]) {
             context.reportError(
@@ -50,7 +50,7 @@ export function UniqueDirectivesPerLocation(
           } else {
             knownDirectives[directiveName] = directive;
           }
-        });
+        }
       }
     },
   };
diff --git a/validation/rules/UniqueDirectivesPerLocation.mjs b/validation/rules/UniqueDirectivesPerLocation.mjs
index 0f451d3..f2f854c 100644
--- a/validation/rules/UniqueDirectivesPerLocation.mjs
+++ b/validation/rules/UniqueDirectivesPerLocation.mjs
@@ -28,15 +28,35 @@ export function UniqueDirectivesPerLocation(context) {
 
       if (directives) {
         var knownDirectives = Object.create(null);
-        directives.forEach(function (directive) {
-          var directiveName = directive.name.value;
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
 
-          if (knownDirectives[directiveName]) {
-            context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], directive]));
-          } else {
-            knownDirectives[directiveName] = directive;
+        try {
+          for (var _iterator = directives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var directive = _step.value;
+            var directiveName = directive.name.value;
+
+            if (knownDirectives[directiveName]) {
+              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], directive]));
+            } else {
+              knownDirectives[directiveName] = directive;
+            }
+          }
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
+            }
           }
-        });
+        }
       }
     }
   };
diff --git a/validation/rules/UniqueFragmentNames.js.flow b/validation/rules/UniqueFragmentNames.js.flow
index 1a55cd7..9bedb9e 100644
--- a/validation/rules/UniqueFragmentNames.js.flow
+++ b/validation/rules/UniqueFragmentNames.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ASTValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
 
@@ -20,7 +20,7 @@ export function duplicateFragmentNameMessage(fragName: string): string {
  *
  * A GraphQL document is only valid if all defined fragments have unique names.
  */
-export function UniqueFragmentNames(context: ValidationContext): ASTVisitor {
+export function UniqueFragmentNames(context: ASTValidationContext): ASTVisitor {
   const knownFragmentNames = Object.create(null);
   return {
     OperationDefinition: () => false,
diff --git a/validation/rules/UniqueInputFieldNames.js.flow b/validation/rules/UniqueInputFieldNames.js.flow
index 9290b60..38ecec0 100644
--- a/validation/rules/UniqueInputFieldNames.js.flow
+++ b/validation/rules/UniqueInputFieldNames.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ASTValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
 
@@ -21,7 +21,9 @@ export function duplicateInputFieldMessage(fieldName: string): string {
  * A GraphQL input object value is only valid if all supplied fields are
  * uniquely named.
  */
-export function UniqueInputFieldNames(context: ValidationContext): ASTVisitor {
+export function UniqueInputFieldNames(
+  context: ASTValidationContext,
+): ASTVisitor {
   const knownNameStack = [];
   let knownNames = Object.create(null);
 
diff --git a/validation/rules/UniqueOperationNames.js.flow b/validation/rules/UniqueOperationNames.js.flow
index 765b0b8..96ba243 100644
--- a/validation/rules/UniqueOperationNames.js.flow
+++ b/validation/rules/UniqueOperationNames.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ASTValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
 
@@ -20,7 +20,9 @@ export function duplicateOperationNameMessage(operationName: string): string {
  *
  * A GraphQL document is only valid if all defined operations have unique names.
  */
-export function UniqueOperationNames(context: ValidationContext): ASTVisitor {
+export function UniqueOperationNames(
+  context: ASTValidationContext,
+): ASTVisitor {
   const knownOperationNames = Object.create(null);
   return {
     OperationDefinition(node) {
diff --git a/validation/rules/UniqueVariableNames.js.flow b/validation/rules/UniqueVariableNames.js.flow
index 90f8448..5b71c00 100644
--- a/validation/rules/UniqueVariableNames.js.flow
+++ b/validation/rules/UniqueVariableNames.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ASTValidationContext } from '../ValidationContext';
 import type { VariableDefinitionNode } from '../../language/ast';
 import { GraphQLError } from '../../error';
 import type { ASTVisitor } from '../../language/visitor';
@@ -21,7 +21,7 @@ export function duplicateVariableMessage(variableName: string): string {
  *
  * A GraphQL operation is only valid if all its variables are uniquely named.
  */
-export function UniqueVariableNames(context: ValidationContext): ASTVisitor {
+export function UniqueVariableNames(context: ASTValidationContext): ASTVisitor {
   let knownVariableNames = Object.create(null);
   return {
     OperationDefinition() {
diff --git a/validation/rules/ValuesOfCorrectType.js b/validation/rules/ValuesOfCorrectType.js
index 8bdbe65..80ee3f0 100644
--- a/validation/rules/ValuesOfCorrectType.js
+++ b/validation/rules/ValuesOfCorrectType.js
@@ -85,7 +85,11 @@ function ValuesOfCorrectType(context) {
       var fieldNodeMap = (0, _keyMap.default)(node.fields, function (field) {
         return field.name.value;
       });
-      Object.keys(inputFields).forEach(function (fieldName) {
+
+      var _arr = Object.keys(inputFields);
+
+      for (var _i = 0; _i < _arr.length; _i++) {
+        var fieldName = _arr[_i];
         var fieldDef = inputFields[fieldName];
         var fieldType = fieldDef.type;
         var fieldNode = fieldNodeMap[fieldName];
@@ -93,7 +97,7 @@ function ValuesOfCorrectType(context) {
         if (!fieldNode && (0, _definition.isNonNullType)(fieldType) && fieldDef.defaultValue === undefined) {
           context.reportError(new _error.GraphQLError(requiredFieldMessage(type.name, fieldName, (0, _inspect.default)(fieldType)), node));
         }
-      });
+      }
     },
     ObjectField: function ObjectField(node) {
       var parentType = (0, _definition.getNamedType)(context.getParentInputType());
diff --git a/validation/rules/ValuesOfCorrectType.js.flow b/validation/rules/ValuesOfCorrectType.js.flow
index 4b51563..5c2d3b5 100644
--- a/validation/rules/ValuesOfCorrectType.js.flow
+++ b/validation/rules/ValuesOfCorrectType.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { ValueNode } from '../../language/ast';
 import { print } from '../../language/printer';
@@ -95,7 +95,7 @@ export function ValuesOfCorrectType(context: ValidationContext): ASTVisitor {
       // Ensure every required field exists.
       const inputFields = type.getFields();
       const fieldNodeMap = keyMap(node.fields, field => field.name.value);
-      Object.keys(inputFields).forEach(fieldName => {
+      for (const fieldName of Object.keys(inputFields)) {
         const fieldDef = inputFields[fieldName];
         const fieldType = fieldDef.type;
         const fieldNode = fieldNodeMap[fieldName];
@@ -111,7 +111,7 @@ export function ValuesOfCorrectType(context: ValidationContext): ASTVisitor {
             ),
           );
         }
-      });
+      }
     },
     ObjectField(node) {
       const parentType = getNamedType(context.getParentInputType());
diff --git a/validation/rules/ValuesOfCorrectType.mjs b/validation/rules/ValuesOfCorrectType.mjs
index 3e5c02a..0623c07 100644
--- a/validation/rules/ValuesOfCorrectType.mjs
+++ b/validation/rules/ValuesOfCorrectType.mjs
@@ -62,7 +62,11 @@ export function ValuesOfCorrectType(context) {
       var fieldNodeMap = keyMap(node.fields, function (field) {
         return field.name.value;
       });
-      Object.keys(inputFields).forEach(function (fieldName) {
+
+      var _arr = Object.keys(inputFields);
+
+      for (var _i = 0; _i < _arr.length; _i++) {
+        var fieldName = _arr[_i];
         var fieldDef = inputFields[fieldName];
         var fieldType = fieldDef.type;
         var fieldNode = fieldNodeMap[fieldName];
@@ -70,7 +74,7 @@ export function ValuesOfCorrectType(context) {
         if (!fieldNode && isNonNullType(fieldType) && fieldDef.defaultValue === undefined) {
           context.reportError(new GraphQLError(requiredFieldMessage(type.name, fieldName, inspect(fieldType)), node));
         }
-      });
+      }
     },
     ObjectField: function ObjectField(node) {
       var parentType = getNamedType(context.getParentInputType());
diff --git a/validation/rules/VariablesAreInputTypes.js.flow b/validation/rules/VariablesAreInputTypes.js.flow
index b152025..7076bd8 100644
--- a/validation/rules/VariablesAreInputTypes.js.flow
+++ b/validation/rules/VariablesAreInputTypes.js.flow
@@ -7,7 +7,7 @@
  * @flow strict
  */
 
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import type { VariableDefinitionNode } from '../../language/ast';
 import { print } from '../../language/printer';
diff --git a/validation/rules/VariablesInAllowedPosition.js b/validation/rules/VariablesInAllowedPosition.js
index 54faec7..204dc5c 100644
--- a/validation/rules/VariablesInAllowedPosition.js
+++ b/validation/rules/VariablesInAllowedPosition.js
@@ -29,7 +29,7 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
  *  strict
  */
 function badVarPosMessage(varName, varType, expectedType) {
-  return "Variable \"$".concat(varName, "\" of type \"").concat((0, _inspect.default)(varType), "\" used in ") + "position expecting type \"".concat((0, _inspect.default)(expectedType), "\".");
+  return "Variable \"$".concat(varName, "\" of type \"").concat(varType, "\" used in ") + "position expecting type \"".concat(expectedType, "\".");
 }
 /**
  * Variables passed to field arguments conform to type
@@ -45,27 +45,47 @@ function VariablesInAllowedPosition(context) {
       },
       leave: function leave(operation) {
         var usages = context.getRecursiveVariableUsages(operation);
-        usages.forEach(function (_ref) {
-          var node = _ref.node,
-              type = _ref.type,
-              defaultValue = _ref.defaultValue;
-          var varName = node.name.value;
-          var varDef = varDefMap[varName];
-
-          if (varDef && type) {
-            // A var type is allowed if it is the same or more strict (e.g. is
-            // a subtype of) than the expected type. It can be more strict if
-            // the variable type is non-null when the expected type is nullable.
-            // If both are list types, the variable item type can be more strict
-            // than the expected item type (contravariant).
-            var schema = context.getSchema();
-            var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
-
-            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
-              context.reportError(new _error.GraphQLError(badVarPosMessage(varName, varType, type), [varDef, node]));
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
+
+        try {
+          for (var _iterator = usages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var _ref2 = _step.value;
+            var node = _ref2.node,
+                type = _ref2.type,
+                defaultValue = _ref2.defaultValue;
+            var varName = node.name.value;
+            var varDef = varDefMap[varName];
+
+            if (varDef && type) {
+              // A var type is allowed if it is the same or more strict (e.g. is
+              // a subtype of) than the expected type. It can be more strict if
+              // the variable type is non-null when the expected type is nullable.
+              // If both are list types, the variable item type can be more strict
+              // than the expected item type (contravariant).
+              var schema = context.getSchema();
+              var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
+
+              if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
+                context.reportError(new _error.GraphQLError(badVarPosMessage(varName, (0, _inspect.default)(varType), (0, _inspect.default)(type)), [varDef, node]));
+              }
             }
           }
-        });
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
+            }
+          }
+        }
       }
     },
     VariableDefinition: function VariableDefinition(node) {
diff --git a/validation/rules/VariablesInAllowedPosition.js.flow b/validation/rules/VariablesInAllowedPosition.js.flow
index 21c04d5..2d80c37 100644
--- a/validation/rules/VariablesInAllowedPosition.js.flow
+++ b/validation/rules/VariablesInAllowedPosition.js.flow
@@ -8,7 +8,7 @@
  */
 
 import inspect from '../../jsutils/inspect';
-import type ValidationContext from '../ValidationContext';
+import type { ValidationContext } from '../ValidationContext';
 import { GraphQLError } from '../../error';
 import { Kind } from '../../language/kinds';
 import type { ValueNode } from '../../language/ast';
@@ -21,12 +21,12 @@ import type { GraphQLSchema } from '../../type/schema';
 
 export function badVarPosMessage(
   varName: string,
-  varType: GraphQLType,
-  expectedType: GraphQLType,
+  varType: string,
+  expectedType: string,
 ): string {
   return (
-    `Variable "$${varName}" of type "${inspect(varType)}" used in ` +
-    `position expecting type "${inspect(expectedType)}".`
+    `Variable "$${varName}" of type "${varType}" used in ` +
+    `position expecting type "${expectedType}".`
   );
 }
 
@@ -46,7 +46,7 @@ export function VariablesInAllowedPosition(
       leave(operation) {
         const usages = context.getRecursiveVariableUsages(operation);
 
-        usages.forEach(({ node, type, defaultValue }) => {
+        for (const { node, type, defaultValue } of usages) {
           const varName = node.name.value;
           const varDef = varDefMap[varName];
           if (varDef && type) {
@@ -68,14 +68,14 @@ export function VariablesInAllowedPosition(
               )
             ) {
               context.reportError(
-                new GraphQLError(badVarPosMessage(varName, varType, type), [
-                  varDef,
-                  node,
-                ]),
+                new GraphQLError(
+                  badVarPosMessage(varName, inspect(varType), inspect(type)),
+                  [varDef, node],
+                ),
               );
             }
           }
-        });
+        }
       },
     },
     VariableDefinition(node) {
diff --git a/validation/rules/VariablesInAllowedPosition.mjs b/validation/rules/VariablesInAllowedPosition.mjs
index f54b6fa..7cb31c7 100644
--- a/validation/rules/VariablesInAllowedPosition.mjs
+++ b/validation/rules/VariablesInAllowedPosition.mjs
@@ -13,7 +13,7 @@ import { isNonNullType } from '../../type/definition';
 import { isTypeSubTypeOf } from '../../utilities/typeComparators';
 import { typeFromAST } from '../../utilities/typeFromAST';
 export function badVarPosMessage(varName, varType, expectedType) {
-  return "Variable \"$".concat(varName, "\" of type \"").concat(inspect(varType), "\" used in ") + "position expecting type \"".concat(inspect(expectedType), "\".");
+  return "Variable \"$".concat(varName, "\" of type \"").concat(varType, "\" used in ") + "position expecting type \"".concat(expectedType, "\".");
 }
 /**
  * Variables passed to field arguments conform to type
@@ -28,27 +28,47 @@ export function VariablesInAllowedPosition(context) {
       },
       leave: function leave(operation) {
         var usages = context.getRecursiveVariableUsages(operation);
-        usages.forEach(function (_ref) {
-          var node = _ref.node,
-              type = _ref.type,
-              defaultValue = _ref.defaultValue;
-          var varName = node.name.value;
-          var varDef = varDefMap[varName];
+        var _iteratorNormalCompletion = true;
+        var _didIteratorError = false;
+        var _iteratorError = undefined;
 
-          if (varDef && type) {
-            // A var type is allowed if it is the same or more strict (e.g. is
-            // a subtype of) than the expected type. It can be more strict if
-            // the variable type is non-null when the expected type is nullable.
-            // If both are list types, the variable item type can be more strict
-            // than the expected item type (contravariant).
-            var schema = context.getSchema();
-            var varType = typeFromAST(schema, varDef.type);
+        try {
+          for (var _iterator = usages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+            var _ref2 = _step.value;
+            var node = _ref2.node,
+                type = _ref2.type,
+                defaultValue = _ref2.defaultValue;
+            var varName = node.name.value;
+            var varDef = varDefMap[varName];
 
-            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
-              context.reportError(new GraphQLError(badVarPosMessage(varName, varType, type), [varDef, node]));
+            if (varDef && type) {
+              // A var type is allowed if it is the same or more strict (e.g. is
+              // a subtype of) than the expected type. It can be more strict if
+              // the variable type is non-null when the expected type is nullable.
+              // If both are list types, the variable item type can be more strict
+              // than the expected item type (contravariant).
+              var schema = context.getSchema();
+              var varType = typeFromAST(schema, varDef.type);
+
+              if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
+                context.reportError(new GraphQLError(badVarPosMessage(varName, inspect(varType), inspect(type)), [varDef, node]));
+              }
+            }
+          }
+        } catch (err) {
+          _didIteratorError = true;
+          _iteratorError = err;
+        } finally {
+          try {
+            if (!_iteratorNormalCompletion && _iterator.return != null) {
+              _iterator.return();
+            }
+          } finally {
+            if (_didIteratorError) {
+              throw _iteratorError;
             }
           }
-        });
+        }
       }
     },
     VariableDefinition: function VariableDefinition(node) {
diff --git a/validation/specifiedRules.js b/validation/specifiedRules.js
index df31734..ad3a04e 100644
--- a/validation/specifiedRules.js
+++ b/validation/specifiedRules.js
@@ -3,7 +3,7 @@
 Object.defineProperty(exports, "__esModule", {
   value: true
 });
-exports.specifiedRules = void 0;
+exports.specifiedSDLRules = exports.specifiedRules = void 0;
 
 var _ExecutableDefinitions = require("./rules/ExecutableDefinitions");
 
@@ -57,6 +57,8 @@ var _OverlappingFieldsCanBeMerged = require("./rules/OverlappingFieldsCanBeMerge
 
 var _UniqueInputFieldNames = require("./rules/UniqueInputFieldNames");
 
+var _LoneSchemaDefinition = require("./rules/LoneSchemaDefinition");
+
 /**
  * Copyright (c) 2015-present, Facebook, Inc.
  *
@@ -99,4 +101,7 @@ var _UniqueInputFieldNames = require("./rules/UniqueInputFieldNames");
  * most clear output when encountering multiple validation errors.
  */
 var specifiedRules = [_ExecutableDefinitions.ExecutableDefinitions, _UniqueOperationNames.UniqueOperationNames, _LoneAnonymousOperation.LoneAnonymousOperation, _SingleFieldSubscriptions.SingleFieldSubscriptions, _KnownTypeNames.KnownTypeNames, _FragmentsOnCompositeTypes.FragmentsOnCompositeTypes, _VariablesAreInputTypes.VariablesAreInputTypes, _ScalarLeafs.ScalarLeafs, _FieldsOnCorrectType.FieldsOnCorrectType, _UniqueFragmentNames.UniqueFragmentNames, _KnownFragmentNames.KnownFragmentNames, _NoUnusedFragments.NoUnusedFragments, _PossibleFragmentSpreads.PossibleFragmentSpreads, _NoFragmentCycles.NoFragmentCycles, _UniqueVariableNames.UniqueVariableNames, _NoUndefinedVariables.NoUndefinedVariables, _NoUnusedVariables.NoUnusedVariables, _KnownDirectives.KnownDirectives, _UniqueDirectivesPerLocation.UniqueDirectivesPerLocation, _KnownArgumentNames.KnownArgumentNames, _UniqueArgumentNames.UniqueArgumentNames, _ValuesOfCorrectType.ValuesOfCorrectType, _ProvidedRequiredArguments.ProvidedRequiredArguments, _VariablesInAllowedPosition.VariablesInAllowedPosition, _OverlappingFieldsCanBeMerged.OverlappingFieldsCanBeMerged, _UniqueInputFieldNames.UniqueInputFieldNames];
-exports.specifiedRules = specifiedRules;
\ No newline at end of file
+exports.specifiedRules = specifiedRules;
+// @internal
+var specifiedSDLRules = [_LoneSchemaDefinition.LoneSchemaDefinition, _KnownDirectives.KnownDirectives, _UniqueDirectivesPerLocation.UniqueDirectivesPerLocation, _UniqueArgumentNames.UniqueArgumentNames, _UniqueInputFieldNames.UniqueInputFieldNames];
+exports.specifiedSDLRules = specifiedSDLRules;
\ No newline at end of file
diff --git a/validation/specifiedRules.js.flow b/validation/specifiedRules.js.flow
index 77792d6..4bf2b31 100644
--- a/validation/specifiedRules.js.flow
+++ b/validation/specifiedRules.js.flow
@@ -7,6 +7,8 @@
  * @flow strict
  */
 
+import type { ValidationRule, SDLValidationRule } from './ValidationContext';
+
 // Spec Section: "Executable Definitions"
 import { ExecutableDefinitions } from './rules/ExecutableDefinitions';
 
@@ -85,15 +87,13 @@ import { OverlappingFieldsCanBeMerged } from './rules/OverlappingFieldsCanBeMerg
 // Spec Section: "Input Object Field Uniqueness"
 import { UniqueInputFieldNames } from './rules/UniqueInputFieldNames';
 
-import type ValidationContext from './ValidationContext';
-
 /**
  * This set includes all validation rules defined by the GraphQL spec.
  *
  * The order of the rules in this list has been adjusted to lead to the
  * most clear output when encountering multiple validation errors.
  */
-export const specifiedRules: Array<(context: ValidationContext) => any> = [
+export const specifiedRules: $ReadOnlyArray<ValidationRule> = [
   ExecutableDefinitions,
   UniqueOperationNames,
   LoneAnonymousOperation,
@@ -121,3 +121,14 @@ export const specifiedRules: Array<(context: ValidationContext) => any> = [
   OverlappingFieldsCanBeMerged,
   UniqueInputFieldNames,
 ];
+
+import { LoneSchemaDefinition } from './rules/LoneSchemaDefinition';
+
+// @internal
+export const specifiedSDLRules: $ReadOnlyArray<SDLValidationRule> = [
+  LoneSchemaDefinition,
+  KnownDirectives,
+  UniqueDirectivesPerLocation,
+  UniqueArgumentNames,
+  UniqueInputFieldNames,
+];
diff --git a/validation/specifiedRules.mjs b/validation/specifiedRules.mjs
index 97eacda..085bcfa 100644
--- a/validation/specifiedRules.mjs
+++ b/validation/specifiedRules.mjs
@@ -58,11 +58,14 @@ import { VariablesInAllowedPosition } from './rules/VariablesInAllowedPosition';
 import { OverlappingFieldsCanBeMerged } from './rules/OverlappingFieldsCanBeMerged'; // Spec Section: "Input Object Field Uniqueness"
 
 import { UniqueInputFieldNames } from './rules/UniqueInputFieldNames';
-
 /**
  * This set includes all validation rules defined by the GraphQL spec.
  *
  * The order of the rules in this list has been adjusted to lead to the
  * most clear output when encountering multiple validation errors.
  */
-export var specifiedRules = [ExecutableDefinitions, UniqueOperationNames, LoneAnonymousOperation, SingleFieldSubscriptions, KnownTypeNames, FragmentsOnCompositeTypes, VariablesAreInputTypes, ScalarLeafs, FieldsOnCorrectType, UniqueFragmentNames, KnownFragmentNames, NoUnusedFragments, PossibleFragmentSpreads, NoFragmentCycles, UniqueVariableNames, NoUndefinedVariables, NoUnusedVariables, KnownDirectives, UniqueDirectivesPerLocation, KnownArgumentNames, UniqueArgumentNames, ValuesOfCorrectType, ProvidedRequiredArguments, VariablesInAllowedPosition, OverlappingFieldsCanBeMerged, UniqueInputFieldNames];
\ No newline at end of file
+
+export var specifiedRules = [ExecutableDefinitions, UniqueOperationNames, LoneAnonymousOperation, SingleFieldSubscriptions, KnownTypeNames, FragmentsOnCompositeTypes, VariablesAreInputTypes, ScalarLeafs, FieldsOnCorrectType, UniqueFragmentNames, KnownFragmentNames, NoUnusedFragments, PossibleFragmentSpreads, NoFragmentCycles, UniqueVariableNames, NoUndefinedVariables, NoUnusedVariables, KnownDirectives, UniqueDirectivesPerLocation, KnownArgumentNames, UniqueArgumentNames, ValuesOfCorrectType, ProvidedRequiredArguments, VariablesInAllowedPosition, OverlappingFieldsCanBeMerged, UniqueInputFieldNames];
+import { LoneSchemaDefinition } from './rules/LoneSchemaDefinition'; // @internal
+
+export var specifiedSDLRules = [LoneSchemaDefinition, KnownDirectives, UniqueDirectivesPerLocation, UniqueArgumentNames, UniqueInputFieldNames];
\ No newline at end of file
diff --git a/validation/validate.js b/validation/validate.js
index 45c65a8..f9a4ab5 100644
--- a/validation/validate.js
+++ b/validation/validate.js
@@ -4,22 +4,21 @@ Object.defineProperty(exports, "__esModule", {
   value: true
 });
 exports.validate = validate;
+exports.validateSDL = validateSDL;
+exports.assertValidSDL = assertValidSDL;
+exports.assertValidSDLExtension = assertValidSDLExtension;
 
 var _invariant = _interopRequireDefault(require("../jsutils/invariant"));
 
-var _error = require("../error");
-
 var _visitor = require("../language/visitor");
 
-var _schema = require("../type/schema");
-
 var _validate = require("../type/validate");
 
 var _TypeInfo = require("../utilities/TypeInfo");
 
 var _specifiedRules = require("./specifiedRules");
 
-var _ValidationContext = _interopRequireDefault(require("./ValidationContext"));
+var _ValidationContext = require("./ValidationContext");
 
 function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
 
@@ -48,26 +47,64 @@ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { de
  * Optionally a custom TypeInfo instance may be provided. If not provided, one
  * will be created from the provided schema.
  */
-function validate(schema, ast, rules, typeInfo) {
-  !ast ? (0, _invariant.default)(0, 'Must provide document') : void 0; // If the schema used for validation is invalid, throw an error.
+function validate(schema, documentAST) {
+  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules.specifiedRules;
+  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _TypeInfo.TypeInfo(schema);
+  !documentAST ? (0, _invariant.default)(0, 'Must provide document') : void 0; // If the schema used for validation is invalid, throw an error.
 
   (0, _validate.assertValidSchema)(schema);
-  return visitUsingRules(schema, typeInfo || new _TypeInfo.TypeInfo(schema), ast, rules || _specifiedRules.specifiedRules);
+  var context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo); // This uses a specialized visitor which runs multiple visitors in parallel,
+  // while maintaining the visitor skip and break API.
+
+  var visitor = (0, _visitor.visitInParallel)(rules.map(function (rule) {
+    return rule(context);
+  })); // Visit the whole document with each instance of all provided rules.
+
+  (0, _visitor.visit)(documentAST, (0, _visitor.visitWithTypeInfo)(typeInfo, visitor));
+  return context.getErrors();
+} // @internal
+
+
+function validateSDL(documentAST, schemaToExtend) {
+  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules.specifiedSDLRules;
+  var context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend);
+  var visitors = rules.map(function (rule) {
+    return rule(context);
+  });
+  (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
+  return context.getErrors();
 }
 /**
- * This uses a specialized visitor which runs multiple visitors in parallel,
- * while maintaining the visitor skip and break API.
+ * Utility function which asserts a SDL document is valid by throwing an error
+ * if it is invalid.
  *
  * @internal
  */
 
 
-function visitUsingRules(schema, typeInfo, documentAST, rules) {
-  var context = new _ValidationContext.default(schema, documentAST, typeInfo);
-  var visitors = rules.map(function (rule) {
-    return rule(context);
-  }); // Visit the whole document with each instance of all provided rules.
+function assertValidSDL(documentAST) {
+  var errors = validateSDL(documentAST);
 
-  (0, _visitor.visit)(documentAST, (0, _visitor.visitWithTypeInfo)(typeInfo, (0, _visitor.visitInParallel)(visitors)));
-  return context.getErrors();
+  if (errors.length !== 0) {
+    throw new Error(errors.map(function (error) {
+      return error.message;
+    }).join('\n\n'));
+  }
+}
+/**
+ * Utility function which asserts a SDL document is valid by throwing an error
+ * if it is invalid.
+ *
+ * @internal
+ */
+
+
+function assertValidSDLExtension(documentAST, schema) {
+  var errors = validateSDL(documentAST, schema);
+
+  if (errors.length !== 0) {
+    throw new Error(errors.map(function (error) {
+      return error.message;
+    }).join('\n\n'));
+  }
 }
\ No newline at end of file
diff --git a/validation/validate.js.flow b/validation/validate.js.flow
index 61213f8..9fe1b2a 100644
--- a/validation/validate.js.flow
+++ b/validation/validate.js.flow
@@ -8,15 +8,15 @@
  */
 
 import invariant from '../jsutils/invariant';
-import { GraphQLError } from '../error';
+import type { GraphQLError } from '../error';
 import { visit, visitInParallel, visitWithTypeInfo } from '../language/visitor';
 import type { DocumentNode } from '../language/ast';
-import type { ASTVisitor } from '../language/visitor';
-import { GraphQLSchema } from '../type/schema';
+import type { GraphQLSchema } from '../type/schema';
 import { assertValidSchema } from '../type/validate';
 import { TypeInfo } from '../utilities/TypeInfo';
-import { specifiedRules } from './specifiedRules';
-import ValidationContext from './ValidationContext';
+import { specifiedRules, specifiedSDLRules } from './specifiedRules';
+import type { SDLValidationRule, ValidationRule } from './ValidationContext';
+import { SDLValidationContext, ValidationContext } from './ValidationContext';
 
 /**
  * Implements the "Validation" section of the spec.
@@ -36,36 +36,60 @@ import ValidationContext from './ValidationContext';
  */
 export function validate(
   schema: GraphQLSchema,
-  ast: DocumentNode,
-  rules?: $ReadOnlyArray<any>,
-  typeInfo?: TypeInfo,
+  documentAST: DocumentNode,
+  rules?: $ReadOnlyArray<ValidationRule> = specifiedRules,
+  typeInfo?: TypeInfo = new TypeInfo(schema),
 ): $ReadOnlyArray<GraphQLError> {
-  invariant(ast, 'Must provide document');
+  invariant(documentAST, 'Must provide document');
   // If the schema used for validation is invalid, throw an error.
   assertValidSchema(schema);
-  return visitUsingRules(
-    schema,
-    typeInfo || new TypeInfo(schema),
-    ast,
-    rules || specifiedRules,
-  );
+
+  const context = new ValidationContext(schema, documentAST, typeInfo);
+  // This uses a specialized visitor which runs multiple visitors in parallel,
+  // while maintaining the visitor skip and break API.
+  const visitor = visitInParallel(rules.map(rule => rule(context)));
+  // Visit the whole document with each instance of all provided rules.
+  visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
+  return context.getErrors();
+}
+
+// @internal
+export function validateSDL(
+  documentAST: DocumentNode,
+  schemaToExtend?: ?GraphQLSchema,
+  rules?: $ReadOnlyArray<SDLValidationRule> = specifiedSDLRules,
+): $ReadOnlyArray<GraphQLError> {
+  const context = new SDLValidationContext(documentAST, schemaToExtend);
+  const visitors = rules.map(rule => rule(context));
+  visit(documentAST, visitInParallel(visitors));
+  return context.getErrors();
 }
 
 /**
- * This uses a specialized visitor which runs multiple visitors in parallel,
- * while maintaining the visitor skip and break API.
+ * Utility function which asserts a SDL document is valid by throwing an error
+ * if it is invalid.
  *
  * @internal
  */
-function visitUsingRules(
-  schema: GraphQLSchema,
-  typeInfo: TypeInfo,
+export function assertValidSDL(documentAST: DocumentNode): void {
+  const errors = validateSDL(documentAST);
+  if (errors.length !== 0) {
+    throw new Error(errors.map(error => error.message).join('\n\n'));
+  }
+}
+
+/**
+ * Utility function which asserts a SDL document is valid by throwing an error
+ * if it is invalid.
+ *
+ * @internal
+ */
+export function assertValidSDLExtension(
   documentAST: DocumentNode,
-  rules: $ReadOnlyArray<(ValidationContext) => ASTVisitor>,
-): $ReadOnlyArray<GraphQLError> {
-  const context = new ValidationContext(schema, documentAST, typeInfo);
-  const visitors = rules.map(rule => rule(context));
-  // Visit the whole document with each instance of all provided rules.
-  visit(documentAST, visitWithTypeInfo(typeInfo, visitInParallel(visitors)));
-  return context.getErrors();
+  schema: GraphQLSchema,
+): void {
+  const errors = validateSDL(documentAST, schema);
+  if (errors.length !== 0) {
+    throw new Error(errors.map(error => error.message).join('\n\n'));
+  }
 }
diff --git a/validation/validate.mjs b/validation/validate.mjs
index 91d4756..4170787 100644
--- a/validation/validate.mjs
+++ b/validation/validate.mjs
@@ -7,13 +7,11 @@
  *  strict
  */
 import invariant from '../jsutils/invariant';
-import { GraphQLError } from '../error';
 import { visit, visitInParallel, visitWithTypeInfo } from '../language/visitor';
-import { GraphQLSchema } from '../type/schema';
 import { assertValidSchema } from '../type/validate';
 import { TypeInfo } from '../utilities/TypeInfo';
-import { specifiedRules } from './specifiedRules';
-import ValidationContext from './ValidationContext';
+import { specifiedRules, specifiedSDLRules } from './specifiedRules';
+import { SDLValidationContext, ValidationContext } from './ValidationContext';
 /**
  * Implements the "Validation" section of the spec.
  *
@@ -31,25 +29,61 @@ import ValidationContext from './ValidationContext';
  * will be created from the provided schema.
  */
 
-export function validate(schema, ast, rules, typeInfo) {
-  !ast ? invariant(0, 'Must provide document') : void 0; // If the schema used for validation is invalid, throw an error.
+export function validate(schema, documentAST) {
+  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;
+  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);
+  !documentAST ? invariant(0, 'Must provide document') : void 0; // If the schema used for validation is invalid, throw an error.
 
   assertValidSchema(schema);
-  return visitUsingRules(schema, typeInfo || new TypeInfo(schema), ast, rules || specifiedRules);
+  var context = new ValidationContext(schema, documentAST, typeInfo); // This uses a specialized visitor which runs multiple visitors in parallel,
+  // while maintaining the visitor skip and break API.
+
+  var visitor = visitInParallel(rules.map(function (rule) {
+    return rule(context);
+  })); // Visit the whole document with each instance of all provided rules.
+
+  visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
+  return context.getErrors();
+} // @internal
+
+export function validateSDL(documentAST, schemaToExtend) {
+  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;
+  var context = new SDLValidationContext(documentAST, schemaToExtend);
+  var visitors = rules.map(function (rule) {
+    return rule(context);
+  });
+  visit(documentAST, visitInParallel(visitors));
+  return context.getErrors();
 }
 /**
- * This uses a specialized visitor which runs multiple visitors in parallel,
- * while maintaining the visitor skip and break API.
+ * Utility function which asserts a SDL document is valid by throwing an error
+ * if it is invalid.
  *
  * @internal
  */
 
-function visitUsingRules(schema, typeInfo, documentAST, rules) {
-  var context = new ValidationContext(schema, documentAST, typeInfo);
-  var visitors = rules.map(function (rule) {
-    return rule(context);
-  }); // Visit the whole document with each instance of all provided rules.
+export function assertValidSDL(documentAST) {
+  var errors = validateSDL(documentAST);
 
-  visit(documentAST, visitWithTypeInfo(typeInfo, visitInParallel(visitors)));
-  return context.getErrors();
+  if (errors.length !== 0) {
+    throw new Error(errors.map(function (error) {
+      return error.message;
+    }).join('\n\n'));
+  }
+}
+/**
+ * Utility function which asserts a SDL document is valid by throwing an error
+ * if it is invalid.
+ *
+ * @internal
+ */
+
+export function assertValidSDLExtension(documentAST, schema) {
+  var errors = validateSDL(documentAST, schema);
+
+  if (errors.length !== 0) {
+    throw new Error(errors.map(function (error) {
+      return error.message;
+    }).join('\n\n'));
+  }
 }
\ No newline at end of file
